<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schemagenerator - {{ school.name if school else 'Okänd skola' }}</title>
    <style>
        /* --- (Samma stil som innan, oförändrad) --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem 2rem;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            color: #2d3748;
            font-size: 1.8rem;
        }
        .back-btn {
            background: #718096;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .back-btn:hover {
            background: #4a5568;
        }
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }
        .generator-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .card {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        .card h3 {
            margin-top: 0;
            color: #2d3748;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #4a5568;
        }
        .form-group select, .form-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        /* Multi-select klasser */
        .classes-container {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            background: #f7fafc;
            max-height: 200px;
            overflow-y: auto;
        }
        .class-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #e2e8f0;
        }
        .class-item:last-child {
            margin-bottom: 0;
        }
        .class-item input[type="checkbox"] {
            margin-right: 0.75rem;
            width: auto;
        }
        .class-item-info {
            flex: 1;
        }
        .class-name {
            font-weight: 600;
            color: #2d3748;
        }
        .class-details {
            font-size: 0.85rem;
            color: #718096;
        }
        .subjects-container {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            background: #f7fafc;
        }
        .class-subject-section {
            margin-bottom: 1rem;
        }
        .class-subject-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            gap: 0.5rem;
        }
        .subject-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 1rem;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }
        .subject-item:last-child {
            margin-bottom: 0;
        }
        .subject-item input, .subject-item select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        .add-subject-btn {
            background: #48bb78;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }
        .add-subject-btn:hover {
            background: #38a169;
        }
        .remove-subject-btn {
            background: #f56565;
            color: white;
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .remove-subject-btn:hover {
            background: #e53e3e;
        }
        .rooms-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .room-item {
            display: flex;
            align-items: center;
            background: #f7fafc;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .room-item input[type="checkbox"] {
            margin-right: 0.5rem;
            width: auto;
        }
        .constraints-section {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            background: #f7fafc;
        }
        .constraint-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .constraint-item input[type="checkbox"] {
            margin-right: 0.5rem;
            width: auto;
        }
        .time-range {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .lesson-duration-section {
            margin-top: 1rem;
            padding: 1rem;
            background: #f0f8ff;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
        }
        .btn {
            background: #4299e1;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s;
            font-weight: 600;
        }
        .btn:hover {
            background: #3182ce;
            transform: translateY(-1px);
        }
        .btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }
        .btn-generate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 100%;
            justify-self: center;
        }
        .btn-generate:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }
        .schedule-preview {
            min-height: 400px;
            background: #f7fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #718096;
            font-size: 1.1rem;
            position: relative;
            overflow-x: auto;
        }
        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 800px;
        }




        .schedule-status-indicator {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .class-item {
            position: relative;
            transition: all 0.2s ease;
        }

        .class-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .generation-controls {
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .reset-schedule-btn:hover {
            background: #e53e3e !important;
            transform: scale(1.02);
        }

        .save-status {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.85rem;
            margin: 0.5rem 0;
        }

        .save-status.unsaved {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }

        .save-status.saved {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .schedule-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .schedule-actions .btn {
            min-width: 120px;
            transition: all 0.2s ease;
        }

        .schedule-actions .btn:hover {
            transform: translateY(-1px);
        }

        .loading-save {
            opacity: 0.7;
            pointer-events: none;
        }

        /* Enhanced schedule table styles */
        .schedule-table {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .lesson-cell {
            vertical-align: top !important;
        }

        .lesson-subject {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: #2d3748;
        }

        .lesson-class {
            font-size: 0.8rem;
            color: #4a5568;
            margin-bottom: 0.25rem;
        }
        .schedule-table th {
            background: #4299e1;
            color: white;
            padding: 0.75rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }
        .schedule-table td {
            padding: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            text-align: center;
            vertical-align: middle;
            font-size: 0.85rem;
            min-width: 120px;
        }
        .schedule-table tr:hover {
            background: #f7fafc;
        }
        .lesson-cell {
            background: #ebf8ff;
            border-left: 3px solid #4299e1;
            font-size: 0.8rem;
            line-height: 1.1;
            text-align: left;
            padding: 0.4rem;
        }
        .lesson-subject {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.8rem;
        }
        .lesson-class {
            color: #4299e1;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .schedule-cell {
            overflow: visible !important; /* tillåt att .draggable-lesson sticker ut */
        }
        .spanning-lesson {
            box-sizing: border-box; /* säkerställ att padding inkluderas i höjden */
        }

        .lesson-room {
            color: #718096;
            font-size: 0.7rem;
        }
        .empty-cell {
            color: #a0aec0;
            font-style: italic;
            font-size: 0.8rem;
        }
        .generation-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #4299e1;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .alert {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            border-left: 4px solid;
        }
        .alert-success {
            background: #f0fff4;
            color: #22543d;
            border-color: #38a169;
        }
        .alert-error {
            background: #fed7d7;
            color: #c53030;
            border-color: #e53e3e;
        }
        .alert-info {
            background: #ebf8ff;
            color: #2c5282;
            border-color: #4299e1;
        }
        .alert-warning {
            background: #fffbeb;
            color: #744210;
            border-color: #f59e0b;
        }
        .debug-info {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #4a5568;
        }
        .validation-warning {
            background: #fffbeb;
            border-left: 4px solid #f59e0b;
            color: #744210;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 6px;
        }
        .selected-classes-info {
            background: #e6fffa;
            border: 1px solid #38b2ac;
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.5rem;
            color: #234e52;
        }
        .class-color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        @media (max-width: 1200px) {
            .generator-layout {
                grid-template-columns: 1fr;
            }
            .subject-item {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            .rooms-container {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📅 Multi-klass Schemagenerator - {{ school.name if school else 'Testskolan' }}</h1>
        <a href="#" class="back-btn">← Tillbaka till Dashboard</a>
    </div>

    <div class="container">



        <!-- Lägg till denna sektion INNAN formuläret i schedule_generator.html -->
        <!-- Lägg till denna sektion INNAN formuläret i schedule_generator.html -->
        <div class="card" style="margin-bottom: 2rem;">
            <h3>📚 Hantera Skolämnen & Lärarbehörigheter</h3>
            
            <div class="form-group">
                <label>Lägg till nytt ämne:</label>
                <div style="display: flex; gap: 1rem; align-items: end;">
                    <div style="flex: 1;">
                        <input type="text" id="newSubjectName" placeholder="Ämnesnamn (t.ex. Matematik, Svenska, Historia)" style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px;">
                    </div>
                    <button type="button" class="btn" onclick="addNewSubject()" style="background: #48bb78; white-space: nowrap;">+ Lägg till</button>
                </div>
            </div>
            
            <div class="form-group">
                <label>Befintliga ämnen & behöriga lärare:</label>
                <div id="existingSubjects" class="subjects-list" style="border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem; background: #f7fafc; min-height: 100px; max-height: 400px; overflow-y: auto;">
                    <div style="color: #666; text-align: center;" id="noSubjectsMessage">
                        Inga ämnen ännu. Lägg till ämnen ovan.
                    </div>
                </div>
            </div>
            
            <div class="alert alert-info" style="margin-top: 1rem;">
                <strong>💡 Tips:</strong> Ämnena du skapar här kommer att vara tillgängliga för alla klasser när du genererar scheman. Endast lärare som är markerade som behöriga kan schemaläggas för respektive ämne.
            </div>
        </div>

        <!-- Modal för lärarhantering -->
        <div id="teacherModal" class="modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
            <div class="modal-content" style="background: white; margin: 5% auto; padding: 2rem; width: 80%; max-width: 600px; border-radius: 12px; max-height: 80vh; overflow-y: auto;">
                <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #e2e8f0; padding-bottom: 1rem;">
                    <h3 id="modalTitle" style="margin: 0; color: #2d3748;">Hantera Lärarbehörigheter</h3>
                    <button class="close" onclick="closeTeacherModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>
                </div>
                
                <div id="modalContent" style="margin-bottom: 1.5rem;">
                    <!-- Content fylls dynamiskt -->
                </div>
                
                <div class="modal-footer" style="border-top: 1px solid #e2e8f0; padding-top: 1rem; text-align: right;">
                    <button type="button" class="btn" onclick="closeTeacherModal()" style="background: #718096;">Stäng</button>
                </div>
            </div>
        </div>

        
        <!-- Informationsbox om nya regler -->
        <div class="alert alert-info">
            <h4>📋 Multi-klass schemaläggningsregler</h4>
            <ul style="margin: 0.5rem 0;">
                <li><strong>5-minutersintervall:</strong> Lektioner kan starta var 5:e minut för flexibilitet</li>
                <li><strong>10-minuters paus:</strong> Minst 10 minuter mellan alla lektioner</li>
                <li><strong>Max 1 ämne per dag per klass:</strong> Varje klass kan bara ha 1 lektion i samma ämne per dag</li>
                <li><strong>Ingen klassrumskonflikt:</strong> Samma klassrum kan inte användas samtidigt av flera klasser</li>
                <li><strong>Max 5 lektioner per ämne:</strong> Per vecka och klass (1 per dag × 5 dagar)</li>
            </ul>
        </div>





        <!-- Add a schedule management section before the main generator -->
        <div class="card" style="margin-bottom: 2rem;" id="scheduleManagement">
            <h3>📅 Schemahantering</h3>
            
            <div class="form-group">
                <label>Snabbåtgärder:</label>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem;">
                    <button type="button" class="btn" onclick="viewAllClassSchedules()" style="background: #4299e1;">
                        👁️ Visa alla klassers scheman
                    </button>
                    <button type="button" class="btn" onclick="exportSchedulesToCSV()" style="background: #38b2ac;">
                        📊 Exportera scheman
                    </button>
                    <button type="button" class="btn" onclick="showScheduleStatistics()" style="background: #9f7aea;">
                        📈 Schemastatistik
                    </button>
                </div>
            </div>
            
            <div id="scheduleOverview" style="margin-top: 1rem; display: none;">
                <!-- Schedule overview will be populated by JavaScript -->
            </div>
        </div>

        <div class="generator-layout">
            <!-- Vänster sida - Inställningar -->
            <div class="card">
                <h3>⚙️ Multi-klass Schemainställningar</h3>
                
                <form id="scheduleForm">
                    <!-- Klassval - Nu multi-select -->
                    <div class="form-group">
                        <label>Välj klasser (flera klasser tillåtet):</label>
                        <div class="classes-container" id="classesContainer">
                            {% if classes %}
                                {% for class in classes %}
                                    <div class="class-item">
                                        <input type="checkbox" name="class_ids[]" value="{{ class.id }}" id="class_{{ class.id }}" onchange="updateSelectedClasses()">
                                        <div class="class-item-info">
                                            <div class="class-name">{{ class.name }}</div>
                                            <div class="class-details">
                                                {{ class.users|length if class.users else 0 }} elever
                                                {% if class.year_level %} - Årskurs {{ class.year_level }}{% endif %}
                                            </div>
                                        </div>
                                        <div class="class-color-indicator" style="background-color: {{ loop.cycle('#4299e1', '#48bb78', '#f56565', '#ed8936', '#9f7aea', '#38b2ac') }};"></div>
                                    </div>
                                {% endfor %}
                            {% else %}
                                <div style="text-align: center; color: #666;">
                                    <p>Inga klasser tillgängliga</p>
                                </div>
                            {% endif %}
                        </div>
                        <div class="selected-classes-info" id="selectedClassesInfo" style="display: none;">
                            <strong>Valda klasser:</strong> <span id="selectedClassesList"></span>
                        </div>
                    </div>

                    <!-- Ämnen och timmar per klass -->
                    <div class="form-group">
                        <label>Ämnen och timmar per vecka (per klass):</label>
                        <div class="validation-warning" id="subjectValidation" style="display: none;">
                            <strong>⚠️ Viktigt:</strong> Varje ämne kan max ha 5 lektioner per vecka per klass (1 per dag).
                        </div>
                        <div class="subjects-container" id="subjectsContainer">
                            <div id="subjectsPlaceholder" style="color:#666;">
                                Välj en eller flera klasser till vänster för att ange ämnen och timmar per klass.
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Tillgängliga klassrum:</label>
                        <div class="rooms-container">
                            {% if school and school.classrooms %}
                                {% set classrooms = school.classrooms | from_json %}
                                {% for classroom in classrooms %}
                                    <div class="room-item">
                                        <input type="checkbox" name="rooms[]" value="{{ classroom }}" id="room_{{ loop.index }}" checked>
                                        <label for="room_{{ loop.index }}">{{ classroom }}</label>
                                    </div>
                                {% endfor %}
                            {% else %}
                                <!-- Fallback if no classrooms are defined -->
                                <div class="room-item">
                                    <input type="checkbox" name="rooms[]" value="Sal A" id="room_a" checked>
                                    <label for="room_a">Sal A</label>
                                </div>
                                <div class="room-item">
                                    <input type="checkbox" name="rooms[]" value="Sal B" id="room_b" checked>
                                    <label for="room_b">Sal B</label>
                                </div>
                                <div class="room-item">
                                    <input type="checkbox" name="rooms[]" value="Sal C" id="room_c" checked>
                                    <label for="room_c">Sal C</label>
                                </div>
                            {% endif %}
                        </div>
                    </div>

                    <!-- Tidsinställningar -->
                    <div class="form-group">
                        <label>Schema-begränsningar:</label>
                        <div class="constraints-section">
                            <div class="constraint-item">
                                <input type="checkbox" id="balanced_days" name="constraints[]" value="balanced_days" checked>
                                <label for="balanced_days">Jämn fördelning över veckan</label>
                            </div>
                            <div class="constraint-item">
                                <input type="checkbox" id="morning_priority" name="constraints[]" value="morning_priority">
                                <label for="morning_priority">Prioritera förmiddagstid</label>
                            </div>
                            <div class="constraint-item">
                                <input type="checkbox" id="no_room_conflicts" name="constraints[]" value="no_room_conflicts" checked disabled>
                                <label for="no_room_conflicts">Förhindra klassrumskonflikter (automatiskt aktivt)</label>
                            </div>
                            
                            <div style="margin-top: 1rem;">
                                <label>Skoldagens timmar:</label>
                                <div class="time-range">
                                    <input type="time" name="start_time" value="08:00">
                                    <input type="time" name="end_time" value="15:00">
                                </div>
                            </div>

                            <!-- Lektionslängd sektion -->
                            
                        </div>
                    </div>

                    <button type="button" class="btn btn-generate" onclick="generateMultiClassSchedule()">
                        🎲 Generera Multi-klass Schema
                    </button>
                </form>
                
                <!-- Debug info -->
                <div id="debugInfo" class="debug-info" style="display: none;">
                    <h4>Debug Information:</h4>
                    <div id="debugContent"></div>
                </div>
            </div>

            <!-- Höger sida - Schemaförhandsvisning -->
            <div class="card">
                <h3>📋 Multi-klass Schemaförhandsvisning</h3>

                <div style="display:flex; gap:0.75rem; align-items:center; margin-bottom:0.75rem;">
                    <label for="classFilter" style="margin:0; font-weight:600; color:#4a5568;">Visa:</label>
                    <select id="classFilter" onchange="onClassFilterChange()" style="padding:0.5rem; border-radius:6px; border:1px solid #e2e8f0;">
                        <option value="all">Alla klasser</option>
                        <!-- JS fyller resterande -->
                    </select>

                    <label for="teacherFilter" style="margin:0; font-weight:600; color:#4a5568;">Lärare:</label>
                    <select id="teacherFilter" onchange="onTeacherFilterChange()" style="padding:0.5rem; border-radius:6px; border:1px solid #e2e8f0;">
                        <option value="all">Alla lärare</option>
                        <!-- JS fyller resterande -->
                    </select>
                </div>




                
                <div class="schedule-preview" id="schedulePreview">
                    <div style="text-align: center;">
                        <p>Välj klasser och ämnen för att generera ett multi-klass schema</p>
                        <p style="color: #a0aec0; font-size: 0.9rem;">
                            Multi-klass schema följer:<br>
                            • Automatisk klassrumshantering<br>
                            • Max 1 ämne per dag per klass<br>
                            • 5-minutersintervall med 10-min paus
                        </p>
                    </div>
                </div>

                <div class="generation-controls" id="generationControls" style="display: none;">
                    <div class="schedule-actions">
                        <button type="button" class="btn" onclick="generateMultiClassSchedule()">
                            🔄 Generera nytt
                        </button>
                        <button type="button" class="btn" style="background: #48bb78;" onclick="saveMultiClassSchedule()">
                            💾 Spara schema
                        </button>
                        <button type="button" class="btn reset-schedule-btn" style="background: #f56565;" onclick="resetClassSchedules()">
                            🗑️ Rensa scheman
                        </button>
                    </div>
                    
                    <div id="saveStatus" class="save-status" style="display: none;">
                        <!-- Status information will be populated by JavaScript -->
                    </div>
                    
                    <div class="alert alert-info" style="margin-top: 1rem; font-size: 0.85rem;">
                        <strong>💡 Tips:</strong>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>Spara schema:</strong> Sparar schemat permanent till databasen</li>
                            <li><strong>Rensa scheman:</strong> Tar bort befintliga scheman för valda klasser</li>
                            <li><strong>Generera nytt:</strong> Skapar ett nytt schema (ersätter inte sparat schema)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
            let availableTeachers = {{ available_teachers | tojson | safe }} || [];

            window.teacherRoomRestrictions = {};

            let globalRoomOccupancy = {};

            let currentSchedule = null;
            let availableSubjects = {{ available_subjects | tojson }};
            let availableClasses = {{ classes | tojson }};
            let selectedClasses = [];

            const classroomsFromServer = {{ classrooms | tojson | safe }}; // lista från backend
            let availableRooms = Array.isArray(classroomsFromServer) ? classroomsFromServer.map(r => String(r).trim()) : [];


            if (!availableRooms || availableRooms.length === 0) {
                availableRooms = ['Sal A', 'Sal B', 'Sal C', 'Sal D', 'Sal E'];
                console.warn('Ingen classroom-data hittades från servern — använder fallbackrum:', availableRooms);
            } else {
                console.log('Initierade klassrum från skolan:', availableRooms);
            }
            let scheduleScrollContainer = null;
            let autoScrollInterval = null;
            let dragScrollBounds = null;

            let isEditMode = false;
            let editingClassId = null;
            let editingClassName = null;
            let originalScheduleData = null;
            let draggedLesson = null;


            let isDragging = false;

            document.addEventListener('dragstart', function(e) {
                if (e.target.classList.contains('draggable-lesson')) {
                    isDragging = true;
                    document.body.classList.add('dragging');
                    e.target.classList.add('dragging');
                }
            });

            document.addEventListener('dragend', function(e) {
                if (e.target.classList.contains('draggable-lesson')) {
                    isDragging = false;
                    document.body.classList.remove('dragging');
                    e.target.classList.remove('dragging');
                }
            });

            // Lägg högst upp (efter att serverdata injicerats)
            let schoolSubjects = (typeof availableSubjects !== 'undefined' && Array.isArray(availableSubjects))
                ? availableSubjects.slice()   // kopiera så vi inte muterar originalet oväntat
                : (window.schoolSubjects || []);

            // och lägg gärna tillbaka på window om andra moduler förväntar sig det
            window.schoolSubjects = schoolSubjects;
            // Class colors for visual distinction
            const classColors = ['#4299e1', '#48bb78', '#f56565', '#ed8936', '#9f7aea', '#38b2ac', '#ec407a', '#26c6da', '#ab47bc', '#66bb6a'];

            // Debug flag
            const DEBUG = true;

            function debugLog(message, data = null) {
                if (DEBUG) {
                    console.log(`[MULTI-CLASS SCHEDULE DEBUG] ${message}`, data);
                    
                    const debugInfo = document.getElementById('debugInfo');
                    const debugContent = document.getElementById('debugContent');
                    
                    debugInfo.style.display = 'block';
                    debugContent.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${message}</div>`;
                    if (data) {
                        debugContent.innerHTML += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                    }
                }
            }

            function updateSelectedClasses() {
                const checkboxes = document.querySelectorAll('input[name="class_ids[]"]:checked');
                const infoDiv = document.getElementById('selectedClassesInfo');
                const listSpan = document.getElementById('selectedClassesList');
                
                // Build selectedClasses anew
                const tempSelected = Array.from(checkboxes).map(cb => {
                    const classId = cb.value;
                    const classData = availableClasses.find(c => c.id == classId);
                    return {
                        id: classId,
                        name: classData ? classData.name : `Klass ${classId}`
                    };
                });

                selectedClasses = tempSelected;

                if (selectedClasses.length > 0) {
                    infoDiv.style.display = 'block';
                    listSpan.innerHTML = selectedClasses.map((cls, index) => 
                        `<span style="color: ${classColors[index % classColors.length]};">●</span> ${cls.name}`
                    ).join(', ');
                    debugLog('Selected classes updated:', selectedClasses);
                } else {
                    infoDiv.style.display = 'none';
                    debugLog('No classes selected');
                }

                // Re-render per-class subject sections
                renderClassSubjectSections();
            }


            // Fyll klass-filtret (finns redan i din kod om du följde tidigare steg)
            function populateClassFilter() {
                const sel = document.getElementById('classFilter');
                if (!sel) return;
                // Ta bort tidigare genererade options
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());
                availableClasses.forEach(cls => {
                    const opt = document.createElement('option');
                    opt.value = cls.id;
                    opt.textContent = cls.name;
                    opt.setAttribute('data-generated', '1');
                    sel.appendChild(opt);
                });
            }



            
            // JavaScript för ämneshantering - lägg till i <script>-sektionen


            


            function updateClassStatusIndicators(statusData) {
                // Update class checkboxes with status indicators
                selectedClasses.forEach(cls => {
                    const checkbox = document.getElementById(`class_${cls.id}`);
                    if (!checkbox) return;

                    const classItem = checkbox.closest('.class-item');
                    if (!classItem) return;

                    // Remove existing status indicators
                    const existingIndicator = classItem.querySelector('.schedule-status-indicator');
                    if (existingIndicator) existingIndicator.remove();

                    // Find class status
                    const status = statusData.classes_status.find(s => s.class_id == cls.id);
                    
                    if (status) {
                        const indicator = document.createElement('div');
                        indicator.className = 'schedule-status-indicator';
                        indicator.style.cssText = `
                            font-size: 0.75rem; 
                            margin-top: 0.25rem;
                            padding: 0.125rem 0.375rem;
                            border-radius: 0.25rem;
                            ${status.has_schedule ? 
                                'background: #c6f6d5; color: #22543d; border: 1px solid #9ae6b4;' : 
                                'background: #fed7d7; color: #742a2a; border: 1px solid #feb2b2;'
                            }
                        `;
                        
                        if (status.has_schedule) {
                            indicator.innerHTML = `✅ Schema sparat (${status.lesson_count} lektioner)`;
                        } else {
                            indicator.innerHTML = `📝 Inget sparat schema`;
                        }

                        const classDetails = classItem.querySelector('.class-details');
                        if (classDetails) {
                            classDetails.appendChild(indicator);
                        }
                    }
                });

                // Update summary info
                updateScheduleSummary(statusData.summary);
            }


            async function updateClassScheduleStatus() {
                if (selectedClasses.length === 0) return;

                try {
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: selectedClasses.map(c => parseInt(c.id))
                        })
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        // Update status cache
                        result.classes_status.forEach(cls => {
                            scheduleSaveState.classScheduleStatus[cls.class_id] = cls;
                        });

                        // Update UI indicators
                        updateClassStatusIndicators(result);
                        debugLog('Class schedule status updated:', result);
                    }

                } catch (error) {
                    console.error('Error updating class schedule status:', error);
                    debugLog('Status update failed:', error);
                }
            }


            async function addNewSubject() {
                const input = document.getElementById('newSubjectName');
                const subjectName = input.value.trim();
                
                if (!subjectName) {
                    alert('Ange ett ämnesnamn');
                    return;
                }
                
                try {
                    const response = await fetch('/api/school_subjects', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ name: subjectName })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        schoolSubjects.push(data.subject);
                        availableSubjects.push(data.subject); // Uppdatera även global variabel
                        input.value = '';
                        renderSubjects();
                        debugLog('Subject added successfully:', data.subject);
                    } else {
                        alert(data.error || 'Fel vid sparande av ämne');
                    }
                } catch (error) {
                    console.error('Error adding subject:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }

            async function removeSubject(subjectId) {
                if (!confirm('Är du säker på att du vill ta bort detta ämne?')) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/school_subjects/${subjectId}`, {
                        method: 'DELETE'
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        schoolSubjects = schoolSubjects.filter(s => s.id !== subjectId);
                        availableSubjects = availableSubjects.filter(s => s.id !== subjectId); // Uppdatera även global variabel
                        renderSubjects();
                        debugLog('Subject removed successfully:', subjectId);
                    } else {
                        alert(data.error || 'Fel vid borttagning av ämne');
                    }
                } catch (error) {
                    console.error('Error removing subject:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }



            function updateScheduleSummary(summary) {
                const infoDiv = document.getElementById('selectedClassesInfo');
                if (!infoDiv) return;

                // Add summary after class list
                let existingSummary = infoDiv.querySelector('.schedule-summary');
                if (existingSummary) existingSummary.remove();

                if (summary.total_classes > 0) {
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'schedule-summary';
                    summaryDiv.style.cssText = `
                        margin-top: 0.5rem; 
                        padding: 0.5rem; 
                        background: #f7fafc; 
                        border-radius: 0.375rem; 
                        font-size: 0.85rem;
                        border-left: 3px solid #4299e1;
                    `;

                    summaryDiv.innerHTML = `
                        <strong>📊 Schemastatus:</strong><br>
                        ${summary.classes_with_schedule}/${summary.total_classes} klasser har scheman (${summary.total_lessons} totalt lektioner)<br>
                        ${summary.all_classes_have_schedule ? 
                            '<span style="color: #38a169;">✅ Alla klasser har scheman</span>' : 
                            '<span style="color: #d69e2e;">⚠️ Vissa klasser saknar scheman</span>'
                        }
                    `;

                    infoDiv.appendChild(summaryDiv);
                }
            }

            /**
             * Update the overall schedule UI based on current state
             */
            function updateScheduleUI() {
                const controls = document.getElementById('generationControls');
                if (!controls) return;

                // Check if we have unsaved changes
                const hasUnsaved = scheduleSaveState.hasUnsavedChanges;
                
                // Update save button
                const saveButton = controls.querySelector('button[onclick="saveMultiClassSchedule()"]');
                if (saveButton) {
                    if (hasUnsaved) {
                        saveButton.style.background = '#ed8936';
                        saveButton.innerHTML = '💾 Spara (osparade ändringar)';
                    } else {
                        saveButton.style.background = '#48bb78';
                        saveButton.innerHTML = '💾 Sparat';
                    }
                }

                // Add reset button if it doesn't exist
                let resetButton = controls.querySelector('.reset-schedule-btn');
                if (!resetButton) {
                    resetButton = document.createElement('button');
                    resetButton.type = 'button';
                    resetButton.className = 'btn reset-schedule-btn';
                    resetButton.style.cssText = 'background: #f56565; margin-left: 0.5rem;';
                    resetButton.onclick = resetClassSchedules;
                    resetButton.innerHTML = '🗑️ Rensa scheman';
                    controls.appendChild(resetButton);
                }
            }


            function updateSubjectDropdowns() {
                const subjectSelects = document.querySelectorAll('select[name^="subjects_"]');
                subjectSelects.forEach(select => {
                    // spara nuvarande val (kan vara string eller number)
                    const currentValue = String(select.value);

                    // bygg options från schoolSubjects
                    let optionsHtml = '<option value="">Välj ämne...</option>';
                    schoolSubjects.forEach(subject => {
                    optionsHtml += `<option value="${subject.id}">${subject.name}</option>`;
                    });

                    select.innerHTML = optionsHtml;

                    // återställ tidigare värde (jämför som sträng för säkerhet)
                    if (currentValue) {
                    const optToSet = Array.from(select.options).find(o => String(o.value) === currentValue);
                    if (optToSet) select.value = currentValue;
                    }
                });
            }



            let scheduleSaveState = {
                hasUnsavedChanges: false,
                lastSavedSchedule: null,
                classScheduleStatus: {}
            };

            // Uppdatera createSubjectItem funktionen för att använda schoolSubjects
           

            // Initiera ämneslistan när sidan laddas
            document.addEventListener('DOMContentLoaded', function() {
                renderSubjects();
            });


            
            


            
                

            // Fyll lärar-filtret - försök med availableTeachers, annars lämna "Alla lärare" tills schemat finns
            function populateTeacherFilter() {
                const sel = document.getElementById('teacherFilter');
                if (!sel) return;
                // Rensa tidigare genererade
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());

                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                    availableTeachers.forEach(t => {
                        const opt = document.createElement('option');
                        opt.value = t.id ?? t.name;
                        opt.textContent = t.name ?? t.displayName ?? t.id;
                        opt.setAttribute('data-generated', '1');
                        sel.appendChild(opt);
                    });
                    return;
                }

                // Om inga lärardata finns ännu - lämna standard 'Alla lärare' (vi kommer att fylla från schedule senare)
            }

            // Fyll teacher-filter från ett genererat schema (används efter generering om backend ej skickade teachers)
            function populateTeacherFilterFromSchedule(schedule) {
                const sel = document.getElementById('teacherFilter');
                if (!sel || !schedule || !Array.isArray(schedule.lessons)) return;
                // Ta bort gamla genererade options
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());

                const teacherSet = new Map();
                schedule.lessons.forEach(lesson => {
                    // Förväntar att lesson har property lesson.teacher_name eller lesson.teacher_id
                    const teacherName = lesson.teacher_name || lesson.teacher || null;
                    const teacherId = lesson.teacher_id || lesson.teacher || teacherName;
                    if (teacherName) {
                        if (!teacherSet.has(teacherId)) teacherSet.set(teacherId, teacherName);
                    }
                });

                Array.from(teacherSet.entries()).forEach(([id, name]) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = name;
                    opt.setAttribute('data-generated', '1');
                    sel.appendChild(opt);
                });
            }

            // Händelsehanterare för filter
            function onClassFilterChange() {
                const classSel = document.getElementById('classFilter');
                const teacherSel = document.getElementById('teacherFilter');
                const classVal = classSel && classSel.value !== 'all' ? classSel.value : null;
                const teacherVal = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
                if (currentSchedule) displayMultiClassSchedule(currentSchedule, classVal, teacherVal);
            }

            function onTeacherFilterChange() {
                const classSel = document.getElementById('classFilter');
                const teacherSel = document.getElementById('teacherFilter');
                const classVal = classSel && classSel.value !== 'all' ? classSel.value : null;
                const teacherVal = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
                if (currentSchedule) displayMultiClassSchedule(currentSchedule, classVal, teacherVal);
            }

            // Efter att currentSchedule deklarerats:
            window.currentSchedule = window.currentSchedule || null;
            window.multiClassSchedule = window.multiClassSchedule || window.currentSchedule;

            // När du uppdaterar schemat, håll båda synkade:
            function setCurrentSchedule(schedule) {
            currentSchedule = schedule;
            window.currentSchedule = schedule;
            window.multiClassSchedule = schedule;
            }


            function renderClassSubjectSections() {
                const container = document.getElementById('subjectsContainer');
                const placeholder = document.getElementById('subjectsPlaceholder');
                container.innerHTML = ''; // clear

                if (selectedClasses.length === 0) {
                    placeholder && container.appendChild(placeholder);
                    return;
                }

                // For each selected class, create a section
                selectedClasses.forEach((cls, idx) => {
                    const section = document.createElement('div');
                    section.className = 'class-subject-section';
                    section.id = `class_subjects_${cls.id}`;
                    section.setAttribute('data-class-id', cls.id);

                    const header = document.createElement('div');
                    header.className = 'class-subject-header';
                    header.innerHTML = `
                        <div style="display:flex; align-items:center; gap:0.5rem;">
                            <span class="class-color-indicator" style="background:${classColors[idx % classColors.length]}"></span>
                            <strong>${cls.name}</strong>
                            <span style="color:#718096; font-size:0.9rem; margin-left:0.5rem;">(Ange ämnen & timmar för denna klass)</span>
                        </div>
                        <div>
                            <button type="button" class="add-subject-btn" onclick="addSubjectForClass('${cls.id}')">+ Lägg till ämne</button>
                        </div>
                    `;
                    section.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'class-subject-list';
                    list.id = `class_subject_list_${cls.id}`;

                    // Add initial subject row
                    const subjectRow = createSubjectItem(cls.id);
                    list.appendChild(subjectRow);

                    section.appendChild(list);
                    container.appendChild(section);
                });

                // Re-validate subjects UI
                validateSubjectHours();
            }



            function populateClassFilter() {
                const sel = document.getElementById('classFilter');
                if (!sel) return;
                // Rensa utom 'Alla'
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());
                // Lägg till klasser från availableClasses
                availableClasses.forEach(cls => {
                    const opt = document.createElement('option');
                    opt.value = cls.id;
                    opt.textContent = cls.name;
                    opt.setAttribute('data-generated', '1');
                    sel.appendChild(opt);
                });
            }


            // Uppdatera renderSubjects funktionen för att inkludera lärarhantering
            // 3. Uppdatera renderSubjects funktionen (JavaScript - ersätt befintlig):
            function renderSubjects() {
                const container = document.getElementById('existingSubjects');
                const noMessage = document.getElementById('noSubjectsMessage');
                
                if (schoolSubjects.length === 0) {
                    noMessage.style.display = 'block';
                    container.innerHTML = '<div style="color: #666; text-align: center;" id="noSubjectsMessage">Inga ämnen ännu. Lägg till ämnen ovan.</div>';
                    return;
                }
                
                noMessage.style.display = 'none';
                
                let html = '';
                schoolSubjects.forEach(subject => {
                    html += `
                        <div class="subject-item" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: white; border-radius: 6px; margin-bottom: 0.5rem; border: 1px solid #e2e8f0;">
                            <div style="flex: 1;">
                                <div>
                                    <strong style="color: #2d3748;">${subject.name}</strong>
                                    <span id="teacherCount_${subject.id}" style="color: #718096; font-size: 0.85rem; margin-left: 0.5rem;">
                                        (Laddar lärare...)
                                    </span>
                                </div>
                                <div id="qualifiedTeachers_${subject.id}" style="margin-top: 0.25rem; font-size: 0.8rem; color: #4a5568;">
                                    <!-- Behöriga lärare visas här -->
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <button type="button" class="btn" onclick="manageTeachers(${subject.id}, '${subject.name}')" 
                                        style="background: #4299e1; color: white; padding: 0.375rem 0.75rem; font-size: 0.8rem;">
                                    👨‍🏫 Lärare
                                </button>
                                <button type="button" class="btn" onclick="manageTeacherRooms(${subject.id}, '${subject.name}')" 
                                        style="background: #9f7aea; color: white; padding: 0.375rem 0.75rem; font-size: 0.8rem;">
                                    🏫 Rum
                                </button>
                                <button type="button" class="remove-subject-btn" onclick="removeSubject(${subject.id})" 
                                        style="background: #f56565; color: white; padding: 0.25rem 0.5rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                    Ta bort
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                
                // Ladda lärarbehörigheter för varje ämne
                schoolSubjects.forEach(subject => {
                    loadTeacherQualifications(subject.id);
                });
                
                // Uppdatera ämnesdropdowns i formuläret
                updateSubjectDropdowns();
            }

            // Ladda och visa behöriga lärare för ett ämne
            async function loadTeacherQualifications(subjectId) {
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const countSpan = document.getElementById(`teacherCount_${subjectId}`);
                        const teachersDiv = document.getElementById(`qualifiedTeachers_${subjectId}`);
                        
                        const qualifiedCount = data.qualified_teachers.length;
                        countSpan.textContent = `(${qualifiedCount} behörig${qualifiedCount !== 1 ? 'a' : ''} lärare)`;
                        countSpan.style.color = qualifiedCount > 0 ? '#38a169' : '#e53e3e';
                        
                        if (qualifiedCount > 0) {
                            const teacherNames = data.qualified_teachers.map(t => t.name).slice(0, 3);
                            let displayText = teacherNames.join(', ');
                            if (qualifiedCount > 3) {
                                displayText += ` +${qualifiedCount - 3} till`;
                            }
                            teachersDiv.innerHTML = `Behöriga: ${displayText}`;
                        } else {
                            teachersDiv.innerHTML = '<span style="color: #e53e3e;">⚠️ Inga behöriga lärare - schema kan inte genereras</span>';
                        }
                    }
                } catch (error) {
                    console.error('Error loading teacher qualifications:', error);
                    const countSpan = document.getElementById(`teacherCount_${subjectId}`);
                    if (countSpan) {
                        countSpan.textContent = '(Fel vid laddning)';
                        countSpan.style.color = '#e53e3e';
                    }
                }
            }


            function markScheduleAsUnsaved() {
                scheduleSaveState.hasUnsavedChanges = true;
                updateScheduleUI();
            }

            // Hantera lärare för ett ämne
            async function manageTeachers(subjectId, subjectName) {
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        alert('Fel vid laddning av lärardata');
                        return;
                    }
                    
                    const modalTitle = document.getElementById('modalTitle');
                    const modalContent = document.getElementById('modalContent');
                    
                    modalTitle.textContent = `Lärarbehörigheter för ${subjectName}`;
                    
                    let html = `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="color: #2d3748; margin-bottom: 0.75rem;">Behöriga lärare (${data.qualified_teachers.length})</h4>
                            <div id="qualifiedTeachersList" style="background: #f0fff4; border: 1px solid #38a169; border-radius: 6px; padding: 1rem; min-height: 60px;">
                    `;
                    
                    if (data.qualified_teachers.length > 0) {
                        data.qualified_teachers.forEach(teacher => {
                            html += `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: white; border-radius: 4px; margin-bottom: 0.5rem; border: 1px solid #c6f6d5;">
                                    <div>
                                        <strong>${teacher.name}</strong>
                                        <span style="color: #666; font-size: 0.9rem; margin-left: 0.5rem;">(${teacher.username})</span>
                                    </div>
                                    <button onclick="removeTeacherQualification(${subjectId}, ${teacher.id}, '${teacher.name}', '${subjectName}')" 
                                            style="background: #f56565; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">
                                        Ta bort
                                    </button>
                                </div>
                            `;
                        });
                    } else {
                        html += '<p style="color: #666; text-align: center; margin: 0;">Inga behöriga lärare ännu</p>';
                    }
                    
                    html += `
                            </div>
                        </div>
                        
                        <div>
                            <h4 style="color: #2d3748; margin-bottom: 0.75rem;">Lägg till behörig lärare</h4>
                            <div style="background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem;">
                                <select id="teacherSelect" style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; margin-bottom: 1rem;">
                                    <option value="">Välj lärare...</option>
                    `;
                    
                    data.available_teachers.forEach(teacher => {
                        if (!teacher.is_qualified) {
                            html += `<option value="${teacher.id}">${teacher.name} (${teacher.username})</option>`;
                        }
                    });
                    
                    html += `
                                </select>
                                <button onclick="addTeacherQualification(${subjectId}, '${subjectName}')" 
                                        style="background: #48bb78; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                    + Lägg till behörighet
                                </button>
                            </div>
                        </div>
                    `;
                    
                    modalContent.innerHTML = html;
                    document.getElementById('teacherModal').style.display = 'block';
                    
                } catch (error) {
                    console.error('Error loading teachers:', error);
                    alert('Fel vid laddning av lärardata');
                }
            }

            // Lägg till lärarbehörighet
            async function addTeacherQualification(subjectId, subjectName) {
                const select = document.getElementById('teacherSelect');
                const teacherId = select.value;
                
                if (!teacherId) {
                    alert('Välj en lärare först');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ teacher_id: parseInt(teacherId) })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Stäng modal och uppdatera visning
                        closeTeacherModal();
                        loadTeacherQualifications(subjectId);
                        alert(data.message);
                    } else {
                        alert(data.error || 'Fel vid tillägg av behörighet');
                    }
                } catch (error) {
                    console.error('Error adding teacher qualification:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }



            // Ta bort lärarbehörighet
            async function removeTeacherQualification(subjectId, teacherId, teacherName, subjectName) {
                if (!confirm(`Är du säker på att du vill ta bort ${teacherName}s behörighet att undervisa i ${subjectName}?`)) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ teacher_id: teacherId })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Stäng modal och uppdatera visning
                        closeTeacherModal();
                        loadTeacherQualifications(subjectId);
                        alert(data.message);
                    } else {
                        alert(data.error || 'Fel vid borttagning av behörighet');
                    }
                } catch (error) {
                    console.error('Error removing teacher qualification:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }

            function closeTeacherModal() {
                document.getElementById('teacherModal').style.display = 'none';
            }

            // Stäng modal vid klick utanför
            window.onclick = function(event) {
                const modal = document.getElementById('teacherModal');
                if (event.target === modal) {
                    closeTeacherModal();
                }
            }



            async function manageTeacherRooms(subjectId, subjectName) {
                try {
                    // Hämta behöriga lärare för ämnet
                    const qualResponse = await fetch(`/api/teacher_qualifications/${subjectId}`);
                    const qualData = await qualResponse.json();
                    
                    if (!qualData.success) {
                        alert('Fel vid laddning av lärardata');
                        return;
                    }
                    
                    if (qualData.qualified_teachers.length === 0) {
                        alert('Inga behöriga lärare finns för detta ämne. Lägg till behöriga lärare först.');
                        return;
                    }
                    
                    const modalTitle = document.getElementById('modalTitle');
                    const modalContent = document.getElementById('modalContent');
                    
                    modalTitle.textContent = `Rumstillgång för lärare i ${subjectName}`;
                    
                    let html = `
                        <div style="margin-bottom: 1.5rem;">
                            <p style="color: #666; margin-bottom: 1rem;">
                                Hantera vilka klassrum som lärare får hålla lektioner i. 
                                <strong>Tom lista = tillgång till alla rum</strong>
                            </p>
                    `;
                    
                    // Lista behöriga lärare och deras rumstillgång
                    for (const teacher of qualData.qualified_teachers) {
                        html += `
                            <div style="border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 0.75rem;">
                                    <h4 style="margin: 0; color: #2d3748;">${teacher.name}</h4>
                                    <button onclick="showTeacherRoomModal(${teacher.id}, '${teacher.name}')" 
                                            style="background: #4299e1; color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        Hantera rum
                                    </button>
                                </div>
                                <div id="teacherRooms_${teacher.id}" style="font-size: 0.9rem; color: #4a5568;">
                                    <span style="color: #9ca3af;">Laddar...</span>
                                </div>
                            </div>
                        `;
                    }
                    
                    html += '</div>';
                    
                    modalContent.innerHTML = html;
                    
                    // Ladda rumstillgång för varje lärare
                    for (const teacher of qualData.qualified_teachers) {
                        loadTeacherRoomAccess(teacher.id);
                    }
                    
                    document.getElementById('teacherModal').style.display = 'block';
                    
                } catch (error) {
                    console.error('Error loading teacher room management:', error);
                    alert('Fel vid laddning av rumhantering');
                }
            }


            // 3. FÖRBÄTTRA loadTeacherRoomRestrictions för att säkerställa korrekt inläsning:
            async function loadTeacherRoomRestrictions() {
                try {
                    if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                        window.teacherRoomRestrictions = {};
                        
                        debugLog('Loading room restrictions for teachers:', availableTeachers.map(t => ({id: t.id, name: t.name})));
                        
                        for (const teacher of availableTeachers) {
                            try {
                                const response = await fetch(`/api/teacher_room_access/${teacher.id}`);
                                const data = await response.json();
                                
                                if (data.success) {
                                    // KRITISK FIX: Korrekt hantering av has_restrictions
                                    if (data.has_restrictions && data.accessible_rooms && data.accessible_rooms.length > 0) {
                                        // Läraren har specifika rumsbegränsningar - endast dessa rum
                                        window.teacherRoomRestrictions[teacher.id] = data.accessible_rooms;
                                        debugLog(`✅ Teacher ${teacher.name} (${teacher.id}) restricted to rooms:`, data.accessible_rooms);
                                    } else {
                                        // INGA begränsningar = tillgång till alla rum (null istället för tom array)
                                        window.teacherRoomRestrictions[teacher.id] = null;
                                        debugLog(`✅ Teacher ${teacher.name} (${teacher.id}) has access to ALL rooms (no restrictions)`);
                                    }
                                } else {
                                    // Fel vid hämtning - anta inga begränsningar
                                    window.teacherRoomRestrictions[teacher.id] = null;
                                    debugLog(`⚠️ Could not load restrictions for teacher ${teacher.name} (${teacher.id}), assuming no restrictions`);
                                }
                            } catch (error) {
                                console.error(`Error loading restrictions for teacher ${teacher.id}:`, error);
                                window.teacherRoomRestrictions[teacher.id] = null;
                            }
                        }
                        
                        debugLog('✅ Teacher room restrictions loaded completely:', window.teacherRoomRestrictions);
                    } else {
                        debugLog('⚠️ No availableTeachers found, cannot load room restrictions');
                        window.teacherRoomRestrictions = {};
                    }
                } catch (error) {
                    console.error('Critical error loading teacher room restrictions:', error);
                    window.teacherRoomRestrictions = {};
                }
            }

            async function loadTeacherRoomAccess(teacherId) {
                try {
                    const response = await fetch(`/api/teacher_room_access/${teacherId}`);
                    const data = await response.json();
                    
                    const container = document.getElementById(`teacherRooms_${teacherId}`);
                    if (!container) return;
                    
                    if (data.success) {
                        if (data.has_restrictions && data.accessible_rooms.length > 0) {
                            container.innerHTML = `
                                <strong>Begränsade rum:</strong> ${data.accessible_rooms.join(', ')}
                                <div style="margin-top: 0.25rem; font-size: 0.8rem; color: #e53e3e;">
                                    ⚠️ Endast dessa rum tillåtna
                                </div>
                            `;
                        } else {
                            container.innerHTML = `
                                <span style="color: #38a169;">✓ Tillgång till alla rum</span>
                            `;
                        }
                    } else {
                        container.innerHTML = '<span style="color: #e53e3e;">Fel vid laddning</span>';
                    }
                } catch (error) {
                    console.error('Error loading teacher room access:', error);
                    const container = document.getElementById(`teacherRooms_${teacherId}`);
                    if (container) {
                        container.innerHTML = '<span style="color: #e53e3e;">Fel vid laddning</span>';
                    }
                }
            }

            async function showTeacherRoomModal(teacherId, teacherName) {
                try {
                    const response = await fetch(`/api/teacher_room_access/${teacherId}`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        alert('Fel vid laddning av rumstillgång');
                        return;
                    }
                    
                    // Skapa ny modal för rumhantering
                    const existingModal = document.getElementById('roomAccessModal');
                    if (existingModal) {
                        existingModal.remove();
                    }
                    
                    const modalHtml = `
                        <div id="roomAccessModal" style="display: block; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4);">
                            <div style="background-color: #fefefe; margin: 5% auto; padding: 20px; border-radius: 8px; width: 600px; max-width: 90%; max-height: 80%; overflow-y: auto;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                                    <h3 style="margin: 0; color: #2d3748;">Rumstillgång för ${teacherName}</h3>
                                    <span onclick="closeRoomAccessModal()" style="cursor: pointer; font-size: 1.5rem; color: #9ca3af;">&times;</span>
                                </div>
                                
                                <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px;">
                                    <p style="margin: 0; font-size: 0.9rem; color: #0c4a6e;">
                                        <strong>Tips:</strong> Lämna listan tom för att ge läraren tillgång till alla rum. 
                                        Lägg till specifika rum för att begränsa tillgången.
                                    </p>
                                </div>
                                
                                <div style="margin-bottom: 1.5rem;">
                                    <h4 style="color: #2d3748; margin-bottom: 0.75rem;">Tillgängliga rum (${data.accessible_rooms.length})</h4>
                                    <div id="accessibleRoomsList" style="background: #f0fff4; border: 1px solid #38a169; border-radius: 6px; padding: 1rem; min-height: 60px;">
                                        ${data.accessible_rooms.length > 0 ? 
                                            data.accessible_rooms.map(room => `
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: white; border-radius: 4px; margin-bottom: 0.5rem; border: 1px solid #c6f6d5;">
                                                    <span><strong>${room}</strong></span>
                                                    <button onclick="removeTeacherRoomAccess(${teacherId}, '${room}')" 
                                                            style="background: #f56565; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">
                                                        Ta bort
                                                    </button>
                                                </div>
                                            `).join('') 
                                            : '<p style="color: #666; text-align: center; margin: 0;">Inga rumsbegränsningar - tillgång till alla rum</p>'
                                        }
                                    </div>
                                </div>
                                
                                <div>
                                    <h4 style="color: #2d3748; margin-bottom: 0.75rem;">Lägg till rumstillgång</h4>
                                    <div style="background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem;">
                                        <select id="roomSelect_${teacherId}" style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; margin-bottom: 1rem;">
                                            <option value="">Välj rum...</option>
                                            ${data.available_rooms.filter(room => !data.accessible_rooms.includes(room)).map(room => 
                                                `<option value="${room}">${room}</option>`
                                            ).join('')}
                                        </select>
                                        <button onclick="addTeacherRoomAccess(${teacherId})" 
                                                style="background: #48bb78; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                            + Lägg till rum
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.insertAdjacentHTML('beforeend', modalHtml);
                    
                } catch (error) {
                    console.error('Error showing room access modal:', error);
                    alert('Fel vid visning av rumstillgång');
                }
            }

            async function addTeacherRoomAccess(teacherId) {
                const select = document.getElementById(`roomSelect_${teacherId}`);
                const roomName = select.value;
                
                if (!roomName) {
                    alert('Välj ett rum först');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/teacher_room_access/${teacherId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ classroom_name: roomName })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        closeRoomAccessModal();
                        loadTeacherRoomAccess(teacherId);
                        alert(data.message);
                    } else {
                        alert(data.error || 'Fel vid tillägg av rumstillgång');
                    }
                } catch (error) {
                    console.error('Error adding room access:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }

            async function removeTeacherRoomAccess(teacherId, roomName) {
                if (!confirm(`Är du säker på att du vill ta bort tillgången till ${roomName}?`)) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/teacher_room_access/${teacherId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ classroom_name: roomName })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        closeRoomAccessModal();
                        loadTeacherRoomAccess(teacherId);
                        alert(data.message);
                    } else {
                        alert(data.error || 'Fel vid borttagning av rumstillgång');
                    }
                } catch (error) {
                    console.error('Error removing room access:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }

            function closeRoomAccessModal() {
                const modal = document.getElementById('roomAccessModal');
                if (modal) {
                    modal.remove();
                }
            }

            



            function createSubjectItem(classId, selectedSubjectId = '') {
                const item = document.createElement('div');
                item.className = 'subject-item';

                let optionsHtml = '<option value="">Välj ämne...</option>';
                schoolSubjects.forEach(subject => {
                    optionsHtml += `<option value="${subject.id}">${subject.name}</option>`;
                });

                item.innerHTML = `
                    <select name="subjects_${classId}[]" required onchange="validateSubjectHours()">
                    ${optionsHtml}
                    </select>
                    <input type="number" name="hours_${classId}[]" min="1" max="5" placeholder="Timmar/vecka (max 5)" required onchange="validateSubjectHours()">
                    <button type="button" class="remove-subject-btn" onclick="removeSubject(this)">Ta bort</button>
                `;

                // sätt valt ämne om det skickats in
                if (selectedSubjectId) {
                    item.querySelector('select').value = String(selectedSubjectId);
                }

                return item;
            }


            function getSubjectNameById(subjectId) {
                if (subjectId === null || subjectId === undefined) return null;
                const idStr = String(subjectId);

                // 1) Sök i schoolSubjects (primärt)
                const fromSchool = (Array.isArray(schoolSubjects) ? schoolSubjects : []).find(x => String(x.id) === idStr);
                if (fromSchool) return fromSchool.name;

                // 2) Sök i availableSubjects (fallback / äldre tabell)
                const fromAvailable = (Array.isArray(availableSubjects) ? availableSubjects : []).find(x => String(x.id) === idStr);
                if (fromAvailable) return fromAvailable.name;

                return null;
            }



    




            function addSubjectForClass(classId) {
                const list = document.getElementById(`class_subject_list_${classId}`);
                if (!list) return;
                const newRow = createSubjectItem(classId);
                list.appendChild(newRow);
                debugLog(`Added subject row for class ${classId}`);
            }

            function removeSubject(button) {
                const list = button.parentElement.parentElement; // .class-subject-list or just parent
                const sectionList = list.classList && list.classList.contains('class-subject-list') ? list : button.parentElement.parentElement;
                // Try to find the sibling rows to ensure at least one remains per class
                const container = button.closest('.class-subject-section');
                if (!container) return;
                const rows = container.querySelectorAll('.subject-item');
                if (rows.length > 1) {
                    button.parentElement.remove();
                    validateSubjectHours();
                    debugLog('Removed subject row', {classSection: container.id});
                } else {
                    // Don't allow removing last row
                    alert('Minst ett ämne måste finnas per klass. Lägg till ett annat ämne först om du vill ta bort detta.');
                    debugLog('Attempted to remove last subject row - blocked');
                }
            }

            function validateSubjectHours() {
                const allHourInputs = document.querySelectorAll('input[type="number"][name^="hours_"]');
                const validationWarning = document.getElementById('subjectValidation');
                let hasViolation = false;

                allHourInputs.forEach(input => {
                    const value = parseInt(input.value);
                    if (value > 5) {
                        hasViolation = true;
                        input.style.borderColor = '#e53e3e';
                        input.style.backgroundColor = '#fed7d7';
                    } else {
                        input.style.borderColor = '#e2e8f0';
                        input.style.backgroundColor = 'white';
                    }
                });

                if (hasViolation) {
                    validationWarning.style.display = 'block';
                } else {
                    validationWarning.style.display = 'none';
                }
            }


            // Optimize daily schedule with flexible lesson durations and mandatory lunch
            // 2. FIX: Uppdatera optimizeDailySchedule för att hantera rumsbrist
            // Update optimizeDailySchedule to include stricter room checking before placement
            function optimizeDailySchedule(daySubjects, startMinutes, endMinutes, classInfo, day, rooms, teacherAvailability) {
                const dayLessons = [];
                if (daySubjects.length === 0) return dayLessons;
                
                const actualRooms = (rooms && rooms.length) ? rooms : getAvailableRooms();
                
                // Define lunch break constraints
                const lunchStartEarliest = timeToMinutes('10:30');
                const lunchStartLatest = timeToMinutes('12:15');
                const lunchDuration = Math.random() > 0.5 ? 45 : 60;
                
                // Calculate available time excluding lunch
                const totalAvailableTime = (endMinutes - startMinutes) - lunchDuration;
                const baseTimePerLesson = Math.floor(totalAvailableTime / daySubjects.length);
                let lessonDuration = Math.max(50, Math.min(100, baseTimePerLesson));
                
                // Adjust if needed to fit all lessons
                const totalNeededTime = daySubjects.length * lessonDuration + lunchDuration;
                if (totalNeededTime > (endMinutes - startMinutes)) {
                    lessonDuration = Math.floor((endMinutes - startMinutes - lunchDuration) / daySubjects.length);
                    lessonDuration = Math.max(50, Math.min(100, lessonDuration));
                }
                
                // STRICT time tracking to prevent overlaps
                const occupiedTimes = [];
                const subjectQueue = [...daySubjects];
                const failedPlacements = [];
                
                let currentTime = startMinutes;
                let lunchPlaced = false;
                
                while (subjectQueue.length > 0) {
                    const subject = subjectQueue.shift();
                    let lessonPlaced = false;
                    let attempts = 0;
                    const maxAttemptsPerSubject = 50;
                    
                    // Check if we should place lunch break
                    if (!lunchPlaced && shouldPlaceLunchNow(currentTime, lunchStartEarliest, lunchStartLatest, subjectQueue.length + 1, lessonDuration)) {
                        occupiedTimes.push({
                            start: currentTime,
                            end: currentTime + lunchDuration,
                            type: 'lunch'
                        });
                        currentTime += lunchDuration;
                        lunchPlaced = true;
                    }
                    
                    while (!lessonPlaced && attempts < maxAttemptsPerSubject) {
                        let lessonStart = currentTime + (attempts * 5);
                        
                        if (lessonStart + lessonDuration > endMinutes) {
                            lessonStart = startMinutes + (attempts * 10);
                        }
                        
                        if (lessonStart + lessonDuration > endMinutes) {
                            break;
                        }
                        
                        const lessonEnd = lessonStart + lessonDuration;
                        
                        // STRICT control of time overlaps
                        let hasOverlap = false;
                        for (const occupied of occupiedTimes) {
                            if (!(lessonEnd <= occupied.start || lessonStart >= occupied.end)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                        
                        if (!hasOverlap && lessonEnd <= endMinutes) {
                            const timeSlot = `${minutesToTime(lessonStart)}-${minutesToTime(lessonEnd)}`;
                            
                            // CHECK ROOM AVAILABILITY BEFORE booking
                            const currentRoomOccupancy = globalRoomOccupancy[day] && globalRoomOccupancy[day][timeSlot] ? 
                                globalRoomOccupancy[day][timeSlot].size : 0;
                            
                            if (currentRoomOccupancy >= actualRooms.length) {
                                debugLog(`✗ All rooms occupied for ${day} ${timeSlot} (${currentRoomOccupancy}/${actualRooms.length})`);
                                attempts++;
                                continue;
                            }
                            
                            const availableRoom = findAvailableRoom(actualRooms, day, timeSlot, teacherAvailability);
                            
                            if (availableRoom) {
                                const teacherAssignment = assignOptimalTeacher(subject, day, timeSlot, teacherAvailability);
                                
                                if (teacherAssignment) {
                                    const lessonData = {
                                        day: day,
                                        time: timeSlot,
                                        class_id: subject.class_id,
                                        class_name: subject.class_name || `Klass ${subject.class_id}`,
                                        subject_id: subject.subject_id,
                                        school_subject_id: subject.school_subject_id || subject.subject_id,
                                        subject_name: subject.subject_name || 'Okänt ämne',
                                        room: availableRoom,
                                        teacher_id: teacherAssignment?.teacher_id || null,
                                        teacher_name: teacherAssignment?.teacher_name || 'Ingen lärare',
                                        color: subject.color || '#9f7aea',
                                        duration: lessonDuration,
                                        optimized: true
                                    };
                                    
                                    dayLessons.push(lessonData);
                                    
                                    occupiedTimes.push({
                                        start: lessonStart,
                                        end: lessonEnd,
                                        type: 'lesson',
                                        lesson: lessonData
                                    });
                                    
                                    if (teacherAvailability[teacherAssignment.teacher_id]) {
                                        teacherAvailability[teacherAssignment.teacher_id][day].push({
                                            start: lessonStart,
                                            end: lessonEnd,
                                            lessonId: `${subject.class_name}-${subject.subject_name}-${timeSlot}`
                                        });
                                    }
                                    
                                    lessonPlaced = true;
                                    currentTime = Math.max(currentTime, lessonEnd + 5);
                                    
                                    debugLog(`✓ Lesson placed: ${subject.class_name}-${subject.subject_name} ${timeSlot} in ${availableRoom}`);
                                    break;
                                    
                                } else {
                                    // No teacher - release room IMMEDIATELY
                                    if (globalRoomOccupancy[day] && globalRoomOccupancy[day][timeSlot]) {
                                        globalRoomOccupancy[day][timeSlot].delete(availableRoom);
                                    }
                                }
                            } else {
                                debugLog(`✗ No room available for ${day} ${timeSlot}`);
                            }
                        }
                        
                        attempts++;
                    }
                    
                    if (!lessonPlaced) {
                        failedPlacements.push(subject);
                        debugLog(`⚠️ Could not place ${subject.class_name}-${subject.subject_name} on ${day}`);
                    }
                }
                
                return dayLessons;
            }


            // Determine if lunch should be placed at current time
            function shouldPlaceLunchNow(currentTime, lunchEarliest, lunchLatest, remainingLessons, lessonDuration) {
                // Must be within lunch time window
                if (currentTime < lunchEarliest) return false;
                
                // If we're past the latest start time, must place now
                if (currentTime >= lunchLatest) return true;
                
                // Smart placement: try to place lunch in the middle of the day
                const estimatedEndTime = currentTime + (remainingLessons * (lessonDuration + 5));
                const middleTime = currentTime + ((estimatedEndTime - currentTime) / 2);
                
                // Place lunch if we're near the middle and within acceptable window
                return (currentTime >= lunchEarliest && currentTime <= middleTime);
            }


            // Calculate compactness score for the schedule
            function calculateCompactScore(allLessons, classes) {
                let totalScore = 0;
                
                classes.forEach(classInfo => {
                    const classLessons = allLessons.filter(l => l.class_id === classInfo.id);
                    let classScore = 0;
                    
                    // Group by day
                    const dayGroups = {};
                    classLessons.forEach(lesson => {
                        if (!dayGroups[lesson.day]) dayGroups[lesson.day] = [];
                        dayGroups[lesson.day].push(lesson);
                    });
                    
                    // Calculate compactness for each day
                    Object.values(dayGroups).forEach(dayLessons => {
                        if (dayLessons.length <= 1) {
                            classScore += 100; // Perfect score for single lesson days
                            return;
                        }
                        
                        // Sort by start time
                        const sortedLessons = dayLessons.sort((a, b) => {
                            const aStart = timeToMinutes(a.time.split('-')[0]);
                            const bStart = timeToMinutes(b.time.split('-')[0]);
                            return aStart - bStart;
                        });
                        
                        // Calculate time span and gaps
                        const firstStart = timeToMinutes(sortedLessons[0].time.split('-')[0]);
                        const lastEnd = timeToMinutes(sortedLessons[sortedLessons.length - 1].time.split('-')[1]);
                        const totalSpan = lastEnd - firstStart;
                        
                        // Calculate actual lesson time
                        const totalLessonTime = sortedLessons.reduce((sum, lesson) => {
                            const [start, end] = lesson.time.split('-');
                            return sum + (timeToMinutes(end) - timeToMinutes(start));
                        }, 0);
                        
                        // Compactness score: higher is better (more lessons packed into shorter time span)
                        const compactness = totalLessonTime > 0 ? (totalLessonTime / totalSpan) * 100 : 0;
                        classScore += Math.max(0, Math.min(100, compactness));
                    });
                    
                    totalScore += classScore / Object.keys(dayGroups).length;
                });
                
                return Math.round(totalScore / classes.length);
            }



            async function loadExistingSchedules() {
                try {
                    // Hämta alla klasser som redan har scheman
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });
                    
                    const result = await response.json();
                    if (!response.ok || !result.success) {
                        debugLog('Could not load existing schedules, proceeding without constraints');
                        return {};
                    }
                    
                    // Bygg teacherAvailability från befintliga scheman
                    const existingAvailability = {};
                    const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                    
                    // Initialisera struktur
                    if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers)) {
                        availableTeachers.forEach(teacher => {
                            existingAvailability[teacher.id] = {};
                            weekdays.forEach(day => {
                                existingAvailability[teacher.id][day] = [];
                            });
                        });
                    }
                    
                    // Ladda detaljer för klasser med scheman (utom de vi ska generera för)
                    const classesWithSchedule = result.classes_status.filter(cls => 
                        cls.has_schedule && !selectedClasses.find(sc => sc.id == cls.class_id)
                    );
                    
                    for (const cls of classesWithSchedule) {
                        try {
                            const detailResponse = await fetch(`/api/class_schedule/status/${cls.class_id}`);
                            const detailResult = await detailResponse.json();
                            
                            if (detailResult.success && detailResult.lessons_by_day) {
                                Object.entries(detailResult.lessons_by_day).forEach(([day, lessons]) => {
                                    lessons.forEach(lesson => {
                                        // Hitta lärare för denna lektion
                                        const teacherId = lesson.teacher_id || lesson.teacher_name;
                                        if (teacherId && existingAvailability[teacherId]) {
                                            const [startTime, endTime] = lesson.time.split('-');
                                            const startMinutes = timeToMinutes(startTime);
                                            const endMinutes = timeToMinutes(endTime);
                                            
                                            existingAvailability[teacherId][day].push({
                                                start: startMinutes,
                                                end: endMinutes,
                                                lessonId: `existing-${cls.class_name}-${lesson.subject}-${lesson.time}`,
                                                class: cls.class_name,
                                                subject: lesson.subject,
                                                isExisting: true
                                            });
                                        }
                                    });
                                });
                            }
                        } catch (error) {
                            debugLog(`Error loading details for class ${cls.class_name}:`, error);
                        }
                    }
                    
                    debugLog('Loaded existing teacher availability:', existingAvailability);
                    return existingAvailability;
                    
                } catch (error) {
                    debugLog('Error loading existing schedules:', error);
                    return {};
                }
            }

            // Count successfully placed lunch breaks
            function countLunchBreaks(allLessons, classes) {
                let lunchBreaksFound = 0;
                
                classes.forEach(classInfo => {
                    const classLessons = allLessons.filter(l => l.class_id === classInfo.id);
                    
                    // Group by day and check for lunch break gaps
                    const dayGroups = {};
                    classLessons.forEach(lesson => {
                        if (!dayGroups[lesson.day]) dayGroups[lesson.day] = [];
                        dayGroups[lesson.day].push(lesson);
                    });
                    
                    Object.values(dayGroups).forEach(dayLessons => {
                        if (dayLessons.length <= 1) return;
                        
                        const sortedLessons = dayLessons.sort((a, b) => {
                            const aStart = timeToMinutes(a.time.split('-')[0]);
                            const bStart = timeToMinutes(b.time.split('-')[0]);
                            return aStart - bStart;
                        });
                        
                        // Look for lunch-sized gaps between 10:30-13:00
                        for (let i = 0; i < sortedLessons.length - 1; i++) {
                            const currentEnd = timeToMinutes(sortedLessons[i].time.split('-')[1]);
                            const nextStart = timeToMinutes(sortedLessons[i + 1].time.split('-')[0]);
                            const gap = nextStart - currentEnd;
                            
                            if (gap >= 45 && currentEnd >= timeToMinutes('10:30') && nextStart <= timeToMinutes('13:00')) {
                                lunchBreaksFound++;
                                break; // Only count one lunch per day per class
                            }
                        }
                    });
                });
                
                return lunchBreaksFound;
            }


            // Add room conflict validation before saving
            function validateRoomBookings(lessons) {
                const conflicts = [];
                const roomBookings = {};
                
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!roomBookings[key]) {
                        roomBookings[key] = new Set();
                    }
                    
                    if (roomBookings[key].has(lesson.room)) {
                        conflicts.push({
                            room: lesson.room,
                            time: key,
                            conflict: `Room ${lesson.room} is double-booked at ${lesson.day} ${lesson.time}`
                        });
                    } else {
                        roomBookings[key].add(lesson.room);
                    }
                });
                
                return conflicts;
            }



            // Hämta tillgängliga rum för en specifik lärare
            function getAvailableRoomsForTeacher(teacherId) {
                const allRooms = getAvailableRooms();
                
                if (!window.teacherRoomRestrictions || !window.teacherRoomRestrictions[teacherId]) {
                    // Inga begränsningar = tillgång till alla rum
                    return allRooms;
                }
                
                const teacherRestrictions = window.teacherRoomRestrictions[teacherId];
                if (teacherRestrictions === null) {
                    // Explicit null = inga begränsningar
                    return allRooms;
                }
                
                // Array med specifika rum = endast dessa rum
                return allRooms.filter(room => teacherRestrictions.includes(room));
            }

            // Hitta tillgängligt rum för lärare utan att påverka global occupancy än
            function findAvailableRoomForTeacher(teacherRooms, day, timeSlot) {
                if (!globalRoomOccupancy[day] || !globalRoomOccupancy[day][timeSlot]) {
                    // Inget rum är upptaget än
                    return teacherRooms.length > 0 ? teacherRooms[0] : null;
                }
                
                const occupiedRooms = globalRoomOccupancy[day][timeSlot];
                
                // Hitta första lediga rum som läraren har tillgång till
                for (const room of teacherRooms) {
                    if (!occupiedRooms.has(room)) {
                        return room;
                    }
                }
                
                return null; // Inga rum tillgängliga för denna lärare
            }

            // Ersätt findAvailableRoom funktionen med denna rättade version:
            // Replace the existing findAvailableRoom function with this improved version
            function findAvailableRoom(rooms, day, timeSlot, teacherAvailability, preferredTeacherId = null) {
                const roomList = (rooms && rooms.length) ? rooms : getAvailableRooms();
                
                // Ensure global room occupancy structure exists
                if (!globalRoomOccupancy) {
                    globalRoomOccupancy = {};
                }
                if (!globalRoomOccupancy[day]) {
                    globalRoomOccupancy[day] = {};
                }
                if (!globalRoomOccupancy[day][timeSlot]) {
                    globalRoomOccupancy[day][timeSlot] = new Set();
                }
                
                const [startTime, endTime] = timeSlot.split('-');
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                
                // Kontrollera överlappande tider
                const overlappingSlots = Object.keys(globalRoomOccupancy[day] || {}).filter(slot => {
                    const [slotStart, slotEnd] = slot.split('-');
                    const slotStartMin = timeToMinutes(slotStart);
                    const slotEndMin = timeToMinutes(slotEnd);
                    
                    return !(endMinutes <= slotStartMin || startMinutes >= slotEndMin);
                });
                
                // Samla alla upptagna rum för överlappande tider
                const allOccupiedRooms = new Set();
                overlappingSlots.forEach(slot => {
                    if (globalRoomOccupancy[day][slot]) {
                        globalRoomOccupancy[day][slot].forEach(room => allOccupiedRooms.add(room));
                    }
                });
                
                // KRITISK FIX: Filtrera rum baserat på lärarens begränsningar
                let availableRoomsForTeacher = roomList;
                if (preferredTeacherId && window.teacherRoomRestrictions) {
                    const teacherRestrictions = window.teacherRoomRestrictions[preferredTeacherId];
                    
                    if (teacherRestrictions !== null && teacherRestrictions !== undefined) {
                        // Läraren har specifika rumsbegränsningar - endast dessa rum är tillåtna
                        availableRoomsForTeacher = roomList.filter(room => teacherRestrictions.includes(room));
                        debugLog(`Teacher ${preferredTeacherId} restricted to rooms:`, teacherRestrictions, 'Available after filtering:', availableRoomsForTeacher);
                    } else {
                        // teacherRestrictions är null = inga begränsningar, tillgång till alla rum
                        availableRoomsForTeacher = roomList;
                        debugLog(`Teacher ${preferredTeacherId} has access to ALL rooms (no restrictions)`);
                    }
                }
                
                // Find first available room that teacher has access to
                for (const room of availableRoomsForTeacher) {
                    if (!allOccupiedRooms.has(room)) {
                        globalRoomOccupancy[day][timeSlot].add(room);
                        debugLog(`✅ Room reserved: ${room} for ${day} ${timeSlot} (teacher ${preferredTeacherId || 'any'})`);
                        return room;
                    }
                }
                
                debugLog(`❌ No available rooms for teacher ${preferredTeacherId || 'any'} on ${day} ${timeSlot}. Teacher restrictions:`, 
                    window.teacherRoomRestrictions?.[preferredTeacherId] || 'none', 
                    'Available rooms after filtering:', availableRoomsForTeacher,
                    'All occupied rooms:', Array.from(allOccupiedRooms));
                return null;
            }






            // Check if teacher is available for a specific time slot
            function isTeacherAvailableForTimeSlot(teacherId, day, startMinutes, endMinutes, teacherAvailability) {
                if (!teacherAvailability[teacherId] || !teacherAvailability[teacherId][day]) {
                    return true;
                }

                const teacherLessons = teacherAvailability[teacherId][day];
                const minBreak = 5;

                for (const lesson of teacherLessons) {
                    if (!(endMinutes + minBreak <= lesson.start || startMinutes >= lesson.end + minBreak)) {
                        return false;
                    }
                }

                return true;
            }


            // Lägg till denna funktion i ditt JavaScript (runt rad 2400, före assignTeacherToLesson)

            // Lägg till denna variabel högst upp i script-sektionen, efter andra globala variabler
            let teacherAvailability = {};

            // Uppdatera isTeacherAvailable funktionen
            function isTeacherAvailable(teacherId, day, timeSlot, lessonDurationMinutes) {
                // Säkerställ att teacherAvailability är initialiserat
                if (!teacherAvailability || typeof teacherAvailability !== 'object') {
                    teacherAvailability = {};
                }
                
                if (!teacherAvailability[teacherId] || !teacherAvailability[teacherId][day]) {
                    return true; // Om ingen data finns, anta att läraren är tillgänglig
                }
                
                const [startTime, endTime] = timeSlot.split('-');
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                const minBreak = 5; // 5 minuters paus mellan lektioner
                
                const teacherLessons = teacherAvailability[teacherId][day];
                
                for (const lesson of teacherLessons) {
                    // Kontrollera om det finns överlappning eller otillräcklig paus
                    if (!(endMinutes + minBreak <= lesson.start || startMinutes >= lesson.end + minBreak)) {
                        return false; // Läraren är inte tillgänglig
                    }
                }
                
                return true; // Läraren är tillgänglig
            }


            // Add teacher assignment function
            function assignTeacherToLesson(lesson, day, timeSlot) {
                const [startTime, endTime] = timeSlot.split('-');
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);

                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                    const qualifiedAndAvailableTeachers = availableTeachers.filter(teacher => {
                        const isTimeAvailable = isTeacherAvailable(teacher.id, day, timeSlot, 60);
                        let isQualified = true;
                        if (teacher.qualified_subjects && Array.isArray(teacher.qualified_subjects)) {
                            isQualified = teacher.qualified_subjects.includes(parseInt(lesson.subject_id));
                        }
                        return isTimeAvailable && isQualified;
                    });

                    if (qualifiedAndAvailableTeachers.length > 0) {
                        const selectedTeacher = qualifiedAndAvailableTeachers[Math.floor(Math.random() * qualifiedAndAvailableTeachers.length)];
                        
                        if (!teacherAvailability[selectedTeacher.id]) {
                            teacherAvailability[selectedTeacher.id] = {};
                        }
                        if (!teacherAvailability[selectedTeacher.id][day]) {
                            teacherAvailability[selectedTeacher.id][day] = [];
                        }

                        teacherAvailability[selectedTeacher.id][day].push({
                            start: startMinutes,
                            end: endMinutes,
                            lessonId: `${lesson.class_name}-${lesson.subject_name}-${timeSlot}`,
                            class: lesson.class_name,
                            subject: lesson.subject_name
                        });

                        return {
                            teacher_id: selectedTeacher.id,
                            teacher_name: selectedTeacher.name || selectedTeacher.username || 'Lärare'
                        };
                    }
                }

                // ÄNDRING: Returnera null istället för fallback-lärare  
                return null; // INGEN backup-lärare
            }

            // Assign optimal teacher considering qualifications and availability
            // 2. ERSÄTT assignOptimalTeacher funktionen för att skicka teacher_id till findAvailableRoom:
            function assignOptimalTeacher(subject, day, timeSlot, teacherAvailability) {
                const [startTime, endTime] = timeSlot.split('-');
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);

                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                    const qualifiedAndAvailableTeachers = availableTeachers.filter(teacher => {
                        // Check availability
                        const isTimeAvailable = isTeacherAvailableForTimeSlot(teacher.id, day, startMinutes, endMinutes, teacherAvailability);
                        
                        // Check qualifications
                        let isQualified = true;
                        if (teacher.qualified_subjects && Array.isArray(teacher.qualified_subjects)) {
                            isQualified = teacher.qualified_subjects.includes(parseInt(subject.subject_id));
                        }
                        
                        return isTimeAvailable && isQualified;
                    });

                    // KRITISK FIX: Kontrollera rumstillgång för varje kvalificerad lärare
                    for (const teacher of qualifiedAndAvailableTeachers) {
                        // Kontrollera om läraren kan få ett rum baserat på sina begränsningar
                        const teacherRooms = getAvailableRoomsForTeacher(teacher.id);
                        const availableRoom = findAvailableRoomForTeacher(teacherRooms, day, timeSlot);
                        
                        if (availableRoom) {
                            // Reservera rummet globalt
                            if (!globalRoomOccupancy[day][timeSlot]) {
                                globalRoomOccupancy[day][timeSlot] = new Set();
                            }
                            globalRoomOccupancy[day][timeSlot].add(availableRoom);
                            
                            debugLog(`✅ Teacher ${teacher.name} assigned room ${availableRoom} for ${subject.subject_name} on ${day} ${timeSlot}`);
                            return {
                                teacher_id: teacher.id,
                                teacher_name: teacher.name || teacher.username || 'Lärare',
                                assigned_room: availableRoom
                            };
                        } else {
                            debugLog(`❌ Teacher ${teacher.name} has no available rooms for ${day} ${timeSlot} - restrictions:`, 
                                window.teacherRoomRestrictions?.[teacher.id] || 'no restrictions');
                        }
                    }
                }

                debugLog(`❌ No teachers with room access available for ${subject.subject_name} on ${day} ${timeSlot}`);
                return null;
            }



            // Distribute subjects across weekdays (max 1 lesson per subject per day)
            function distributeSubjectsAcrossDays(subjectPlans, weekdays) {
                const dailyPlans = {};
                weekdays.forEach(day => dailyPlans[day] = []);
                
                // Group by subject
                const subjectGroups = {};
                subjectPlans.forEach(plan => {
                    if (!subjectGroups[plan.subject_name]) {
                        subjectGroups[plan.subject_name] = [];
                    }
                    subjectGroups[plan.subject_name].push(plan);
                });
                
                // Distribute each subject across days
                Object.values(subjectGroups).forEach(group => {
                    group.forEach((lesson, index) => {
                        const dayIndex = index % weekdays.length;
                        dailyPlans[weekdays[dayIndex]].push(lesson);
                    });
                });
                
                return dailyPlans;
            }


            // LÄGG TILL denna nya valideringsfunktion:
            function validateNoRoomOverlaps(allLessons) {
                const conflicts = [];
                const roomTimeMap = new Map();
                
                allLessons.forEach(lesson => {
                    const [startTime, endTime] = lesson.time.split('-');
                    const startMinutes = timeToMinutes(startTime);
                    const endMinutes = timeToMinutes(endTime);
                    
                    const key = `${lesson.day}-${lesson.room}`;
                    
                    if (!roomTimeMap.has(key)) {
                        roomTimeMap.set(key, []);
                    }
                    
                    const existingBookings = roomTimeMap.get(key);
                    
                    // Kontrollera överlappning med befintliga bokningar
                    for (const booking of existingBookings) {
                        if (!(endMinutes <= booking.start || startMinutes >= booking.end)) {
                            conflicts.push({
                                room: lesson.room,
                                day: lesson.day,
                                conflict1: `${lesson.class_name} - ${lesson.subject_name} (${lesson.time})`,
                                conflict2: `${booking.class_name} - ${booking.subject_name} (${booking.time})`,
                                overlap: true
                            });
                        }
                    }
                    
                    // Lägg till denna bokning
                    existingBookings.push({
                        start: startMinutes,
                        end: endMinutes,
                        time: lesson.time,
                        class_name: lesson.class_name,
                        subject_name: lesson.subject_name
                    });
                });
                
                return conflicts;
            }



            // Enhanced room validation function - replace existing validateStrictRoomBookings
            function validateStrictRoomBookings(lessons) {
                const conflicts = [];
                const roomBookings = {};
                let totalSlots = 0;
                let occupiedSlots = 0;
                
                // Group lessons by day and time
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!roomBookings[key]) {
                        roomBookings[key] = new Map(); // room -> lesson
                    }
                    
                    totalSlots++;
                    
                    // Check if room is already booked for this time
                    if (roomBookings[key].has(lesson.room)) {
                        const existingLesson = roomBookings[key].get(lesson.room);
                        conflicts.push({
                            room: lesson.room,
                            time: key,
                            conflict1: `${existingLesson.class_name} - ${existingLesson.subject_name}`,
                            conflict2: `${lesson.class_name} - ${lesson.subject_name}`,
                            message: `Room ${lesson.room} double-booked at ${key}`
                        });
                    } else {
                        roomBookings[key].set(lesson.room, lesson);
                        occupiedSlots++;
                    }
                });
                
                // Calculate room utilization
                const roomUtilization = totalSlots > 0 ? occupiedSlots / totalSlots : 0;
                
                return {
                    conflicts,
                    totalRoomSlots: totalSlots,
                    occupiedRoomSlots: occupiedSlots,
                    roomUtilization,
                    isValid: conflicts.length === 0
                };
            }


            // Smart Schedule Generator - Kompakt schema med flexibel lektionslängd
            // UPPDATERAD generateSmartCompactScheduleWithConstraints med bättre rumskontroll
            // ERSÄTT HELA generateSmartCompactScheduleWithConstraints funktionen:
            function generateSmartCompactScheduleWithConstraints(classes, classSubjectMap, rooms, startTime = '08:00', endTime = '15:00', existingTeacherAvailability = {}) {
                debugLog('Generating SMART schedule with ANTI-OVERLAP room control:', {
                    classes: classes.length, 
                    rooms: rooms.length,
                    classSubjectMap: classSubjectMap
                });
                
                const actualRooms = (rooms && rooms.length) ? rooms : getAvailableRooms();
                if (!actualRooms || actualRooms.length === 0) {
                    throw new Error('Inga klassrum valda. Välj minst ett klassrum.');
                }

                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                const allLessons = [];
                
                // RESET global room occupancy - critical to prevent conflicts
                globalRoomOccupancy = {};
                weekdays.forEach(day => {
                    globalRoomOccupancy[day] = {};
                });
                
                // Initialize teacher availability
                teacherAvailability = JSON.parse(JSON.stringify(existingTeacherAvailability));
                
                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers)) {
                    availableTeachers.forEach(teacher => {
                        if (!teacherAvailability[teacher.id]) {
                            teacherAvailability[teacher.id] = {};
                            weekdays.forEach(day => {
                                teacherAvailability[teacher.id][day] = [];
                            });
                        }
                    });
                }
                
                // Create hour-based lesson plans
                const exactHourPlan = [];
                const hourCounter = {};
                
                classes.forEach(classInfo => {
                    const cid = classInfo.id;
                    const className = classInfo.name || `Klass ${cid}`;
                    hourCounter[cid] = {};
                    
                    const items = classSubjectMap[cid] || [];
                    items.forEach(item => {
                        const subjectId = item.subject_id;
                        const schoolSubjectId = item.school_subject_id || subjectId;
                        const subjectName = getSubjectNameById(subjectId) || `Ämne ${subjectId}`;
                        const hoursPerWeek = parseInt(item.hours);
                        
                        if (hoursPerWeek > 5) {
                            throw new Error(`Ämnet "${subjectName}" för klass ${className} har ${hoursPerWeek} timmar, men max 5 är tillåtet`);
                        }
                        
                        hourCounter[cid][subjectName] = {
                            required: hoursPerWeek,
                            placed: 0
                        };
                        
                        exactHourPlan.push({
                            class_id: cid,
                            class_name: className,
                            subject_id: subjectId,
                            school_subject_id: schoolSubjectId,
                            subject_name: subjectName,
                            hours_required: hoursPerWeek,
                            hours_placed: 0,
                            color: classInfo.color || classColors[classes.indexOf(classInfo) % classColors.length],
                            priority: Math.random()
                        });
                    });
                });
                
                // Sort for fair distribution
                exactHourPlan.sort((a, b) => a.priority - b.priority);
                
                // Global schedule layout
                const globalSchedule = {};
                const subjectHoursByDay = {};
                
                weekdays.forEach(day => {
                    globalSchedule[day] = [];
                    subjectHoursByDay[day] = {};
                    classes.forEach(cls => {
                        subjectHoursByDay[day][cls.id] = {};
                    });
                });
                
                // MAIN SCHEDULING LOOP with STRICT room control
                let placedSubjects = 0;
                const maxAttempts = exactHourPlan.length * 20;
                let attempts = 0;
                
                while (exactHourPlan.length > 0 && attempts < maxAttempts) {
                    attempts++;
                    const subjectPlan = exactHourPlan.shift();
                    const remainingHours = subjectPlan.hours_required - subjectPlan.hours_placed;
                    
                    if (remainingHours <= 0) {
                        placedSubjects++;
                        continue;
                    }
                    
                    let hoursPlacedThisRound = 0;
                    const daysToTry = weekdays.slice().sort(() => Math.random() - 0.5);
                    
                    for (const day of daysToTry) {
                        if (hoursPlacedThisRound >= remainingHours) break;
                        
                        // Check if subject already has hours today (max 1 lesson per subject per day)
                        const subjectHoursToday = subjectHoursByDay[day][subjectPlan.class_id][subjectPlan.subject_name] || 0;
                        if (subjectHoursToday > 0) continue;
                        
                        const classLessonsToday = globalSchedule[day].filter(l => l.class_id === subjectPlan.class_id);
                        const hoursNeeded = Math.min(remainingHours - hoursPlacedThisRound, 2);
                        const lessonDurationMinutes = Math.floor(hoursNeeded * 60);
                        
                        const possibleSlots = generateFlexibleTimeSlots(startTime, endTime, lessonDurationMinutes, classLessonsToday);
                        
                        for (const timeSlot of possibleSlots) {
                            // ANTI-OVERLAP room check
                            const availableRoom = findAvailableRoom(actualRooms, day, timeSlot, teacherAvailability);
                            
                            if (availableRoom) {
                                const teacherAssignment = assignOptimalTeacher(subjectPlan, day, timeSlot, teacherAvailability);
                                
                                if (teacherAssignment) {
                                    // KRITISK FIX: Använd rummet som redan tilldelats av assignOptimalTeacher
                                    const finalRoom = teacherAssignment.assigned_room || availableRoom;
                                    
                                    const lessonData = {
                                        day: day,
                                        time: timeSlot,
                                        class_id: subjectPlan.class_id,
                                        class_name: subjectPlan.class_name,
                                        subject_id: subjectPlan.subject_id,
                                        school_subject_id: subjectPlan.school_subject_id,
                                        subject_name: subjectPlan.subject_name,
                                        room: finalRoom, // Använd det rum som läraren faktiskt kan använda
                                        teacher_id: teacherAssignment.teacher_id,
                                        teacher_name: teacherAssignment.teacher_name,
                                        color: subjectPlan.color,
                                        duration_hours: hoursNeeded,
                                        duration_minutes: lessonDurationMinutes,
                                        optimized: true
                                    };
                                    
                                    // Add to schedule
                                    globalSchedule[day].push(lessonData);
                                    allLessons.push(lessonData);
                                    
                                    // Update counters
                                    subjectPlan.hours_placed += hoursNeeded;
                                    hourCounter[subjectPlan.class_id][subjectPlan.subject_name].placed += hoursNeeded;
                                    
                                    // Track subject per day
                                    if (!subjectHoursByDay[day][subjectPlan.class_id][subjectPlan.subject_name]) {
                                        subjectHoursByDay[day][subjectPlan.class_id][subjectPlan.subject_name] = 0;
                                    }
                                    subjectHoursByDay[day][subjectPlan.class_id][subjectPlan.subject_name] += hoursNeeded;
                                    
                                    // Update teacher availability
                                    if (teacherAvailability[teacherAssignment.teacher_id]) {
                                        const [startTime, endTime] = timeSlot.split('-');
                                        teacherAvailability[teacherAssignment.teacher_id][day].push({
                                            start: timeToMinutes(startTime),
                                            end: timeToMinutes(endTime),
                                            lessonId: `${subjectPlan.class_name}-${subjectPlan.subject_name}-${timeSlot}`,
                                            hours: hoursNeeded
                                        });
                                    }
                                    
                                    hoursPlacedThisRound += hoursNeeded;
                                    
                                    debugLog(`✅ Placed ${hoursNeeded}h of ${subjectPlan.class_name}-${subjectPlan.subject_name} on ${day} ${timeSlot} in ${availableRoom}`);
                                    break;
                                    
                                } else {
                                    // No teacher, release room IMMEDIATELY
                                    if (globalRoomOccupancy[day] && globalRoomOccupancy[day][timeSlot]) {
                                        globalRoomOccupancy[day][timeSlot].delete(availableRoom);
                                    }
                                    debugLog(`✗ No teacher available, room ${availableRoom} released`);
                                }
                            } else {
                                debugLog(`✗ No room available for ${day} ${timeSlot}`);
                            }
                        }
                    }
                    
                    // If hours placed, re-queue if not complete
                    if (subjectPlan.hours_placed < subjectPlan.hours_required) {
                        subjectPlan.priority += 1;
                        subjectPlan.retry_count = (subjectPlan.retry_count || 0) + 1;
                        
                        if (subjectPlan.retry_count < 30) {
                            exactHourPlan.push(subjectPlan);
                        } else {
                            debugLog(`❌ Could not place all hours for ${subjectPlan.class_name}-${subjectPlan.subject_name}. Placed: ${subjectPlan.hours_placed}/${subjectPlan.hours_required}h`);
                        }
                    } else {
                        placedSubjects++;
                    }
                }
                
                // ANTI-OVERLAP validation
                const overlapConflicts = validateNoRoomOverlaps(allLessons);
                if (overlapConflicts.length > 0) {
                    debugLog('CRITICAL: Room overlap conflicts detected:', overlapConflicts);
                    throw new Error(`❌ RUMSKONFLIKTER MED ÖVERLAPPNING: ${overlapConflicts.length} konflikter. Öka antalet klassrum.`);
                }
                
                // Create final stats
                const totalHoursPlaced = allLessons.reduce((sum, lesson) => sum + (lesson.duration_hours || 1), 0);
                
                const hourDistribution = {};
                classes.forEach(cls => {
                    const className = cls.name || `Klass ${cls.id}`;
                    hourDistribution[className] = {};
                    
                    Object.entries(hourCounter[cls.id] || {}).forEach(([subjectName, counter]) => {
                        const status = counter.placed === counter.required ? '✓' : '⚠️';
                        hourDistribution[className][subjectName] = `${counter.placed}/${counter.required}h ${status}`;
                    });
                });

                const finalStats = {
                    total_lessons: allLessons.length,
                    total_hours: totalHoursPlaced,
                    lessons_per_class: classes.reduce((acc, cls) => {
                        const className = cls.name || `Klass ${cls.id}`;
                        acc[className] = allLessons.filter(l => l.class_id === cls.id).length;
                        return acc;
                    }, {}),
                    hour_distribution: hourDistribution,
                    rooms_used: [...new Set(allLessons.map(l => l.room))],
                    teachers_used: [...new Set(allLessons.filter(l => l.teacher_name).map(l => l.teacher_name))],
                    placement_success_rate: `${placedSubjects} subjects completed`,
                    hour_accuracy: `${totalHoursPlaced} timmar placerade`,
                    validation_status: 'PASSED - Anti-overlap room booking validated'
                };
                
                debugLog('✅ ANTI-OVERLAP SCHEDULING COMPLETE:', finalStats);

                return {
                    lessons: allLessons,
                    time_slots: [...new Set(allLessons.map(l => l.time))].sort((a, b) => {
                        const aStart = timeToMinutes(a.split('-')[0]);
                        const bStart = timeToMinutes(b.split('-')[0]);
                        return aStart - bStart;
                    }),
                    classes: classes,
                    stats: finalStats
                };
            }






            // Add room conflict checking before finalizing schedule
            function checkFinalRoomConflicts() {
                let conflicts = 0;
                Object.keys(globalRoomOccupancy).forEach(day => {
                    Object.keys(globalRoomOccupancy[day]).forEach(timeSlot => {
                        const roomsAtTime = globalRoomOccupancy[day][timeSlot];
                        // Count actual lessons in schedule for this time
                        const actualLessons = allLessons.filter(l => l.day === day && l.time === timeSlot);
                        const actualRooms = actualLessons.map(l => l.room);
                        
                        // Check for duplicates
                        const uniqueRooms = [...new Set(actualRooms)];
                        if (actualRooms.length !== uniqueRooms.length) {
                            conflicts += (actualRooms.length - uniqueRooms.length);
                            debugLog(`Room conflict detected: ${day} ${timeSlot}`, {
                                trackedRooms: Array.from(roomsAtTime),
                                actualRooms: actualRooms,
                                duplicates: actualRooms.filter((room, index) => actualRooms.indexOf(room) !== index)
                            });
                        }
                    });
                });
                return conflicts;
            }


            // Generate optimal schedule for a single class
            function generateOptimalClassSchedule(classInfo, subjectPlans, rooms, teacherAvailability, startTime, endTime, weekdays) {
                const classLessons = [];
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                
                // Säkerställ att classInfo har nödvändiga fält
                if (!classInfo.name) {
                    debugLog('Warning: classInfo missing name field:', classInfo);
                    classInfo.name = `Klass ${classInfo.id}`;
                }
                
                // Group subjects by day, ensuring no more than 1 lesson per subject per day
                const dailyPlans = distributeSubjectsAcrossDays(subjectPlans, weekdays);
                
                for (const [day, daySubjects] of Object.entries(dailyPlans)) {
                    if (daySubjects.length === 0) continue;
                    
                    // Säkerställ att varje subject har rätt fält
                    daySubjects.forEach(subject => {
                        if (!subject.class_name) subject.class_name = classInfo.name;
                        if (!subject.subject_name) subject.subject_name = `Ämne ${subject.subject_id}`;
                    });
                    
                    // Calculate optimal lesson durations for this day
                    const optimalSchedule = optimizeDailySchedule(
                        daySubjects, 
                        startMinutes, 
                        endMinutes,
                        classInfo,
                        day,
                        rooms,
                        teacherAvailability
                    );
                    
                    classLessons.push(...optimalSchedule);
                }
                
                return classLessons;
            }

            function getAvailableRooms() {
                // Prioritera den server-initialiserade listan
                if (Array.isArray(availableRooms) && availableRooms.length > 0) {
                    return availableRooms.slice(); // returnera en kopia så vi inte muterar originalet
                }

                // Försök plocka ut från DOM om någon utökad logik redan renderat rum i sidan
                const roomsFromDOM = new Set();
                document.querySelectorAll('.spanning-lesson').forEach(lessonEl => {
                    const room = lessonEl.dataset.room;
                    if (room && room !== 'Inget rum') {
                        roomsFromDOM.add(room);
                    }
                });

                if (roomsFromDOM.size > 0) return Array.from(roomsFromDOM);

                // Endast som sista utväg: fasta fallback-rum
                return ['Sal A', 'Sal B', 'Sal C', 'Sal D', 'Sal E'];
            }



            function mapSchoolSubjectToSubject(schoolSubjectId) {
                // This function should map from SchoolSubject ID to Subject ID
                // You'll need to implement the mapping logic based on your database structure
                
                // Option 1: If you have a direct mapping in your backend data
                // Look for a mapping table or field that connects SchoolSubject to Subject
                
                // Option 2: Match by name (if names are consistent)
                const schoolSubject = schoolSubjects.find(s => String(s.id) === String(schoolSubjectId));
                if (schoolSubject) {
                    // Look for matching subject in main subjects table by name
                    const matchingSubject = availableSubjects.find(s => s.name === schoolSubject.name);
                    if (matchingSubject) {
                        return matchingSubject.id;
                    }
                }
                
                // Option 3: Return the school subject ID if no mapping exists
                // (This assumes your backend can handle school_subject_ids in the subject_id field)
                return schoolSubjectId;
            }

            function validateRoomAvailability(room, day, timeSlot) {
                if (!globalRoomOccupancy || !globalRoomOccupancy[day] || !globalRoomOccupancy[day][timeSlot]) {
                    return true;
                }
                return !globalRoomOccupancy[day][timeSlot].has(room);
            }





            // --- Klistra in denna funktion i din scriptsektion (funktion-deklaration, alltså hoistas) ---
            // Uppdatera generateMultiClassScheduleWithConstraints funktionen - ersätt roomOccupancy-initieringen och användningen
            // 3. Uppdaterad generateMultiClassScheduleWithConstraints - med bättre rumskontroll
            // Replace the entire generateMultiClassScheduleWithConstraints function
            // ERSÄTT generateMultiClassScheduleWithConstraints funktionen med denna:
            function generateMultiClassScheduleWithConstraints(classes, classSubjectMap, rooms, startTime, endTime, lessonDuration) {
                debugLog('Generating multi-class schedule with EXACT lesson allocation:', {
                    classes: classes.length, 
                    rooms: rooms.length, 
                    classSubjectMap: classSubjectMap
                });

                const actualRooms = (rooms && rooms.length) ? rooms : getAvailableRooms();
                if (!actualRooms || actualRooms.length === 0) {
                    throw new Error('Inga klassrum valda. Välj minst ett klassrum.');
                }

                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                const timeSlots = generateTimeSlots(startTime || '08:00', endTime || '15:00', lessonDuration);
                const allLessons = [];

                // Reset global room occupancy
                globalRoomOccupancy = {};
                weekdays.forEach(day => {
                    globalRoomOccupancy[day] = {};
                    timeSlots.forEach(slot => {
                        globalRoomOccupancy[day][slot] = new Set();
                    });
                });

                // Initialize teacher availability
                teacherAvailability = {};
                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                    availableTeachers.forEach(teacher => {
                        teacherAvailability[teacher.id] = {};
                        weekdays.forEach(day => {
                            teacherAvailability[teacher.id][day] = [];
                        });
                    });
                }

                // KRITISK FIX: Skapa exakt rätt antal lektioner per ämne per klass
                const exactLessonPlan = [];
                const lessonCounter = {}; // För att spåra placerade lektioner per klass per ämne
                
                classes.forEach(classInfo => {
                    const cid = classInfo.id;
                    const className = classInfo.name || `Klass ${cid}`;
                    lessonCounter[cid] = {};

                    const items = classSubjectMap[cid] || [];
                    items.forEach(item => {
                        const subjectId = item.subject_id;
                        const schoolSubjectId = item.school_subject_id || subjectId;
                        const subjectName = getSubjectNameById(subjectId) || `Ämne ${subjectId}`;
                        const hoursPerWeek = parseInt(item.hours);

                        if (hoursPerWeek > 5) {
                            throw new Error(`Ämnet "${subjectName}" för klass ${className} har ${hoursPerWeek} lektioner, men max 5 är tillåtet`);
                        }

                        // Initiera räknaren för detta ämne
                        lessonCounter[cid][subjectName] = {
                            required: hoursPerWeek,
                            placed: 0
                        };

                        // Skapa exakt rätt antal lektionsplaner
                        for (let lessonNum = 1; lessonNum <= hoursPerWeek; lessonNum++) {
                            exactLessonPlan.push({
                                class_id: cid,
                                class_name: className,
                                subject_id: subjectId,
                                school_subject_id: schoolSubjectId,
                                subject_name: subjectName,
                                lesson_number: lessonNum,
                                total_lessons: hoursPerWeek,
                                color: classInfo.color || classColors[classes.indexOf(classInfo) % classColors.length],
                                priority: Math.random() // För slumpmässig initial placering
                            });
                        }
                    });
                });

                debugLog('Exact lesson plan created:', {
                    totalLessonsToPlace: exactLessonPlan.length,
                    lessonsByClass: Object.keys(lessonCounter).reduce((acc, classId) => {
                        const className = classes.find(c => c.id == classId)?.name || classId;
                        acc[className] = Object.entries(lessonCounter[classId]).reduce((subAcc, [subject, count]) => {
                            subAcc[subject] = count.required;
                            return subAcc;
                        }, {});
                        return acc;
                    }, {})
                });

                // Sortera lektioner för rättvis fördelning
                exactLessonPlan.sort((a, b) => a.priority - b.priority);

                // Global schemalayout per dag
                const globalSchedule = {};
                const subjectsByClassAndDay = {}; // Spåra vilka ämnen som redan är placerade per klass per dag
                
                weekdays.forEach(day => {
                    globalSchedule[day] = [];
                    subjectsByClassAndDay[day] = {};
                    classes.forEach(cls => {
                        subjectsByClassAndDay[day][cls.id] = new Set();
                    });
                });

                // HUVUDSCHEMALÄGGNINGSLOGIK - Garanterad placering
                let placedLessons = 0;
                const maxAttempts = exactLessonPlan.length * 10; // Säkerhetsgräns
                let attempts = 0;
                
                while (exactLessonPlan.length > 0 && attempts < maxAttempts) {
                    attempts++;
                    const lesson = exactLessonPlan.shift(); // Ta första lektionen i kön
                    let lessonPlaced = false;

                    // Försök placera på alla dagar (prioritera dagar utan samma ämne först)
                    const availableDays = weekdays.filter(day => 
                        !subjectsByClassAndDay[day][lesson.class_id].has(lesson.subject_name)
                    );
                    
                    // Om inga "rena" dagar finns, använd alla dagar (för att undvika deadlock)
                    const daysToTry = availableDays.length > 0 ? availableDays : weekdays.slice();
                    
                    // Sortera dagar efter minst belastad först
                    daysToTry.sort((a, b) => {
                        const aLoad = globalSchedule[a].filter(l => l.class_id === lesson.class_id).length;
                        const bLoad = globalSchedule[b].filter(l => l.class_id === lesson.class_id).length;
                        return aLoad - bLoad;
                    });

                    for (const day of daysToTry) {
                        // Hitta tillgängliga tidsslots för denna klass
                        const classLessonsToday = globalSchedule[day].filter(l => l.class_id === lesson.class_id);
                        const availableSlots = timeSlots.filter(slot => {
                            // Kontrollera om tiden är ledig för klassen (ingen överlappning)
                            const isTimeAvailable = !classLessonsToday.some(existingLesson => {
                                return slot === existingLesson.time; // Enkel kontroll - samma tidsslot
                            });
                            
                            return isTimeAvailable;
                        });

                        // Blanda tidsslots för variation
                        const shuffledSlots = [...availableSlots].sort(() => Math.random() - 0.5);

                        for (const timeSlot of shuffledSlots) {
                            // Kontrollera rumstillgänglighet
                            const availableRoom = findAvailableRoom(actualRooms, day, timeSlot, teacherAvailability);
                            
                            if (availableRoom) {
                                // Kontrollera lärartillgänglighet
                                const teacherAssignment = assignTeacherToLesson(lesson, day, timeSlot);
                                
                                if (teacherAssignment) {
                                    // FRAMGÅNG! Placera lektionen
                                    const lessonData = {
                                        day: day,
                                        time: timeSlot,
                                        class_id: lesson.class_id,
                                        class_name: lesson.class_name,
                                        subject_id: lesson.subject_id,
                                        school_subject_id: lesson.school_subject_id,
                                        subject_name: lesson.subject_name,
                                        room: availableRoom,
                                        teacher_id: teacherAssignment.teacher_id,
                                        teacher_name: teacherAssignment.teacher_name,
                                        color: lesson.color,
                                        lesson_number: lesson.lesson_number,
                                        total_lessons: lesson.total_lessons
                                    };

                                    // Lägg till i schemat
                                    globalSchedule[day].push(lessonData);
                                    subjectsByClassAndDay[day][lesson.class_id].add(lesson.subject_name);
                                    allLessons.push(lessonData);
                                    
                                    // Uppdatera räknare
                                    lessonCounter[lesson.class_id][lesson.subject_name].placed++;
                                    placedLessons++;
                                    lessonPlaced = true;
                                    
                                    debugLog(`✅ Lesson ${placedLessons}: ${lesson.class_name}-${lesson.subject_name} (${lesson.lesson_number}/${lesson.total_lessons}) placed on ${day} ${timeSlot} in ${availableRoom}`);
                                    break;
                                    
                                } else {
                                    // Ingen lärare tillgänglig - frigör rummet
                                    globalRoomOccupancy[day][timeSlot].delete(availableRoom);
                                }
                            }
                        }
                        
                        if (lessonPlaced) break; // Gå till nästa lektion
                    }

                    // Om lektionen inte kunde placeras, lägg tillbaka i kön med lägre prioritet
                    if (!lessonPlaced) {
                        lesson.priority += 1; // Sänk prioritet
                        lesson.retry_count = (lesson.retry_count || 0) + 1;
                        
                        if (lesson.retry_count < 20) { // Max 20 återförsök per lektion
                            exactLessonPlan.push(lesson); // Lägg tillbaka i slutet av kön
                            debugLog(`⏳ Lesson queued for retry: ${lesson.class_name}-${lesson.subject_name} (${lesson.lesson_number}/${lesson.total_lessons}) - retry ${lesson.retry_count}`);
                        } else {
                            debugLog(`❌ KRITISKT: Kunde inte placera ${lesson.class_name}-${lesson.subject_name} (${lesson.lesson_number}/${lesson.total_lessons}) efter 20 försök`);
                        }
                    }
                }

                // VALIDERING - Kontrollera att alla lektioner är placerade
                const validationResults = [];
                Object.keys(lessonCounter).forEach(classId => {
                    const className = classes.find(c => c.id == classId)?.name || classId;
                    Object.entries(lessonCounter[classId]).forEach(([subjectName, count]) => {
                        if (count.placed !== count.required) {
                            validationResults.push({
                                class: className,
                                subject: subjectName,
                                required: count.required,
                                placed: count.placed,
                                missing: count.required - count.placed
                            });
                        }
                    });
                });

                if (validationResults.length > 0) {
                    const errorMsg = `❌ SCHEMALÄGGNINGSFEL - Inte alla lektioner kunde placeras:\n\n${validationResults.map(v => 
                        `• ${v.class} - ${v.subject}: ${v.placed}/${v.required} lektioner placerade (saknas: ${v.missing})`
                    ).join('\n')}\n\nLösningar:\n• Öka antalet klassrum\n• Minska lektioner per ämne\n• Kontrollera lärarbehörigheter\n• Utöka skoldagens timmar`;
                    
                    debugLog('❌ Validation failed:', validationResults);
                    throw new Error(errorMsg);
                }

                // Slutgiltig validering av rumskonflikter
                const finalRoomConflicts = validateFinalRoomBookings(allLessons);
                if (finalRoomConflicts.length > 0) {
                    throw new Error(`Rumkonflikter upptäcktes: ${finalRoomConflicts.length} konflikter. Öka antalet klassrum.`);
                }

                // Skapa slutlig sammanfattning
                const finalStats = {
                    total_lessons: allLessons.length,
                    lessons_per_class: classes.reduce((acc, cls) => {
                        acc[cls.name] = allLessons.filter(l => l.class_id === cls.id).length;
                        return acc;
                    }, {}),
                    subject_distribution: Object.keys(lessonCounter).reduce((acc, classId) => {
                        const className = classes.find(c => c.id == classId)?.name || classId;
                        acc[className] = Object.entries(lessonCounter[classId]).reduce((subAcc, [subject, count]) => {
                            subAcc[subject] = `${count.placed}/${count.required}`;
                            return subAcc;
                        }, {});
                        return acc;
                    }, {}),
                    rooms_used: [...new Set(allLessons.map(l => l.room))],
                    teachers_used: [...new Set(allLessons.map(l => l.teacher_name))],
                    placement_success_rate: '100%',
                    total_placement_attempts: attempts,
                    validation_status: 'PASSED - All lessons placed correctly'
                };

                debugLog('✅ PERFEKT SCHEMALÄGGNING KLAR:', finalStats);

                return {
                    lessons: allLessons,
                    time_slots: timeSlots,
                    classes: classes,
                    stats: finalStats
                };
            }


            // --- Slut på funktionen ---

            const roomConflicts = validateRoomBookings(allLessons);
            if (roomConflicts.length > 0) {
                debugLog('Room conflicts detected:', roomConflicts);
                throw new Error(`Rumskonflikter upptäcktes: ${roomConflicts.length} dubbelbokning(ar). Försök med fler klassrum.`);
            }



            // 4. Slutgiltig rumvalidering
            // Add final validation function
            // 4. FIX: Förbättra validateFinalRoomBookings för bättre felrapportering
            function validateFinalRoomBookings(lessons) {
                const conflicts = [];
                const roomBookings = {};
                
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!roomBookings[key]) {
                        roomBookings[key] = [];
                    }
                    
                    // Kontrollera om rummet redan är bokat för denna tid
                    const existingBooking = roomBookings[key].find(booking => booking.room === lesson.room);
                    if (existingBooking) {
                        conflicts.push({
                            room: lesson.room || 'Okänt rum',
                            timeSlot: key || 'Okänd tid',
                            classes: [
                                existingBooking.class_name || 'Okänd klass', 
                                lesson.class_name || 'Okänd klass'
                            ],
                            subjects: [
                                existingBooking.subject_name || 'Okänt ämne', 
                                lesson.subject_name || 'Okänt ämne'
                            ],
                            conflict: `Room ${lesson.room || 'N/A'} double-booked at ${key || 'N/A'} - ${existingBooking.class_name || 'N/A'} (${existingBooking.subject_name || 'N/A'}) vs ${lesson.class_name || 'N/A'} (${lesson.subject_name || 'N/A'})`
                        });
                    }
                    
                    roomBookings[key].push({
                        room: lesson.room || 'Okänt rum',
                        class_name: lesson.class_name || 'Okänd klass',
                        subject_name: lesson.subject_name || 'Okänt ämne'
                    });
                });
                
                if (conflicts.length > 0) {
                    debugLog('Room booking conflicts detected:', conflicts);
                }
                
                return conflicts;
            }


            // Fix 1: Remove duplicate function declaration
            // 4. UPPDATERA generateMultiClassSchedule för att ladda rumsbegränsningar först:
            async function generateMultiClassSchedule() {
                const preview = document.getElementById('schedulePreview');
                const controls = document.getElementById('generationControls');

                // Säkerställ att selectedClasses speglar DOM
                const checkedBoxes = Array.from(document.querySelectorAll('input[name="class_ids[]"]:checked'));
                if (checkedBoxes.length > 0) {
                    selectedClasses = checkedBoxes.map(cb => {
                        const classId = cb.value;
                        const classData = availableClasses.find(c => c.id == classId);
                        return {
                            id: classId,
                            name: classData ? classData.name : `Klass ${classId}`
                        };
                    });
                }

                if (selectedClasses.length === 0) {
                    alert('Välj minst en klass!');
                    debugLog('Validation failed: No classes selected');
                    return;
                }

                // Validering av ämneskonfiguration (behåll befintlig kod)...
                const classSubjectMap = {};
                for (const cls of selectedClasses) {
                    const classId = cls.id;
                    const container = document.getElementById(`class_subjects_${classId}`);
                    if (!container) {
                        alert(`Ingen ämnessektion hittades för klass ${cls.name}.`);
                        debugLog('Validation failed: missing class subject container', {class: cls});
                        return;
                    }

                    const rows = Array.from(container.querySelectorAll('.subject-item'));
                    if (rows.length === 0) {
                        alert(`Ingen ämneskonfiguration för klass ${cls.name}. Ange minst ett ämne.`);
                        debugLog('Validation failed: No subject rows for class', {class: cls});
                        return;
                    }

                    const items = [];
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];
                        const subjSelect = row.querySelector('select');
                        const hourInput = row.querySelector('input[type="number"]');

                        const subjVal = subjSelect ? subjSelect.value.trim() : '';
                        const hrsValRaw = hourInput ? hourInput.value.trim() : '';
                        const hrsVal = hrsValRaw === '' ? NaN : parseInt(hrsValRaw, 10);

                        if (!subjVal) {
                            alert(`Välj ämne i alla rader för klass ${cls.name}`);
                            debugLog('Validation failed: empty subject row', {class: cls, index: i});
                            return;
                        }
                        if (isNaN(hrsVal) || hrsVal <= 0) {
                            alert(`Ange giltigt antal timmar för ämnet i klass ${cls.name}`);
                            debugLog('Validation failed: invalid hours', {class: cls, index: i, hours: hrsValRaw});
                            return;
                        }
                        if (hrsVal > 5) {
                            alert(`Max 5 lektioner per vecka per ämne. Du angav ${hrsVal} för ämnet i klass ${cls.name}`);
                            debugLog('Validation failed: hours > 5', {class: cls, hours: hrsVal});
                            return;
                        }

                        const schoolSubjectId = parseInt(subjVal, 10);
                        const subjectNameFromSchool = getSubjectNameById(schoolSubjectId);
                        const subjectNameFromAvailable = (availableSubjects||[]).find(s => String(s.id) === String(schoolSubjectId))?.name;
                        const resolvedSubjectName = subjectNameFromSchool || subjectNameFromAvailable || `Ämne ${schoolSubjectId}`;

                        items.push({
                            subject_id: schoolSubjectId,
                            school_subject_id: schoolSubjectId,
                            subject_name: resolvedSubjectName,
                            hours: hrsVal
                        });

                        debugLog('Added subject item', { classId, schoolSubjectId, resolvedSubjectName, hours: hrsVal });
                    }

                    classSubjectMap[classId] = items;
                }


                

                const rooms = getAvailableRooms();
                const maxSimultaneousClasses = selectedClasses.length;
                if (rooms.length < maxSimultaneousClasses) {
                    const proceed = confirm(
                        `Du har valt ${maxSimultaneousClasses} klasser men bara ${rooms.length} klassrum. ` +
                        `Detta kan orsaka schemaläggningsproblem när klasser har lektioner samtidigt. Fortsätt ändå?`
                    );
                    if (!proceed) {
                        debugLog('User cancelled due to insufficient rooms');
                        return;
                    }
                }

                debugLog('Multi-class validation passed, generating schedule...', {
                    classes: selectedClasses.length,
                    classSubjectMap,
                    rooms: rooms.length
                });

                // Visa loading
                preview.innerHTML = `
                    <div style="text-align: center;">
                        <div class="loading-spinner"></div>
                        <p style="margin-top: 1rem;">Laddar lärarnas rumsbegränsningar...</p>
                        <p style="font-size: 0.9rem; color: #666;">
                            Kontrollerar vilka klassrum varje lärare får undervisa i
                        </p>
                    </div>
                `;

                try {
                    // KRITISK FIX: Ladda rumsbegränsningar FÖRST
                    await loadTeacherRoomRestrictions();

                    debugLog('Teacher room restrictions loaded:', window.teacherRoomRestrictions);
                    

                    if (window.teacherRoomRestrictions && availableTeachers) {
                        availableTeachers.forEach(teacher => {
                            const restrictions = window.teacherRoomRestrictions[teacher.id];
                            debugLog(`Teacher ${teacher.name} (${teacher.id}):`, 
                                restrictions === null ? 'ALL ROOMS' : restrictions || 'NO DATA');
                        });
                    }
                    // Uppdatera loading-meddelande
                    preview.innerHTML = `
                        <div style="text-align: center;">
                            <div class="loading-spinner"></div>
                            <p style="margin-top: 1rem;">Laddar befintliga scheman...</p>
                            <p style="font-size: 0.9rem; color: #666;">
                                Kontrollerar lärartillgänglighet från andra klassers scheman
                            </p>
                        </div>
                    `;
                    
                    // Ladda befintliga scheman
                    const existingTeacherAvailability = await loadExistingSchedules();
                    
                    // Uppdatera loading-meddelande
                    preview.innerHTML = `
                        <div style="text-align: center;">
                            <div class="loading-spinner"></div>
                            <p style="margin-top: 1rem;">Genererar optimerat multi-klass schema...</p>
                            <p style="font-size: 0.9rem; color: #666;">
                                Optimerar för ${selectedClasses.length} klasser med hänsyn till befintliga scheman och rumsbegränsningar
                            </p>
                            <p style="font-size: 0.85rem; color: #888;">
                                Följer: Inga lärarkonflikter, automatisk lunch, kompakt schema, lärarens rumstillgång
                            </p>
                        </div>
                    `;
                    
                    const form = document.getElementById('scheduleForm');
                    const formData = new FormData(form);
                    
                    // Skicka befintlig tillgänglighet till schema-generatorn
                    const multiClassSchedule = generateSmartCompactScheduleWithConstraints(
                        selectedClasses, classSubjectMap, rooms, 
                        formData.get('start_time'), formData.get('end_time'),
                        existingTeacherAvailability
                    );

                    setTimeout(() => {
                        debugLog('Multi-class schedule generated successfully with room restrictions:', multiClassSchedule);
                        currentSchedule = multiClassSchedule;
                        
                        // Fill teacher filter from schedule if not already available
                        if (!(typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0)) {
                            populateTeacherFilterFromSchedule(currentSchedule);
                        }
                        
                        // Display with current filters
                        const classSel = document.getElementById('classFilter');
                        const teacherSel = document.getElementById('teacherFilter');
                        const selectedClass = classSel && classSel.value !== 'all' ? classSel.value : null;
                        const selectedTeacher = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
                        
                        displayMultiClassSchedule(currentSchedule, selectedClass, selectedTeacher);
                        controls.style.display = 'flex';
                    }, 1000);

                } catch (error) {
                    debugLog('Error generating multi-class schedule:', error);
                    console.error('Error generating multi-class schedule:', error);
                    preview.innerHTML = `
                        <div style="text-align: center; color: #e53e3e;">
                            <p>❌ Fel vid multi-klass schemagenerering</p>
                            <p style="font-size: 0.9rem;">${error.message}</p>
                            <p style="font-size: 0.85rem; color: #666;">
                                Tips: Kontrollera lärarnas rumstillgång, öka antalet klassrum, eller minska antalet klasser
                            </p>
                        </div>
                    `;
                    controls.style.display = 'none';
                }
            }

            // Fix 2: Ensure availableTeachers is properly initialized
            function initializeData() {
                // Make sure availableTeachers is defined
                if (typeof availableTeachers === 'undefined') {
                    availableTeachers = [];
                }
                
                // Make sure other global variables are properly initialized
                if (typeof availableSubjects === 'undefined') {
                    availableSubjects = [];
                }
                
                if (typeof availableClasses === 'undefined') {
                    availableClasses = [];
                }
                
                if (typeof schoolSubjects === 'undefined') {
                    schoolSubjects = availableSubjects || [];
                }
            }



            


            // 2. FIX: Förbättra findAvailableTimeSlotsForClass för att undvika överlappningar
            function findAvailableTimeSlotsForClass(daySchedule, classId, allTimeSlots, minBreakMinutes) {
                const availableSlots = [];
                const classLessons = daySchedule.filter(lesson => lesson.class_id === classId);
                
                // CRITICAL: Sort existing lessons by time for proper overlap checking
                const sortedClassLessons = classLessons.sort((a, b) => {
                    const aStart = timeToMinutes(a.time.split('-')[0]);
                    const bStart = timeToMinutes(b.time.split('-')[0]);
                    return aStart - bStart;
                });
                
                for (const timeSlot of allTimeSlots) {
                    const [startTime, endTime] = timeSlot.split('-');
                    const startMinutes = timeToMinutes(startTime);
                    const endMinutes = timeToMinutes(endTime);
                    
                    let canPlace = true;
                    
                    // CRITICAL: Check against ALL existing lessons for this class
                    for (const existingLesson of sortedClassLessons) {
                        const [existingStart, existingEnd] = existingLesson.time.split('-');
                        const existingStartMinutes = timeToMinutes(existingStart);
                        const existingEndMinutes = timeToMinutes(existingEnd);
                        
                        // Check for ANY overlap (not just insufficient break)
                        const hasOverlap = !(endMinutes + minBreakMinutes <= existingStartMinutes || 
                                            startMinutes >= existingEndMinutes + minBreakMinutes);
                        
                        if (hasOverlap) {
                            canPlace = false;
                            debugLog(`Time slot ${timeSlot} conflicts with existing lesson ${existingLesson.time} for class ${classId}`);
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        availableSlots.push(timeSlot);
                    }
                }
                
                debugLog(`Found ${availableSlots.length} available slots for class ${classId} out of ${allTimeSlots.length} total slots`);
                return availableSlots;
            }



            function checkTeacherConflicts(lessons) {
                const conflicts = [];
                
                // Gruppera lektioner efter dag och tid
                const lessonsByDayTime = {};
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!lessonsByDayTime[key]) {
                        lessonsByDayTime[key] = [];
                    }
                    lessonsByDayTime[key].push(lesson);
                });
                
                // Kontrollera lärarkonflikter
                Object.keys(lessonsByDayTime).forEach(key => {
                    const timeLessons = lessonsByDayTime[key];
                    const teachersUsed = {};
                    
                    timeLessons.forEach(lesson => {
                        const teacherKey = lesson.teacher_id || lesson.teacher_name || lesson.teacher;
                        if (teacherKey && teachersUsed[teacherKey]) {
                            conflicts.push({
                                teacher: teacherKey,
                                time: key,
                                classes: [teachersUsed[teacherKey].class_name, lesson.class_name]
                            });
                        } else if (teacherKey) {
                            teachersUsed[teacherKey] = lesson;
                        }
                    });
                });
                
                return conflicts;
            }

            function checkRoomConflicts(lessons) {
                const conflicts = [];
                
                // Gruppera lektioner efter dag och tid
                const lessonsByDayTime = {};
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!lessonsByDayTime[key]) {
                        lessonsByDayTime[key] = [];
                    }
                    lessonsByDayTime[key].push(lesson);
                });
                
                // Kontrollera konflikter
                Object.keys(lessonsByDayTime).forEach(key => {
                    const timeLessons = lessonsByDayTime[key];
                    const roomsUsed = {};
                    
                    timeLessons.forEach(lesson => {
                        if (roomsUsed[lesson.room]) {
                            conflicts.push({
                                room: lesson.room,
                                time: key,
                                classes: [roomsUsed[lesson.room].class_name, lesson.class_name]
                            });
                        } else {
                            roomsUsed[lesson.room] = lesson;
                        }
                    });
                });
                
                return conflicts;
            }

            function calculateMultiClassBalanceScore(schedule, classes) {
                let totalBalance = 0;
                
                classes.forEach(classInfo => {
                    const dailyCounts = Object.keys(schedule).map(day => 
                        schedule[day].filter(lesson => lesson.class_id === classInfo.id).length
                    );
                    const max = Math.max(...dailyCounts);
                    const min = Math.min(...dailyCounts);
                    
                    const balance = max === 0 ? 100 : Math.round((1 - (max - min) / max) * 100);
                    totalBalance += balance;
                });
                
                return Math.round(totalBalance / classes.length);
            }


            // 3. FIX: Lägg till strikt validering före sparande
            function validateScheduleBeforeSave(lessons) {
                const conflicts = {
                    timeOverlaps: [],
                    roomConflicts: [],
                    teacherConflicts: []
                };
                
                // Group lessons by class for overlap checking
                const lessonsByClass = {};
                lessons.forEach(lesson => {
                    if (!lessonsByClass[lesson.class_id]) {
                        lessonsByClass[lesson.class_id] = [];
                    }
                    lessonsByClass[lesson.class_id].push(lesson);
                });
                
                // Check for time overlaps within each class
                Object.entries(lessonsByClass).forEach(([classId, classLessons]) => {
                    const dailyLessons = {};
                    
                    // Group by day
                    classLessons.forEach(lesson => {
                        if (!dailyLessons[lesson.day]) {
                            dailyLessons[lesson.day] = [];
                        }
                        dailyLessons[lesson.day].push(lesson);
                    });
                    
                    // Check overlaps within each day
                    Object.entries(dailyLessons).forEach(([day, dayLessons]) => {
                        for (let i = 0; i < dayLessons.length; i++) {
                            for (let j = i + 1; j < dayLessons.length; j++) {
                                const lesson1 = dayLessons[i];
                                const lesson2 = dayLessons[j];
                                
                                const [start1, end1] = lesson1.time.split('-');
                                const [start2, end2] = lesson2.time.split('-');
                                
                                const start1Min = timeToMinutes(start1);
                                const end1Min = timeToMinutes(end1);
                                const start2Min = timeToMinutes(start2);
                                const end2Min = timeToMinutes(end2);
                                
                                // Check for overlap
                                if (!(end1Min <= start2Min || start1Min >= end2Min)) {
                                    conflicts.timeOverlaps.push({
                                        class_name: lesson1.class_name,
                                        day: day,
                                        lesson1: `${lesson1.subject_name} (${lesson1.time})`,
                                        lesson2: `${lesson2.subject_name} (${lesson2.time})`,
                                        conflict: `Overlapping lessons in ${lesson1.class_name} on ${day}: ${lesson1.time} vs ${lesson2.time}`
                                    });
                                }
                            }
                        }
                    });
                });
                
                // Check room conflicts
                const roomBookings = {};
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!roomBookings[key]) {
                        roomBookings[key] = [];
                    }
                    roomBookings[key].push(lesson);
                });
                
                Object.entries(roomBookings).forEach(([timeKey, lessonsAtTime]) => {
                    const roomsUsed = {};
                    lessonsAtTime.forEach(lesson => {
                        if (roomsUsed[lesson.room]) {
                            conflicts.roomConflicts.push({
                                room: lesson.room,
                                time: timeKey,
                                classes: [roomsUsed[lesson.room].class_name, lesson.class_name],
                                subjects: [roomsUsed[lesson.room].subject_name, lesson.subject_name]
                            });
                        } else {
                            roomsUsed[lesson.room] = lesson;
                        }
                    });
                });
                
                // Check teacher conflicts
                const teacherBookings = {};
                lessons.forEach(lesson => {
                    if (lesson.teacher_id && lesson.teacher_id !== 'fallback') {
                        const key = `${lesson.day}-${lesson.time}`;
                        if (!teacherBookings[key]) {
                            teacherBookings[key] = {};
                        }
                        
                        if (teacherBookings[key][lesson.teacher_id]) {
                            conflicts.teacherConflicts.push({
                                teacher: lesson.teacher_name || lesson.teacher_id,
                                time: key,
                                classes: [teacherBookings[key][lesson.teacher_id].class_name, lesson.class_name],
                                subjects: [teacherBookings[key][lesson.teacher_id].subject_name, lesson.subject_name]
                            });
                        } else {
                            teacherBookings[key][lesson.teacher_id] = lesson;
                        }
                    }
                });
                
                return conflicts;
            }


            // LÄGG TILL denna nya hjälpfunktion för flexibla tidsslots:
            function generateFlexibleTimeSlots(startTime, endTime, lessonDurationMinutes, existingClassLessons) {
                const slots = [];
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                const minBreak = 5; // Minsta paus mellan lektioner
                
                // Skapa lista av upptagna tider för denna klass
                const occupiedPeriods = existingClassLessons.map(lesson => {
                    const [start, end] = lesson.time.split('-');
                    return {
                        start: timeToMinutes(start),
                        end: timeToMinutes(end)
                    };
                }).sort((a, b) => a.start - b.start);
                
                // Generera möjliga starttider (var 15:e minut)
                for (let startMin = startMinutes; startMin + lessonDurationMinutes <= endMinutes; startMin += 15) {
                    const endMin = startMin + lessonDurationMinutes;
                    
                    // Kontrollera om detta slot krockar med befintliga lektioner
                    let hasConflict = false;
                    for (const occupied of occupiedPeriods) {
                        if (!(endMin + minBreak <= occupied.start || startMin >= occupied.end + minBreak)) {
                            hasConflict = true;
                            break;
                        }
                    }
                    
                    if (!hasConflict) {
                        const timeSlot = `${minutesToTime(startMin)}-${minutesToTime(endMin)}`;
                        slots.push(timeSlot);
                    }
                }
                
                // Blanda för variation
                return slots.sort(() => Math.random() - 0.5);
            }


            function validateMultiClassConstraints(schedule, classes) {
                let violations = 0;
                
                classes.forEach(classInfo => {
                    Object.values(schedule).forEach(dayLessons => {
                        const classLessons = dayLessons.filter(l => l.class_id === classInfo.id);
                        const subjects = classLessons.map(l => l.subject_name);
                        const uniqueSubjects = new Set(subjects);
                        if (subjects.length !== uniqueSubjects.size) {
                            violations++;
                        }
                    });
                });
                
                return violations;
            }

            // classFilter: null eller classId
            // teacherFilter: null eller teacherId/name
            function escapeHtml(str) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
            function timeToMinutes(t) { const [hh, mm] = String(t).split(':').map(Number); return hh*60 + (mm||0); }

                // Robust display-funktion (ersätt befintlig)
            // UPPDATERA displayMultiClassSchedule för att visa timmar korrekt:
            function displayMultiClassSchedule(schedule, classFilter = null, teacherFilter = null) {
                const preview = document.getElementById('schedulePreview');
                if (!preview || !schedule || !Array.isArray(schedule.lessons)) {
                    if (preview) preview.innerHTML = '<div style="text-align:center;color:#666;">Inget schema att visa</div>';
                    return;
                }

                // Filtrera lektioner
                let filteredLessons = schedule.lessons;
                if (classFilter) {
                    filteredLessons = filteredLessons.filter(l => String(l.class_id) === String(classFilter));
                }
                if (teacherFilter) {
                    filteredLessons = filteredLessons.filter(l => 
                        String(l.teacher_id) === String(teacherFilter) || 
                        String(l.teacher_name) === String(teacherFilter)
                    );
                }

                // Gruppera lektioner per dag
                const lessonMap = {};
                filteredLessons.forEach(lesson => {
                    const day = lesson.day || 'okänd';
                    if (!lessonMap[day]) lessonMap[day] = [];
                    lessonMap[day].push(lesson);
                });

                // Hämta alla unika tider och sortera
                const allTimes = [...new Set(filteredLessons.map(l => l.time))].sort((a, b) => {
                    const aStart = timeToMinutes(a.split('-')[0]);
                    const bStart = timeToMinutes(b.split('-')[0]);
                    return aStart - bStart;
                });

                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];

                // Bygg tabell med timvisnig
                let html = `
                    <div style="margin-bottom: 1rem;">
                        <h3>📅 Schema ${classFilter ? `för ${schedule.classes?.find(c => c.id == classFilter)?.name || 'Klass ' + classFilter}` : '(Multi-klass)'}</h3>
                        ${schedule.stats ? `
                            <div style="font-size: 0.9rem; color: #666; margin-top: 0.5rem;">
                                ${schedule.stats.total_lessons} lektioner • ${schedule.stats.total_hours || 'N/A'} timmar totalt
                                ${schedule.stats.hour_accuracy ? ` • ${schedule.stats.hour_accuracy}` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div style="overflow-x:auto;">
                        <table class="schedule-table" style="width:100%; border-collapse:collapse; border: 1px solid #e2e8f0;">
                            <thead>
                                <tr style="background: #f7fafc;">
                                    <th style="min-width:80px; text-align:left; padding:8px; border: 1px solid #e2e8f0; font-weight: 600;">Tid</th>`;
                
                weekdays.forEach(day => {
                    html += `<th style="text-align:left; padding:8px; border: 1px solid #e2e8f0; font-weight: 600;">${day.charAt(0).toUpperCase() + day.slice(1)}</th>`;
                });
                
                html += '</tr></thead><tbody>';

                // Skapa rader för varje tidslot
                allTimes.forEach(currentTime => {
                    html += `<tr><td style="padding:8px; font-weight:600; vertical-align:top; border: 1px solid #e2e8f0; background: #f8f9fa;">${escapeHtml(currentTime)}</td>`;

                    weekdays.forEach(day => {
                        const dayLessons = lessonMap[day] || [];
                        const lessonsAtTime = dayLessons.filter(l => l.time === currentTime);

                        if (lessonsAtTime.length === 0) {
                            html += '<td style="padding:8px; color:#a0aec0; border: 1px solid #e2e8f0; text-align: center;">-</td>';
                        } else {
                            const cellContent = lessonsAtTime.map(lesson => {
                                const subjectLabel = lesson.subject_name || getSubjectNameById(lesson.school_subject_id) || getSubjectNameById(lesson.subject_id) || 'Okänt ämne';
                                const classLabel = lesson.class_name || lesson.class_id || '';
                                const room = lesson.room || '';
                                const teacher = lesson.teacher_name || lesson.teacher || '';
                                const color = lesson.color || '#9f7aea';
                                const duration = lesson.duration_hours ? `(${lesson.duration_hours}h)` : '';

                                return `
                                    <div style="margin-bottom:4px; padding:6px; border-left:4px solid ${escapeHtml(color)}; background: ${escapeHtml(color)}15; border-radius:4px;">
                                        <div style="font-weight:700; font-size: 0.9rem;">${escapeHtml(subjectLabel)} ${duration}</div>
                                        <div style="font-size:0.8rem; color:#4a5568; margin-top: 2px;">
                                            ${escapeHtml(classLabel)} • <span style="color:#718096">${escapeHtml(room)}</span>
                                        </div>
                                        ${teacher ? `<div style="font-size:0.75rem; color:#4a5568; margin-top: 2px;">👨‍🏫 ${escapeHtml(teacher)}</div>` : ''}
                                    </div>
                                `;
                            }).join('');
                            
                            html += `<td style="padding:8px; vertical-align:top; border: 1px solid #e2e8f0;">${cellContent}</td>`;
                        }
                    });

                    html += '</tr>';
                });

                html += '</tbody></table></div>';

                // Lägg till detaljerad statistik om tillgänglig
                if (schedule.stats && schedule.stats.hour_distribution) {
                    html += `
                        <div style="margin-top: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 0.5rem; border: 1px solid #e2e8f0;">
                            <h4 style="margin: 0 0 0.75rem 0; color: #2d3748;">📊 Timfördelning per klass</h4>
                            <div style="display: grid; gap: 0.5rem;">
                    `;
                    
                    Object.entries(schedule.stats.hour_distribution).forEach(([className, subjects]) => {
                        html += `
                            <div style="padding: 0.5rem; background: white; border-radius: 0.25rem; border: 1px solid #e2e8f0;">
                                <strong style="color: #2d3748;">${escapeHtml(className)}</strong>
                                <div style="margin-top: 0.25rem; font-size: 0.85rem; color: #4a5568;">
                        `;
                        
                        Object.entries(subjects).forEach(([subject, hourInfo]) => {
                            const isComplete = hourInfo.includes('✓');
                            html += `
                                <span style="margin-right: 0.75rem; color: ${isComplete ? '#38a169' : '#e53e3e'};">
                                    ${escapeHtml(subject)}: ${escapeHtml(hourInfo)}
                                </span>
                            `;
                        });
                        
                        html += '</div></div>';
                    });
                    
                    html += '</div></div>';
                }

                preview.innerHTML = html;
                
                // Visa kontroller
                const controls = document.getElementById('generationControls');
                if (controls) controls.style.display = 'flex';
            }


            document.addEventListener('DOMContentLoaded', function() {
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
            });

            document.addEventListener('DOMContentLoaded', function() {
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
                populateTeacherFilter();
            });

            document.addEventListener('DOMContentLoaded', function() {
                initializeData();
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
                populateTeacherFilter();
                renderSubjects();
                loadTeacherRoomRestrictions(); 
            });




            // Efter att schemat skapats
            currentSchedule = multiClassSchedule;
            // Fyll teacher-filter från schemat om backend inte skickade teachers
            if (!(typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0)) {
                populateTeacherFilterFromSchedule(currentSchedule);
            }
            // Rendera med eventuellt redan valt filter
            const classSel = document.getElementById('classFilter');
            const teacherSel = document.getElementById('teacherFilter');
            const selectedClass = classSel && classSel.value !== 'all' ? classSel.value : null;
            const selectedTeacher = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
            displayMultiClassSchedule(currentSchedule, selectedClass, selectedTeacher);
            controls.style.display = 'flex';




            

            function minutesToTime(minutes) {
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            }

            // ERSÄTT även generateTimeSlots funktionen för bättre tidshantering:
            function generateTimeSlots(startTime, endTime, lessonDurationMinutes = 60) {
                const slots = [];
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                const breakMinutes = 10; // 10 minuters paus mellan lektioner
                
                let currentStart = startMinutes;
                
                while (currentStart + lessonDurationMinutes <= endMinutes) {
                    const currentEnd = currentStart + lessonDurationMinutes;
                    const timeSlot = `${minutesToTime(currentStart)}-${minutesToTime(currentEnd)}`;
                    slots.push(timeSlot);
                    
                    // Nästa lektion startar efter paus
                    currentStart = currentEnd + breakMinutes;
                }
                
                debugLog(`Generated ${slots.length} time slots from ${startTime} to ${endTime}:`, slots);
                return slots;
            }









            function hideScheduleOverview() {
                document.getElementById('scheduleOverview').style.display = 'none';
            }

            /**
             * View detailed schedule for a specific class
             */
            async function viewClassScheduleDetails(classId, className) {
                try {
                    debugLog(`Loading schedule details for class ${className} (${classId})`);
                    
                    const response = await fetch(`/api/class_schedule/status/${classId}`);
                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta schemadetaljer');
                    }

                    // Create modal to show schedule details
                    showClassScheduleModal(result);
                    
                } catch (error) {
                    console.error('Error loading class schedule details:', error);
                    alert(`Fel vid laddning av schemadetaljer: ${error.message}`);
                }
            }

            /**
             * Show class schedule in modal
             */
            function showClassScheduleModal(scheduleData) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 10000;
                    display: flex; align-items: center; justify-content: center;
                    overflow-y: auto; padding: 1rem;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; border-radius: 0.5rem; max-width: 800px; width: 100%;
                    max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                `;

                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                
                let scheduleHtml = `
                    <div style="padding: 1.5rem; border-bottom: 1px solid #e2e8f0;">
                        <h3 style="margin: 0; display: flex; justify-content: space-between; align-items: center;">
                            📅 Schema för ${scheduleData.class_name}
                            <button onclick="this.closest('[style*=position]').remove()" 
                                    style="background: #f56565; color: white; border: none; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer;">
                                ✕
                            </button>
                        </h3>
                        <p style="margin: 0.5rem 0 0 0; color: #666;">
                            Totalt ${scheduleData.lesson_count} lektioner per vecka
                        </p>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                `;

                if (scheduleData.has_schedule) {
                    scheduleHtml += `<div style="overflow-x: auto;"><table class="schedule-table" style="width: 100%; border-collapse: collapse;">`;
                    scheduleHtml += `<thead><tr style="background: #f7fafc;"><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Dag</th><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Tid</th><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Ämne</th><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Rum</th></tr></thead><tbody>`;

                    weekdays.forEach(day => {
                        const dayLessons = scheduleData.lessons_by_day[day] || [];
                        
                        if (dayLessons.length === 0) {
                            scheduleHtml += `
                                <tr>
                                    <td style="padding: 0.75rem; border: 1px solid #e2e8f0; font-weight: 600; text-transform: capitalize;">${day}</td>
                                    <td colspan="3" style="padding: 0.75rem; border: 1px solid #e2e8f0; color: #999; font-style: italic;">Inga lektioner</td>
                                </tr>
                            `;
                        } else {
                            dayLessons.forEach((lesson, index) => {
                                scheduleHtml += `
                                    <tr>
                                        ${index === 0 ? `<td rowspan="${dayLessons.length}" style="padding: 0.75rem; border: 1px solid #e2e8f0; font-weight: 600; text-transform: capitalize; vertical-align: top;">${day}</td>` : ''}
                                        <td style="padding: 0.75rem; border: 1px solid #e2e8f0; font-family: monospace;">${lesson.time}</td>
                                        <td style="padding: 0.75rem; border: 1px solid #e2e8f0;">${lesson.subject}</td>
                                        <td style="padding: 0.75rem; border: 1px solid #e2e8f0;">${lesson.room}</td>
                                    </tr>
                                `;
                            });
                        }
                    });

                    scheduleHtml += `</tbody></table></div>`;
                } else {
                    scheduleHtml += `<div style="text-align: center; color: #666; font-style: italic;">Inget schema har skapats för denna klass.</div>`;
                }

                scheduleHtml += `
                    </div>
                `;

                content.innerHTML = scheduleHtml;
                modal.appendChild(content);
                document.body.appendChild(modal);

                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            /**
             * Edit schedule for a specific class
             */
            async function editClassSchedule(classId, className) {
                try {
                    debugLog(`Starting edit mode for class ${className} (${classId})`);
                    
                    // Set edit mode state
                    isEditMode = true;
                    editingClassId = classId;
                    editingClassName = className;
                    
                    // Select only this class
                    document.querySelectorAll('input[name="class_ids[]"]').forEach(cb => {
                        cb.checked = cb.id === `class_${classId}`;
                    });
                    
                    // Update selected classes
                    updateSelectedClasses();
                    
                    // Load existing schedule data
                    const response = await fetch(`/api/class_schedule/status/${classId}`);
                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte ladda befintligt schema');
                    }
                    
                    if (!result.has_schedule) {
                        // No existing schedule - redirect to creation
                        alert(`Klass "${className}" har inget befintligt schema. Du kommer att skapa ett nytt schema istället.`);
                        isEditMode = false;
                        editingClassId = null;
                        editingClassName = null;
                        document.getElementById('scheduleForm').scrollIntoView({ behavior: 'smooth', block: 'start' });
                        return;
                    }
                    
                    // Store original data for potential rollback
                    originalScheduleData = result;
                    
                    // Enter edit mode UI
                    enterEditMode(result);
                    
                    // Display editable schedule
                    displayEditableSchedule(result);
                    
                    // Update controls
                    updateEditControls();
                    
                    // Show controls
                    document.getElementById('generationControls').style.display = 'flex';
                    
                    // Scroll to preview
                    document.getElementById('schedulePreview').scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // Hide overview if visible
                    const overview = document.getElementById('scheduleOverview');
                    if (overview && overview.style.display === 'block') {
                        hideScheduleOverview();
                    }
                    
                    debugLog('Edit mode entered successfully', { classId, className, lessonCount: result.lesson_count });
                    
                } catch (error) {
                    console.error('Error entering edit mode:', error);
                    
                    // Reset edit state on error
                    isEditMode = false;
                    editingClassId = null;
                    editingClassName = null;
                    originalScheduleData = null;
                    
                    handleApiError(error, 'redigering av schema');
                }
            }

            /**
             * Create schedule for a specific class
             */
            function createScheduleForClass(classId, className) {
                editClassSchedule(classId, className);
            }

            /**
             * Reset schedule for a single class
             */
            async function resetSingleClassSchedule(classId, className) {
                if (!confirm(`Är du säker på att du vill ta bort schemat för "${className}"?\n\nDetta kan inte ångras.`)) {
                    return;
                }

                try {
                    const response = await fetch(`/api/class_schedule/reset/${classId}`, {
                        method: 'DELETE'
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        alert(`✅ Schema för "${className}" har rensats.\n${result.deleted_lessons} lektioner togs bort.`);
                        
                        // Refresh overview
                        viewAllClassSchedules();
                    } else {
                        throw new Error(result.error || 'Okänt fel');
                    }

                } catch (error) {
                    console.error('Error resetting single class schedule:', error);
                    alert(`❌ Fel vid rensning av schema: ${error.message}`);
                }
            }

            /**
             * Export schedules to CSV
             */
            async function exportSchedulesToCSV() {
                try {
                    debugLog('Exporting schedules to CSV...');
                    
                    // Get all class schedules
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });

                    const result = await response.json();
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta scheman');
                    }

                    // Get detailed schedule data for classes with schedules
                    const classesWithSchedule = result.classes_status.filter(cls => cls.has_schedule);
                    
                    if (classesWithSchedule.length === 0) {
                        alert('Inga scheman att exportera');
                        return;
                    }

                    // Prepare CSV data
                    const csvRows = [];
                    csvRows.push(['Klass', 'Dag', 'Starttid', 'Sluttid', 'Ämne', 'Rum', 'Antal lektioner']);

                    // Get detailed data for each class
                    for (const cls of classesWithSchedule) {
                        const detailResponse = await fetch(`/api/class_schedule/status/${cls.class_id}`);
                        const detailResult = await detailResponse.json();
                        
                        if (detailResult.success && detailResult.lessons_by_day) {
                            Object.entries(detailResult.lessons_by_day).forEach(([day, lessons]) => {
                                lessons.forEach(lesson => {
                                    const [startTime, endTime] = lesson.time.split('-');
                                    csvRows.push([
                                        cls.class_name,
                                        day,
                                        startTime,
                                        endTime,
                                        lesson.subject,
                                        lesson.room,
                                        '1'
                                    ]);
                                });
                            });
                        }
                    }

                    // Generate CSV
                    const csvContent = csvRows.map(row => 
                        row.map(field => `"${field}"`).join(',')
                    ).join('\n');

                    // Download CSV
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `scheman_${new Date().toISOString().split('T')[0]}.csv`;
                    link.click();

                    debugLog('CSV export completed');
                    alert(`✅ Scheman exporterade!\n${csvRows.length - 1} lektioner från ${classesWithSchedule.length} klasser.`);

                } catch (error) {
                    console.error('Error exporting schedules:', error);
                    alert(`❌ Fel vid export: ${error.message}`);
                }
            }

            /**
             * Show schedule statistics
             */
            async function showScheduleStatistics() {
                try {
                    debugLog('Loading schedule statistics...');
                    
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });

                    const result = await response.json();
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta statistik');
                    }

                    // Calculate statistics
                    const stats = calculateScheduleStatistics(result);
                    
                    // Show statistics modal
                    showStatisticsModal(stats);
                    
                } catch (error) {
                    console.error('Error loading statistics:', error);
                    alert(`❌ Fel vid laddning av statistik: ${error.message}`);
                }
            }

            /**
             * Calculate schedule statistics
             */
            function calculateScheduleStatistics(statusData) {
                const { classes_status, summary } = statusData;
                
                const stats = {
                    total_classes: summary.total_classes,
                    classes_with_schedule: summary.classes_with_schedule,
                    total_lessons: summary.total_lessons,
                    avg_lessons_per_class: summary.classes_with_schedule > 0 ? 
                        (summary.total_lessons / summary.classes_with_schedule).toFixed(1) : 0,
                    schedule_coverage: summary.total_classes > 0 ? 
                        ((summary.classes_with_schedule / summary.total_classes) * 100).toFixed(1) : 0,
                    
                    lessons_by_class: {},
                    most_lessons: { class: null, count: 0 },
                    least_lessons: { class: null, count: Infinity },
                    
                    completion_rate: summary.all_classes_have_schedule ? 100 : 
                        (summary.classes_with_schedule / summary.total_classes * 100).toFixed(1)
                };
                
                // Analyze per class
                classes_status.forEach(cls => {
                    if (cls.has_schedule) {
                        stats.lessons_by_class[cls.class_name] = cls.lesson_count;
                        
                        if (cls.lesson_count > stats.most_lessons.count) {
                            stats.most_lessons = { class: cls.class_name, count: cls.lesson_count };
                        }
                        
                        if (cls.lesson_count < stats.least_lessons.count) {
                            stats.least_lessons = { class: cls.class_name, count: cls.lesson_count };
                        }
                    }
                });
                
                // Reset least if no classes have schedules
                if (stats.least_lessons.count === Infinity) {
                    stats.least_lessons = { class: null, count: 0 };
                }
                
                return stats;
            }

            /**
             * Show statistics modal
             */
            function showStatisticsModal(stats) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 10000;
                    display: flex; align-items: center; justify-content: center;
                    overflow-y: auto; padding: 1rem;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; border-radius: 0.5rem; max-width: 600px; width: 100%;
                    max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                `;

                let html = `
                    <div style="padding: 1.5rem; border-bottom: 1px solid #e2e8f0;">
                        <h3 style="margin: 0; display: flex; justify-content: space-between; align-items: center;">
                            📈 Schemastatistik
                            <button onclick="this.closest('[style*=position]').remove()" 
                                    style="background: #f56565; color: white; border: none; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer;">
                                ✕
                            </button>
                        </h3>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div style="text-align: center; padding: 1rem; background: #f0fff4; border-radius: 0.5rem; border: 1px solid #9ae6b4;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #22543d;">${stats.total_classes}</div>
                                <div style="color: #4a5568;">Totalt klasser</div>
                            </div>
                            
                            <div style="text-align: center; padding: 1rem; background: #ebf8ff; border-radius: 0.5rem; border: 1px solid #90cdf4;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #2a4365;">${stats.classes_with_schedule}</div>
                                <div style="color: #4a5568;">Med scheman</div>
                            </div>
                            
                            <div style="text-align: center; padding: 1rem; background: #fef5e7; border-radius: 0.5rem; border: 1px solid #f6ad55;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #744210;">${stats.total_lessons}</div>
                                <div style="color: #4a5568;">Totalt lektioner</div>
                            </div>
                            
                            <div style="text-align: center; padding: 1rem; background: #f7fafc; border-radius: 0.5rem; border: 1px solid #cbd5e0;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #2d3748;">${stats.avg_lessons_per_class}</div>
                                <div style="color: #4a5568;">⌀ per klass</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin-bottom: 0.75rem; color: #2d3748;">🎯 Schemaläggningsstatus</h4>
                            <div style="background: #f7fafc; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #4299e1;">
                                <div style="margin-bottom: 0.5rem;">
                                    <strong>Täckningsgrad:</strong> ${stats.schedule_coverage}% 
                                    (${stats.classes_with_schedule}/${stats.total_classes} klasser)
                                </div>
                                <div style="background: #e2e8f0; height: 0.5rem; border-radius: 0.25rem; overflow: hidden;">
                                    <div style="background: ${stats.completion_rate == 100 ? '#38a169' : stats.completion_rate > 50 ? '#ed8936' : '#f56565'}; 
                                                height: 100%; width: ${stats.completion_rate}%; transition: width 0.3s ease;"></div>
                                </div>
                            </div>
                        </div>
                `;

                if (Object.keys(stats.lessons_by_class).length > 0) {
                    html += `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin-bottom: 0.75rem; color: #2d3748;">📊 Lektioner per klass</h4>
                            <div style="max-height: 200px; overflow-y: auto; background: #f7fafc; padding: 1rem; border-radius: 0.5rem;">
                    `;

                    Object.entries(stats.lessons_by_class)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([className, lessonCount]) => {
                            const percentage = (lessonCount / Math.max(...Object.values(stats.lessons_by_class))) * 100;
                            html += `
                                <div style="margin-bottom: 0.75rem;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                        <span>${className}</span>
                                        <strong>${lessonCount} lektioner</strong>
                                    </div>
                                    <div style="background: #e2e8f0; height: 0.25rem; border-radius: 0.125rem; overflow: hidden;">
                                        <div style="background: #4299e1; height: 100%; width: ${percentage}%; transition: width 0.3s ease;"></div>
                                    </div>
                                </div>
                            `;
                        });

                    html += `</div></div>`;

                    if (stats.most_lessons.class && stats.least_lessons.class) {
                        html += `
                            <div>
                                <h4 style="margin-bottom: 0.75rem; color: #2d3748;">🏆 Extremvärden</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div style="background: #c6f6d5; padding: 1rem; border-radius: 0.5rem; border: 1px solid #9ae6b4;">
                                        <div style="font-weight: bold; color: #22543d;">Mest lektioner</div>
                                        <div>${stats.most_lessons.class}</div>
                                        <div style="font-size: 1.2rem; font-weight: bold; color: #22543d;">${stats.most_lessons.count} lektioner</div>
                                    </div>
                                    <div style="background: #fed7d7; padding: 1rem; border-radius: 0.5rem; border: 1px solid #feb2b2;">
                                        <div style="font-weight: bold; color: #742a2a;">Minst lektioner</div>
                                        <div>${stats.least_lessons.class}</div>
                                        <div style="font-size: 1.2rem; font-weight: bold; color: #742a2a;">${stats.least_lessons.count} lektioner</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }

                html += `
                        <div style="text-align: center; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e2e8f0;">
                            <div style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                                Statistik genererad: ${new Date().toLocaleString('sv-SE')}
                            </div>
                            <button type="button" class="btn" onclick="exportStatisticsReport()" style="background: #48bb78; margin-right: 0.5rem;">
                                📊 Exportera rapport
                            </button>
                            <button type="button" class="btn" onclick="this.closest('[style*=position]').remove()" style="background: #718096;">
                                Stäng
                            </button>
                        </div>
                    </div>
                `;

                content.innerHTML = html;
                modal.appendChild(content);
                document.body.appendChild(modal);

                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                // Store stats globally for export
                window.currentScheduleStats = stats;
            }

            /**
             * Export statistics report
             */
            function exportStatisticsReport() {
                if (!window.currentScheduleStats) {
                    alert('Ingen statistik att exportera');
                    return;
                }

                const stats = window.currentScheduleStats;
                const timestamp = new Date().toLocaleString('sv-SE');
                
                let report = `SCHEMASTATISTIK RAPPORT\n`;
                report += `Genererad: ${timestamp}\n`;
                report += `${'='.repeat(50)}\n\n`;
                
                report += `ÖVERSIKT:\n`;
                report += `- Totalt klasser: ${stats.total_classes}\n`;
                report += `- Klasser med scheman: ${stats.classes_with_schedule}\n`;
                report += `- Totalt lektioner: ${stats.total_lessons}\n`;
                report += `- Genomsnitt lektioner per klass: ${stats.avg_lessons_per_class}\n`;
                report += `- Schematäckningsgrad: ${stats.schedule_coverage}%\n\n`;
                
                if (Object.keys(stats.lessons_by_class).length > 0) {
                    report += `LEKTIONER PER KLASS:\n`;
                    Object.entries(stats.lessons_by_class)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([className, lessonCount]) => {
                            report += `- ${className}: ${lessonCount} lektioner\n`;
                        });
                    report += `\n`;
                    
                    if (stats.most_lessons.class && stats.least_lessons.class) {
                        report += `EXTREMVÄRDEN:\n`;
                        report += `- Mest lektioner: ${stats.most_lessons.class} (${stats.most_lessons.count} lektioner)\n`;
                        report += `- Minst lektioner: ${stats.least_lessons.class} (${stats.least_lessons.count} lektioner)\n\n`;
                    }
                }
                
                report += `REKOMMENDATIONER:\n`;
                if (stats.completion_rate < 100) {
                    report += `- ${stats.total_classes - stats.classes_with_schedule} klasser saknar scheman\n`;
                }
                if (stats.most_lessons.count > stats.least_lessons.count + 5) {
                    report += `- Överväg att balansera lektioner mellan klasser\n`;
                }
                if (stats.completion_rate == 100) {
                    report += `- Alla klasser har scheman - bra jobbat!\n`;
                }

                // Create and download report
                const blob = new Blob([report], { type: 'text/plain;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `schemastatistik_${new Date().toISOString().split('T')[0]}.txt`;
                link.click();

                debugLog('Statistics report exported');
            }

            /**
             * Enhanced initialization function
             */
            function initializeScheduleManagement() {
                // Initialize data
                initializeData();
                
                // Setup auto-save detection
                let scheduleChangeDetected = false;
                
                // Monitor for schedule changes
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.target.id === 'schedulePreview' && currentSchedule) {
                            if (!scheduleChangeDetected) {
                                scheduleChangeDetected = true;
                                markScheduleAsUnsaved();
                            }
                        }
                    });
                });
                
                const previewElement = document.getElementById('schedulePreview');
                if (previewElement) {
                    observer.observe(previewElement, {
                        childList: true,
                        subtree: true
                    });
                }
                
                // Auto-update status periodically
                setInterval(() => {
                    if (selectedClasses.length > 0) {
                        updateClassScheduleStatus();
                    }
                }, 30000); // Every 30 seconds
                
                debugLog('Schedule management initialized');
            }

            /**
             * Enhanced error handling for API calls
             */
            function handleApiError(error, context = '') {
                console.error(`API Error ${context}:`, error);
                
                let userMessage = 'Ett fel uppstod';
                if (context) userMessage += ` vid ${context}`;
                
                if (error.message.includes('Unauthorized') || error.message.includes('403')) {
                    userMessage += '.\n\nDu har inte behörighet för denna åtgärd.';
                } else if (error.message.includes('Not Found') || error.message.includes('404')) {
                    userMessage += '.\n\nData hittades inte. Sidan kan behöva laddas om.';
                } else if (error.message.includes('500')) {
                    userMessage += '.\n\nServerfel. Försök igen senare.';
                } else {
                    userMessage += `.\n\nDetaljer: ${error.message}`;
                }
                
                alert(`❌ ${userMessage}`);
                debugLog(`Error handled for ${context}:`, error);
            }

            /**
             * Utility function to format time strings
             */
            function formatTimeRange(timeRange) {
                if (!timeRange || !timeRange.includes('-')) return timeRange;
                
                const [start, end] = timeRange.split('-');
                return `${start}–${end}`;
            }

            /**
             * Utility function to get class color by ID
             */
            function getClassColorById(classId) {
                const classIndex = availableClasses.findIndex(c => c.id == classId);
                return classIndex >= 0 ? classColors[classIndex % classColors.length] : '#718096';
            }

            /**
             * Debounce function for API calls
             */
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Debounced version of updateClassScheduleStatus
            const debouncedUpdateStatus = debounce(updateClassScheduleStatus, 500);

            // Override the existing DOMContentLoaded handler
            document.addEventListener('DOMContentLoaded', function() {
                // Call original initialization
                initializeData();
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
                populateTeacherFilter();
                renderSubjects();
                
                // Initialize schedule management
                initializeScheduleManagement();
                
                // Add keyboard shortcuts
                document.addEventListener('keydown', function(e) {
                    // Ctrl+S to save
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        if (currentSchedule) {
                            saveMultiClassSchedule();
                        }
                    }
                    
                    // Ctrl+R to reset (with confirmation)
                    if (e.ctrlKey && e.key === 'r' && selectedClasses.length > 0) {
                        e.preventDefault();
                        resetClassSchedules();
                    }
                    
                    // Ctrl+G to generate
                    if (e.ctrlKey && e.key === 'g') {
                        e.preventDefault();
                        generateMultiClassSchedule();
                    }
                });
                
                debugLog('Enhanced schedule management loaded with keyboard shortcuts');
            });
    



            function displayAllClassSchedules(statusData) {
                const overviewDiv = document.getElementById('scheduleOverview');
                const { classes_status, summary } = statusData;

                let html = `
                    <div class="schedule-overview-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 0.5rem;">
                        <h4 style="margin: 0;">📊 Översikt - Alla klasser</h4>
                        <div style="text-align: right; font-size: 0.9rem;">
                            <div><strong>${summary.classes_with_schedule}/${summary.total_classes}</strong> klasser har scheman</div>
                            <div style="color: #666;"><strong>${summary.total_lessons}</strong> totalt lektioner</div>
                        </div>
                    </div>

                    <div class="classes-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">
                `;

                classes_status.forEach((cls, index) => {
                    const classColor = classColors[index % classColors.length];
                    const statusColor = cls.has_schedule ? '#38a169' : '#e53e3e';
                    const statusIcon = cls.has_schedule ? '✅' : '❌';
                    const statusText = cls.has_schedule ? 'Schema sparat' : 'Inget schema';

                    html += `
                        <div class="class-schedule-card" style="border: 2px solid ${classColor}; border-radius: 0.5rem; padding: 1rem; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                <h5 style="margin: 0; color: ${classColor};">${cls.class_name}</h5>
                                <span style="color: ${statusColor}; font-weight: 600;">${statusIcon} ${statusText}</span>
                            </div>
                            
                            ${cls.has_schedule ? `
                                <div style="margin-bottom: 0.75rem;">
                                    <div style="font-size: 0.9rem; color: #4a5568;">
                                        📚 <strong>${cls.lesson_count}</strong> lektioner per vecka
                                    </div>
                                </div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <button type="button" class="btn" onclick="viewClassScheduleDetails(${cls.class_id}, '${cls.class_name}')" 
                                            style="background: #4299e1; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                        👁️ Visa
                                    </button>
                                    <button type="button" class="btn" onclick="editClassSchedule(${cls.class_id}, '${cls.class_name}')" 
                                            style="background: #ed8936; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                        ✏️ Redigera
                                    </button>
                                    <button type="button" class="btn" onclick="resetSingleClassSchedule(${cls.class_id}, '${cls.class_name}')" 
                                            style="background: #f56565; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                        🗑️ Rensa
                                    </button>
                                </div>
                            ` : `
                                <div style="color: #666; font-style: italic; margin-bottom: 0.75rem;">
                                    Inget schema har skapats för denna klass än.
                                </div>
                                <button type="button" class="btn" onclick="createScheduleForClass(${cls.class_id}, '${cls.class_name}')" 
                                        style="background: #48bb78; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                    ➕ Skapa schema
                                </button>
                            `}
                        </div>
                    `;
                });

                html += `
                    </div>
                    
                    <div style="text-align: center; margin-top: 1.5rem;">
                        <button type="button" class="btn" onclick="hideScheduleOverview()" style="background: #718096;">
                            ⬆️ Dölj översikt
                        </button>
                    </div>
                `;

                overviewDiv.innerHTML = html;
                debugLog('All class schedules displayed');
            }




            async function viewAllClassSchedules() {
                try {
                    debugLog('Loading all class schedules...');
                    
                    // Show loading state
                    const overviewDiv = document.getElementById('scheduleOverview');
                    overviewDiv.style.display = 'block';
                    overviewDiv.innerHTML = '<div style="text-align: center;"><div class="loading-spinner"></div><p>Laddar scheman...</p></div>';

                    // Get status for all classes in school
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });

                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta scheman');
                    }

                    // Display overview
                    displayAllClassSchedules(result);
                    
                } catch (error) {
                    console.error('Error loading all schedules:', error);
                    const overviewDiv = document.getElementById('scheduleOverview');
                    overviewDiv.innerHTML = `<div style="color: #e53e3e; text-align: center;">Fel vid laddning: ${error.message}</div>`;
                }
            }




            async function resetClassSchedules() {
                if (selectedClasses.length === 0) {
                    alert('Inga klasser valda för rensning');
                    return;
                }

                // Check which classes have existing schedules
                const classesWithSchedule = [];
                const classesWithoutSchedule = [];
                
                for (const cls of selectedClasses) {
                    const status = scheduleSaveState.classScheduleStatus[cls.id];
                    if (status && status.has_schedule) {
                        classesWithSchedule.push(cls);
                    } else {
                        classesWithoutSchedule.push(cls);
                    }
                }

                if (classesWithSchedule.length === 0) {
                    alert('Inga av de valda klasserna har befintliga scheman att rensa');
                    return;
                }

                // Confirm reset
                let confirmMessage = `⚠️ VARNING: Detta kommer att permanent ta bort scheman för:\n\n`;
                classesWithSchedule.forEach(cls => {
                    const status = scheduleSaveState.classScheduleStatus[cls.id];
                    confirmMessage += `• ${cls.name} (${status ? status.lesson_count : '?'} lektioner)\n`;
                });
                
                if (classesWithoutSchedule.length > 0) {
                    confirmMessage += `\nFöljande klasser har inga befintliga scheman:\n`;
                    classesWithoutSchedule.forEach(cls => confirmMessage += `• ${cls.name}\n`);
                }
                
                confirmMessage += `\nÄr du säker på att du vill fortsätta?`;

                if (!confirm(confirmMessage)) {
                    debugLog('Reset cancelled by user');
                    return;
                }

                try {
                    debugLog('Resetting class schedules...', {classes: classesWithSchedule.map(c => c.name)});

                    let totalDeleted = 0;
                    let resetResults = [];

                    // Reset each class individually
                    for (const cls of classesWithSchedule) {
                        const response = await fetch(`/api/class_schedule/reset/${cls.id}`, {
                            method: 'DELETE'
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            totalDeleted += result.deleted_lessons;
                            resetResults.push(`${cls.name}: ${result.deleted_lessons} lektioner`);
                            debugLog(`Reset successful for class ${cls.name}:`, result);
                        } else {
                            throw new Error(`Fel för ${cls.name}: ${result.error}`);
                        }
                    }

                    // Clear current schedule if it was for the reset classes
                    currentSchedule = null;
                    const preview = document.getElementById('schedulePreview');
                    preview.innerHTML = `
                        <div style="text-align: center; color: #38a169;">
                            <h3>✅ Scheman rensade framgångsrikt</h3>
                            <p><strong>Totalt ${totalDeleted} lektioner borttagna</strong></p>
                            <div style="margin-top: 1rem; text-align: left; display: inline-block;">
                                ${resetResults.map(r => `<div>📚 ${r}</div>`).join('')}
                            </div>
                            <p style="margin-top: 1.5rem;">Generera ett nytt schema för att fortsätta.</p>
                        </div>
                    `;

                    // Hide generation controls
                    const controls = document.getElementById('generationControls');
                    if (controls) controls.style.display = 'none';

                    // Update status
                    await updateClassScheduleStatus();
                    
                    // Update save state
                    scheduleSaveState.hasUnsavedChanges = false;
                    scheduleSaveState.lastSavedSchedule = null;

                    showSuccessMessage(`✅ Scheman rensade framgångsrikt!\n\n${totalDeleted} lektioner borttagna från ${classesWithSchedule.length} klass${classesWithSchedule.length !== 1 ? 'er' : ''}.`);

                } catch (error) {
                    console.error('Error resetting schedules:', error);
                    alert(`❌ Fel vid rensning av scheman:\n${error.message}`);
                    debugLog('Reset failed:', error);
                }
            }


            function showSuccessMessage(message) {
                // Create simple success modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.5); z-index: 10000; 
                    display: flex; align-items: center; justify-content: center;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; padding: 2rem; border-radius: 0.5rem; 
                    max-width: 500px; margin: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                `;

                content.innerHTML = `
                    <div style="text-align: center;">
                        <div style="white-space: pre-line; margin-bottom: 1.5rem;">${message}</div>
                        <button onclick="this.closest('[style*=position]').remove()" 
                                style="background: #48bb78; color: white; padding: 0.5rem 1.5rem; 
                                    border: none; border-radius: 0.375rem; cursor: pointer;">
                            OK
                        </button>
                    </div>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (modal.parentNode) modal.remove();
                }, 5000);
            }


            document.addEventListener('DOMContentLoaded', function() {
                // Add event listener for page unload to warn about unsaved changes
                window.addEventListener('beforeunload', function(e) {
                    if (scheduleSaveState.hasUnsavedChanges) {
                        const message = 'Du har osparade ändringar i schemat. Är du säker på att du vill lämna sidan?';
                        e.returnValue = message;
                        return message;
                    }
                });
                
                // Update status after initial load
                setTimeout(() => {
                    if (selectedClasses.length > 0) {
                        updateClassScheduleStatus();
                    }
                }, 500);
            });


            const originalUpdateSelectedClasses = updateSelectedClasses;
            updateSelectedClasses = function() {
                // Call original function
                originalUpdateSelectedClasses();
                
                // Update status for newly selected classes
                setTimeout(() => {
                    updateClassScheduleStatus();
                }, 100);
            };



            const originalGenerateMultiClassSchedule = generateMultiClassSchedule;
            generateMultiClassSchedule = async function() {
                // Call original function
                await originalGenerateMultiClassSchedule();
                
                // Mark as having unsaved changes if generation was successful
                if (currentSchedule) {
                    markScheduleAsUnsaved();
                    await updateClassScheduleStatus();
                }
            };



            

            /**
             * Enter edit mode UI state
             */
            function enterEditMode(scheduleData) {
                // Update header to show edit mode
                
                
                // Hide class selection (already selected)
                const classContainer = document.getElementById('classesContainer');
                if (classContainer) {
                    classContainer.style.opacity = '0.5';
                    classContainer.style.pointerEvents = 'none';
                }
                
                // Disable subject configuration
                const subjectsContainer = document.getElementById('subjectsContainer');
                if (subjectsContainer) {
                    subjectsContainer.innerHTML = `
                        <div style="padding: 1rem; background: #f7fafc; border-radius: 0.5rem; border: 1px solid #e2e8f0; text-align: center; color: #4a5568;">
                            <strong>Redigeringsläge:</strong> Ämnen och timmar bestäms av befintligt schema
                        </div>
                    `;
                }
            }

            /**
             * Exit edit mode and return to normal state
             */
            function exitEditMode() {
                isEditMode = false;
                editingClassId = null;
                editingClassName = null;
                originalScheduleData = null;
                
                // Remove edit header
                const editHeader = document.getElementById('editModeHeader');
                if (editHeader) editHeader.remove();
                
                // Restore UI elements
                const classContainer = document.getElementById('classesContainer');
                if (classContainer) {
                    classContainer.style.opacity = '1';
                    classContainer.style.pointerEvents = 'auto';
                }
                
                // Restore subject configuration
                renderClassSubjectSections();
                
                // Clear preview
                const preview = document.getElementById('schedulePreview');
                preview.innerHTML = `
                    <div style="text-align: center;">
                        <p>Välj klasser och ämnen för att generera ett multi-klass schema</p>
                    </div>
                `;
                
                // Hide controls
                document.getElementById('generationControls').style.display = 'none';
                
                debugLog('Edit mode exited');
            }


            // Ny funktion för att generera diskreta tidsintervall
            function generateDiscreteTimeSlots(startTime, endTime, intervalMinutes) {
                const slots = [];
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                
                let currentTime = startMinutes;
                
                while (currentTime <= endMinutes) {
                    slots.push(minutesToTime(currentTime));
                    currentTime += intervalMinutes;
                }
                
                return slots;
            }

            // Ny funktion för att skapa lesson grid med spanning
            // 4. Förbättra createLessonGrid för korrekt lesson ID hantering
            function createLessonGrid(scheduleData, weekdays, discreteTimeSlots) {
                const grid = {};
                
                // Initiera grid
                weekdays.forEach(day => {
                    grid[day] = {};
                    discreteTimeSlots.forEach(timeSlot => {
                        grid[day][timeSlot] = { type: 'empty', lesson: null, spanRows: 0 };
                    });
                });
                
                // Placera lektioner i grid
                if (scheduleData.lessons_by_day) {
                    Object.entries(scheduleData.lessons_by_day).forEach(([day, lessons]) => {
                        lessons.forEach((lesson, lessonIndex) => {
                            // Skapa unikt lesson ID om det inte finns
                            if (!lesson.id) {
                                lesson.id = `${day}-${lessonIndex}-${lesson.subject?.replace(/\s+/g, '')}-${lesson.time?.replace(/[:-]/g, '')}`;
                            }
                            
                            const [lessonStartTime, lessonEndTime] = lesson.time.split('-');
                            const lessonStartMinutes = timeToMinutes(lessonStartTime);
                            const lessonEndMinutes = timeToMinutes(lessonEndTime);
                            
                            // RÄTT metod: Hitta närmaste tidslot som är <= lektionens starttid
                            let startIndex = -1;
                            let bestMatch = -1;
                            
                            discreteTimeSlots.forEach((timeSlot, index) => {
                                const slotMinutes = timeToMinutes(timeSlot);
                                
                                // Hitta den senaste tidslot som är <= lektionens starttid
                                if (slotMinutes <= lessonStartMinutes) {
                                    if (slotMinutes > bestMatch) {
                                        bestMatch = slotMinutes;
                                        startIndex = index;
                                    }
                                }
                            });

                            // Sätt start cell med korrekt spanRows
                            if (startIndex >= 0 && startIndex < discreteTimeSlots.length) {
                                const startTimeSlot = discreteTimeSlots[startIndex];
                                
                                // Beräkna spanRows baserat på faktisk lektionstid
                                const intervalMinutes = 5;
                                const actualDurationMinutes = lessonEndMinutes - lessonStartMinutes;
                                const spanRows = Math.ceil(actualDurationMinutes / intervalMinutes);
                                
                                grid[day][startTimeSlot] = {
                                    type: 'lesson-start',
                                    lesson: lesson,
                                    spanRows: spanRows
                                };
                                
                                // Markera mellanliggande celler
                                const endIndex = Math.min(startIndex + spanRows - 1, discreteTimeSlots.length - 1);
                                for (let i = startIndex + 1; i <= endIndex; i++) {
                                    const middleTimeSlot = discreteTimeSlots[i];
                                    grid[day][middleTimeSlot] = {
                                        type: 'lesson-middle',
                                        lesson: lesson,
                                        spanRows: 0
                                    };
                                }
                            }
                        });
                    });
                }
                
                return grid;
            }


            // Lägg till styles om de inte redan finns
            if (!document.getElementById('spanning-lesson-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'spanning-lesson-styles';
                styleElement.textContent = spanningLessonStyles;
                document.head.appendChild(styleElement);
            }



            // Lägg till CSS för spanning lessons
            const spanningLessonStyles = `
                .schedule-cell {
                    position: relative;
                }
                
                .spanning-lesson {
                    box-sizing: border-box;
                }
                
                .spanning-lesson:hover {
                    z-index: 30 !important;
                    transform: scale(1.02) !important;
                }
                
                .spanning-lesson:active {
                    cursor: grabbing !important;
                }
                
                .lesson-middle {
                    background: linear-gradient(135deg, #4299e1, #3182ce) !important; /* SAMMA FÄRG som lektionsblocket */
                    border-top: 1px solid rgba(255,255,255,0.3) !important;
                    border-left: 1px solid rgba(255,255,255,0.3) !important;
                    border-right: 1px solid rgba(255,255,255,0.3) !important;
                }
                
                .editable-schedule-table td {
                    padding: 0;
                    vertical-align: top;
                }
                
                .editable-schedule-table .schedule-cell.empty {
                    background: transparent;
                }
                
                .editable-schedule-table .schedule-cell.lesson-start {
                    background: transparent; /* Låt lektionsblocket hantera färgen */
                }
                
                .editable-schedule-table .schedule-cell.lesson-middle {
                    background: linear-gradient(135deg, #4299e1, #3182ce); /* SAMMA FÄRG */
                    border-left: 1px solid rgba(255,255,255,0.3);
                    border-right: 1px solid rgba(255,255,255,0.3);
                }
            `;


            /**
             * Display schedule in editable format with drag-and-drop
             */
            // Förbättrad displayEditableSchedule med scroll-container
            // Uppdaterad displayEditableScheduleWithAutoScroll funktion
            // Ersätt displayEditableScheduleWithAutoScroll funktionen med denna:
            // Ersätt displayEditableScheduleWithAutoScroll funktionen med denna:
            function displayEditableScheduleWithAutoScroll(scheduleData) {
                const preview = document.getElementById('schedulePreview');
                
                // Skapa scroll-container
                const scrollContainer = document.createElement('div');
                scrollContainer.id = 'scheduleScrollContainer';
                scrollContainer.style.cssText = `
                    max-height: 70vh;
                    overflow: auto;
                    position: relative;
                    border: 2px solid #e2e8f0;
                    border-radius: 0.5rem;
                    background: white;
                    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
                `;

                // Generera diskreta tidsintervall (5-minuters intervall)
                const discreteTimeSlots = generateDiscreteTimeSlots('08:00', '18:00', 5);
                
                // Build schedule grid med förbättrad layout
                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                
                // Store lesson data för lookup
                window.editModeLessons = {};
                
                let html = `<table class="editable-schedule-table" style="
                    width: 100%; 
                    border-collapse: collapse; 
                    user-select: none;
                    min-width: 800px;
                ">`;
                
                // Table header
                html += '<thead><tr style="position: sticky; top: 0; background: white; z-index: 50;">';
                html += '<th style="min-width: 80px; padding: 12px; background: #f7fafc; border: 1px solid #e2e8f0; font-weight: 600;">Tid</th>';
                weekdays.forEach(day => {
                    html += `<th style="min-width: 160px; padding: 12px; background: #f7fafc; border: 1px solid #e2e8f0; text-align: center; font-weight: 600;">
                        ${day.charAt(0).toUpperCase() + day.slice(1)}
                    </th>`;
                });
                html += '</tr></thead><tbody>';
                
                // Skapa en grid för lektioner per dag och tid
                const lessonGrid = createLessonGrid(scheduleData, weekdays, discreteTimeSlots);
                
                // Rendera rader för varje diskret tidsslot
                discreteTimeSlots.forEach(timeSlot => {
                    html += `<tr><td style="
                        padding: 4px 12px; 
                        font-weight: 600; 
                        background: #f9fafb; 
                        border: 1px solid #e2e8f0;
                        white-space: nowrap;
                        position: sticky;
                        left: 0;
                        z-index: 10;
                        height: 20px;
                        font-size: 12px;
                        line-height: 1;
                    ">${timeSlot}</td>`;
                    
                    weekdays.forEach(day => {
                        const cellId = `cell-${day}-${timeSlot.replace(':', '-')}`;
                        const cellData = lessonGrid[day][timeSlot];
                        
                        html += `<td id="${cellId}" 
                                    class="schedule-cell ${cellData.type}" 
                                    data-day="${day}" 
                                    data-time="${timeSlot}"
                                    ondrop="handleLessonDrop(event)" 
                                    ondragover="handleDragOver(event)"
                                    ondragenter="handleDragEnter(event)"
                                    ondragleave="handleDragLeave(event)"
                                    style="
                                        padding: 0; 
                                        border: 1px solid #e2e8f0; 
                                        height: 20px;
                                        position: relative; 
                                        vertical-align: top;
                                        transition: all 0.2s ease;
                                        ${cellData.type === 'lesson-start' ? 'background: transparent;' : ''}
                                        ${cellData.type === 'lesson-middle' ? 'background: linear-gradient(135deg, #4299e1, #3182ce); border-left: 1px solid rgba(255,255,255,0.3); border-right: 1px solid rgba(255,255,255,0.3);' : ''}
                                    ">`;

                        
                        // Rendera lektion bara på start-raden (utan höjdberäkning här)
                        // Rendera lektion bara på start-raden (utan höjdberäkning här)
                        if (cellData.type === 'lesson-start' && cellData.lesson) {
                            const lessonWithTeacher = {
                                ...cellData.lesson,
                                teacher_id: cellData.lesson.teacher_id || cellData.lesson.teacherId,
                                teacher_name: cellData.lesson.teacher_name || cellData.lesson.teacherName || cellData.lesson.teacher
                            };
                            
                            // Store complete lesson data including teacher info
                            window.editModeLessons[cellData.lesson.id] = lessonWithTeacher;
                            
                            html += `<div id="lesson-${cellData.lesson.id}" 
                                class="draggable-lesson spanning-lesson" 
                                draggable="true"
                                data-lesson-id="${cellData.lesson.id}"
                                data-subject="${escapeHtml(cellData.lesson.subject || cellData.lesson.school_subject || 'Okänt ämne')}"
                                data-room="${escapeHtml(cellData.lesson.room || 'Inget rum')}"
                                data-original-day="${day}"
                                data-original-time="${cellData.lesson.time}"
                                data-span-rows="${cellData.spanRows}"
                                data-teacher-id="${lessonWithTeacher.teacher_id || ''}"
                                data-teacher-name="${escapeHtml(lessonWithTeacher.teacher_name || '')}"
                                style="position: absolute; left: 1px; right: 1px; background: linear-gradient(135deg, #4299e1, #3182ce); color: white; padding: 4px 8px; border-radius: 6px; cursor: move; box-shadow: 0 2px 4px rgba(0,0,0,0.15); transition: all 0.2s ease; border: 1px solid rgba(255,255,255,0.3); z-index: 10; overflow: hidden; font-size: 11px; line-height: 1.2; box-sizing: border-box;"
                                ondragstart="handleLessonDragStartEnhanced(event)"
                                ondragend="handleLessonDragEndEnhanced(event)">
                                <div style="font-weight: 700; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${escapeHtml(cellData.lesson.subject || cellData.lesson.school_subject || 'Okänt ämne')}
                                </div>
                            </div>`;
                        }
                        
                        html += '</td>';
                    });
                    
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                
                // Set content
                scrollContainer.innerHTML = html;

                // Preserve existing edit header
                const existingHeader = document.getElementById('editModeHeader');
                const headerHtml = existingHeader ? existingHeader.outerHTML : '';
                
                preview.innerHTML = headerHtml;
                preview.appendChild(scrollContainer);
                
                // Store reference för auto-scroll
                scheduleScrollContainer = scrollContainer;
                
                // VIKTIGT: Beräkna korrekta höjder EFTER DOM är renderad
                setTimeout(() => {
                    adjustLessonHeights();
                    setupAutoScrollBounds();
                    attachScrollListeners();
                }, 50);
                
                debugLog('Enhanced editable schedule displayed with discrete time slots');
            }

            // Ny funktion för att justera lesson-höjder efter DOM är renderad
            // Uppdatera adjustLessonHeights funktionen för att inkludera rum-knapp i room-info
            function adjustLessonHeights() {
                document.querySelectorAll('.spanning-lesson').forEach(lessonElement => {
                    const lessonId = lessonElement.dataset.lessonId;
                    const lesson = window.editModeLessons[lessonId];
                    const day = lessonElement.dataset.originalDay;
                    const originalTime = lessonElement.dataset.originalTime;
                    const spanRows = parseInt(lessonElement.dataset.spanRows);
                    
                    if (!lesson || !originalTime) return;
                    
                    const [lessonStartTime, lessonEndTime] = originalTime.split('-');
                    const lessonStartMinutes = timeToMinutes(lessonStartTime);
                    const lessonEndMinutes = timeToMinutes(lessonEndTime);
                    const durationMinutes = lessonEndMinutes - lessonStartMinutes;
                    
                    // Hitta första cellen
                    const discreteTimeSlots = generateDiscreteTimeSlots('08:00', '18:00', 5);
                    let startTimeSlot = null;
                    let bestMatch = -1;
                    
                    discreteTimeSlots.forEach(timeSlot => {
                        const slotMinutes = timeToMinutes(timeSlot);
                        if (slotMinutes <= lessonStartMinutes && slotMinutes > bestMatch) {
                            bestMatch = slotMinutes;
                            startTimeSlot = timeSlot;
                        }
                    });
                    
                    if (!startTimeSlot) return;
                    
                    const firstCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${startTimeSlot}"]`);
                    if (!firstCell) return;
                    
                    const actualCellHeight = firstCell.getBoundingClientRect().height;
                    const pixelsPerMinute = actualCellHeight / 5; // 5 minuter per cell
                    
                    // Beräkna offset och höjd
                    const slotStartMinutes = timeToMinutes(startTimeSlot);
                    const offsetMinutes = Math.max(0, lessonStartMinutes - slotStartMinutes);
                    const offsetPixels = Math.round(offsetMinutes * pixelsPerMinute);
                    
                    // Beräkna total tillgänglig höjd
                    const lastCellStartMinutes = slotStartMinutes + (spanRows - 1) * 5;
                    const lastCellTime = minutesToTime(lastCellStartMinutes);
                    const lastCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${lastCellTime}"]`);
                    
                    let totalAvailableHeight = spanRows * actualCellHeight;
                    if (firstCell && lastCell) {
                        const firstRect = firstCell.getBoundingClientRect();
                        const lastRect = lastCell.getBoundingClientRect();
                        totalAvailableHeight = Math.max(0, lastRect.bottom - firstRect.top);
                    }
                    
                    const durationPixels = Math.round(durationMinutes * pixelsPerMinute);
                    const maxPossibleHeight = Math.max(0, totalAvailableHeight - offsetPixels - 2);
                    const blockHeight = Math.max(20, Math.min(durationPixels, maxPossibleHeight));
                    
                    // Uppdatera element
                    lessonElement.style.top = `${offsetPixels}px`;
                    lessonElement.style.height = `${blockHeight}px`;
                    
                    // Lägg till mer innehåll om det finns plats
                    const contentDiv = lessonElement.querySelector('div');
                    if (spanRows >= 3 && !lessonElement.querySelector('.room-info')) {
                        const roomDiv = document.createElement('div');
                        roomDiv.className = 'room-info';
                        roomDiv.style.cssText = `
                            font-size: 10px; 
                            opacity: 0.9; 
                            white-space: nowrap; 
                            overflow: hidden; 
                            text-overflow: ellipsis;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            gap: 4px;
                        `;
                        
                        // Skapa rum-text span
                        const roomText = document.createElement('span');
                        roomText.textContent = `📍 ${lesson.room || 'Inget rum'}`;
                        roomDiv.appendChild(roomText);
                        
                        // Lägg till rum-byta knapp
                        const roomChangeBtn = document.createElement('button');
                        roomChangeBtn.className = 'room-change-btn-inline';
                        roomChangeBtn.innerHTML = '🔄';
                        roomChangeBtn.title = 'Byt klassrum';
                        roomChangeBtn.onclick = (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            showRoomChangeModal(lessonId, e);
                        };
                        roomChangeBtn.style.cssText = `
                            background: rgba(255, 255, 255, 0.8);
                            border: 1px solid rgba(0,0,0,0.2);
                            border-radius: 50%;
                            width: 16px;
                            height: 16px;
                            cursor: pointer;
                            font-size: 8px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.2s ease;
                            flex-shrink: 0;
                        `;
                        roomDiv.appendChild(roomChangeBtn);
                        
                        contentDiv.after(roomDiv);
                    }
                    
                    if (spanRows >= 5 && !lessonElement.querySelector('.time-info')) {
                        const timeDiv = document.createElement('div');
                        timeDiv.className = 'time-info';
                        timeDiv.style.cssText = 'font-size: 10px; opacity: 0.8; margin-top: 2px;';
                        timeDiv.textContent = `🕒 ${originalTime}`;
                        lessonElement.appendChild(timeDiv);
                    }

                    if (spanRows >= 7 && !lessonElement.querySelector('.teacher-info')) {
                        const teacherDiv = document.createElement('div');
                        teacherDiv.className = 'teacher-info';
                        teacherDiv.style.cssText = 'font-size: 10px; opacity: 0.8; margin-top: 2px;';
                        
                        const teacherName = lesson.teacher_name || lesson.teacher || 'Okänd lärare';
                        teacherDiv.textContent = `👨‍🏫 ${teacherName}`;
                        
                        lessonElement.appendChild(teacherDiv);
                    }
                });
            }

            function displayEditableSchedule(scheduleData) {
                return displayEditableScheduleWithAutoScroll(scheduleData);
            }

            /**
             * Create draggable lesson block for editing (backward compatibility)
             */
            function createEditableLessonBlock(lesson, day, timeSlot) {
                return createEditableLessonBlockEnhanced(lesson, day, timeSlot);
            }


            // Uppdaterad funktion för att skapa spanning lesson blocks
            // 5. Uppdatera createEditableLessonBlockSpanning med korrekt lesson data
            // Ersätt denna funktion (createEditableLessonBlockSpanning) med denna version.
            // Förklaring: vi hämtar verkliga DOM-höjder för start- och slutcell istället för
            // att använda hårdkodade 20px/5min. Vi beräknar blockets top (offset) och höjd
            // från cellernas bounding rects vilket gör att blocket alltid fyller korrekt tid.
            // --- Ersätt hela createEditableLessonBlockSpanning med denna ---
            // Uppdatera createEditableLessonBlockSpanning för att inkludera rum-knapp
            // Uppdatera createEditableLessonBlockSpanningWithRoomButton för att använda room-info div
            function createEditableLessonBlockSpanningWithRoomButton(lesson, day, timeSlot, spanRows) {
                const lessonId = lesson.id;
                const firstCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${timeSlot}"]`);
                const teacherId = lesson.teacher_id || lesson.teacherId || null;
                const teacherName = lesson.teacher_name || lesson.teacherName || lesson.teacher || null;
                
                const minutesPerCell = firstCell && firstCell.dataset && firstCell.dataset.minutesPerSlot
                    ? parseInt(firstCell.dataset.minutesPerSlot, 10)
                    : 5;

                const fallbackCellHeight = 20;
                const actualCellHeight = firstCell ? firstCell.getBoundingClientRect().height : fallbackCellHeight;
                const pixelsPerMinute = actualCellHeight / minutesPerCell;

                const [lessonStartTime, lessonEndTime] = lesson.time.split('-');
                const lessonStartMinutes = timeToMinutes(lessonStartTime);
                const lessonEndMinutes = timeToMinutes(lessonEndTime);
                const durationMinutes = Math.max(0, lessonEndMinutes - lessonStartMinutes);

                const slotStartMinutes = timeToMinutes(timeSlot);
                const offsetMinutes = Math.max(0, lessonStartMinutes - slotStartMinutes);
                const offsetPixels = Math.max(0, Math.round(offsetMinutes * pixelsPerMinute));

                const lastCellStartMinutes = slotStartMinutes + (spanRows - 1) * minutesPerCell;
                const lastCellTime = minutesToTime(lastCellStartMinutes);
                const lastCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${lastCellTime}"]`);

                let totalAvailableHeight;
                if (firstCell && lastCell) {
                    const firstRect = firstCell.getBoundingClientRect();
                    const lastRect = lastCell.getBoundingClientRect();
                    totalAvailableHeight = Math.max(0, lastRect.bottom - firstRect.top);
                } else {
                    totalAvailableHeight = Math.max(0, spanRows * actualCellHeight);
                }

                const estimatedCellsHeight = spanRows * actualCellHeight;
                const gapAdjustment = Math.max(0, totalAvailableHeight - estimatedCellsHeight);
                const durationPixels = Math.round(durationMinutes * pixelsPerMinute);
                const desiredHeight = durationPixels + gapAdjustment;
                const maxPossibleHeight = Math.max(0, totalAvailableHeight - offsetPixels - 2);
                const MIN_LESSON_HEIGHT = 20;
                const computed = Math.min(desiredHeight, maxPossibleHeight);
                const blockHeight = Math.max(MIN_LESSON_HEIGHT, Math.ceil(computed + 1));

                return `
                    <div id="lesson-${lessonId}" 
                        class="draggable-lesson spanning-lesson" 
                        draggable="true"
                        ondragstart="handleLessonDragStartEnhanced(event)"
                        ondragend="handleLessonDragEndEnhanced(event)"
                        data-lesson-id="${lessonId}"
                        data-subject="${escapeHtml(lesson.subject || lesson.school_subject || 'Okänt ämne')}"
                        data-room="${escapeHtml(lesson.room || 'Inget rum')}"
                        data-original-day="${day}"
                        data-original-time="${lesson.time}"
                        data-span-rows="${spanRows}"
                        data-teacher-id="${teacherId || ''}"
                        data-teacher-name="${escapeHtml(teacherName || '')}"
                        style="
                            position: absolute;
                            top: ${offsetPixels}px;
                            left: 1px;
                            right: 1px;
                            height: ${blockHeight}px;
                            background: linear-gradient(135deg, #4299e1, #3182ce);
                            color: white;
                            padding: 4px 8px;
                            border-radius: 6px;
                            cursor: move;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
                            transition: all 0.2s ease;
                            border: 1px solid rgba(255,255,255,0.3);
                            z-index: 10;
                            overflow: hidden;
                            font-size: 11px;
                            line-height: 1.2;
                            box-sizing: border-box;
                        "
                        onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.25)'; this.style.zIndex='20';"
                        onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.15)'; this.style.zIndex='10';">
                        
                        <div style="font-weight: 700; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${escapeHtml(lesson.subject || lesson.school_subject || 'Okänt ämne')}
                        </div>
                        
                        ${spanRows >= 3 ? `
                            <div class="room-info" style="
                                font-size: 10px; 
                                opacity: 0.9; 
                                white-space: nowrap; 
                                overflow: hidden; 
                                text-overflow: ellipsis;
                                display: flex;
                                align-items: center;
                                justify-content: space-between;
                                gap: 4px;
                            ">
                                <span>📍 ${escapeHtml(lesson.room || 'Inget rum')}</span>
                                <button class="room-change-btn-inline" 
                                        onclick="showRoomChangeModal('${lessonId}', event)" 
                                        title="Byt klassrum"
                                        style="
                                            background: rgba(255, 255, 255, 0.8);
                                            border: 1px solid rgba(0,0,0,0.2);
                                            border-radius: 50%;
                                            width: 16px;
                                            height: 16px;
                                            cursor: pointer;
                                            font-size: 8px;
                                            display: flex;
                                            align-items: center;
                                            justify-content: center;
                                            transition: all 0.2s ease;
                                            flex-shrink: 0;
                                        ">🔄</button>
                            </div>
                        ` : ''}
                        
                        ${spanRows >= 5 ? `
                            <div style="font-size: 10px; opacity: 0.8; margin-top: 2px;">
                                🕒 ${lesson.time}
                            </div>
                        ` : ''}

                        ${spanRows >= 7 ? `
                            <div class="teacher-info" style="font-size: 10px; opacity: 0.8; margin-top: 2px;">
                                👨‍🏫 ${escapeHtml(teacherName || lesson.teacher || 'Okänd lärare')}
                            </div>
                        ` : ''}
                        
                        <div class="drag-handle" style="
                            position: absolute;
                            top: 2px;
                            right: 2px;
                            width: 12px;
                            height: 12px;
                            background: rgba(255,255,255,0.3);
                            border-radius: 2px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 8px;
                            cursor: grab;
                        ">⋮⋮</div>
                    </div>
                `;
            }


    



            /**
             * Create draggable lesson block for editing
             */
            // 1. Fix för createEditableLessonBlock - lägg till korrekt lesson ID
            // Uppdatera lesson block creation för att använda enhanced handlers
            function createEditableLessonBlockEnhanced(lesson, day, timeSlot) {
                const lessonId = lesson.id;
                
                return `
                    <div id="lesson-${lessonId}" 
                        class="draggable-lesson" 
                        draggable="true"
                        ondragstart="handleLessonDragStartEnhanced(event)"
                        ondragend="handleLessonDragEndEnhanced(event)"
                        data-lesson-id="${lessonId}"
                        data-subject="${lesson.subject}"
                        data-room="${lesson.room}"
                        data-original-day="${day}"
                        data-original-time="${timeSlot}"
                        style="
                            background: linear-gradient(135deg, #4299e1, #3182ce);
                            color: white;
                            padding: 10px;
                            border-radius: 8px;
                            cursor: move;
                            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
                            transition: all 0.2s ease;
                            border: 2px solid transparent;
                            position: relative;
                        "
                        onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 6px 12px rgba(0,0,0,0.2)'"
                        onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 6px rgba(0,0,0,0.15)'">
                        <div style="font-weight: 700; font-size: 0.9rem; margin-bottom: 4px;">
                            ${escapeHtml(lesson.subject)}
                        </div>
                        <div style="font-size: 0.8rem; opacity: 0.9; margin-bottom: 2px;">
                            📍 ${escapeHtml(lesson.room || 'Inget rum')}
                        </div>
                        <div class="drag-handle" style="
                            position: absolute;
                            top: 4px;
                            right: 4px;
                            width: 16px;
                            height: 16px;
                            background: rgba(255,255,255,0.3);
                            border-radius: 3px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 10px;
                            cursor: grab;
                        ">⋮⋮</div>
                        <div style="
                            position: absolute;
                            bottom: 2px;
                            right: 4px;
                            font-size: 0.7rem;
                            opacity: 0.7;
                        ">🕒 5min buffer</div>
                    </div>
                `;
            }

            /**
             * Handle drag start for lessons
             */
            // Add enhanced drag visual feedback
            // Förbättrad drag start med auto-scroll setup
            // 3. Fix dragstart för spanning lessons
            // 1. HUVUDPROBLEMET: Förbättra handleLessonDragStartEnhanced



            // Uppdatera displayEditableScheduleWithAutoScroll för att ladda rumsbehörigheter
            const originalDisplayEditableScheduleWithAutoScroll = window.displayEditableScheduleWithAutoScroll;

            window.displayEditableScheduleWithAutoScroll = async function(scheduleData) {
                // Ladda lärarnas rumsbehörigheter först
                await loadTeacherRoomRestrictions(scheduleData);
                
                // Anropa den ursprungliga funktionen
                return originalDisplayEditableScheduleWithAutoScroll(scheduleData);
            };

            // Uppdatera även den vanliga displayEditableSchedule funktionen
            const originalDisplayEditableSchedule = window.displayEditableSchedule;

            window.displayEditableSchedule = async function(scheduleData) {
                // Ladda lärarnas rumsbehörigheter först
                await loadTeacherRoomRestrictions(scheduleData);
                
                // Anropa den ursprungliga funktionen
                return originalDisplayEditableSchedule(scheduleData);
            };

            function handleLessonDragStartEnhanced(event) {
                // Förhindra event bubbling
                event.stopPropagation();
                
                const lessonElement = event.target.closest('.draggable-lesson');
                if (!lessonElement) {
                    console.warn('Drag started on non-lesson element');
                    return;
                }
                
                // Hämta lärardata från DOM eller window.editModeLessons
                let teacherId = lessonElement.dataset.teacherId;
                let teacherName = lessonElement.dataset.teacherName;
                
                // Fallback: hämta från editModeLessons om data saknas i DOM
                if ((!teacherId || !teacherName) && window.editModeLessons) {
                    const lesson = window.editModeLessons[lessonElement.dataset.lessonId];
                    if (lesson) {
                        teacherId = teacherId || lesson.teacher_id || lesson.teacherId;
                        teacherName = teacherName || lesson.teacher_name || lesson.teacherName || lesson.teacher;
                    }
                }
                
                // Säkerställ att draggedLesson sätts FÖRST med korrekt lärardata
                draggedLesson = {
                    element: lessonElement,
                    lessonId: lessonElement.dataset.lessonId,
                    subject: lessonElement.dataset.subject,
                    room: lessonElement.dataset.room,
                    originalDay: lessonElement.dataset.originalDay,
                    originalTime: lessonElement.dataset.originalTime,
                    teacherId: teacherId || null,
                    teacherName: teacherName || null,
                    spanRows: parseInt(lessonElement.dataset.spanRows) || 1
                };
                
                debugLog('Drag start enhanced - draggedLesson set:', draggedLesson);
                
                // Sätt drag data för native drag-and-drop
                try {
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/plain', draggedLesson.lessonId);
                    event.dataTransfer.setData('application/json', JSON.stringify(draggedLesson));
                } catch (e) {
                    debugLog('DataTransfer error (IE compatibility):', e);
                }
                
                // Visuell feedback för dragged element
                lessonElement.style.opacity = '0.7';
                lessonElement.style.transform = 'rotate(2deg) scale(1.05)';
                lessonElement.style.zIndex = '1000';
                lessonElement.style.boxShadow = '0 8px 16px rgba(0,0,0,0.3)';
                
                // Hitta ursprungscellerna MEN rensa dem INTE än
                const originalDay = draggedLesson.originalDay;
                const [originalStart, originalEnd] = draggedLesson.originalTime.split('-');
                const originalStartMinutes = timeToMinutes(originalStart);
                const originalEndMinutes = timeToMinutes(originalEnd);
                
                const discreteTimeSlots = generateDiscreteTimeSlots('08:00', '18:00', 5);
                const occupiedCells = [];
                
                discreteTimeSlots.forEach(timeSlot => {
                    const slotMinutes = timeToMinutes(timeSlot);
                    if (slotMinutes >= originalStartMinutes && slotMinutes < originalEndMinutes) {
                        const cellId = `cell-${originalDay}-${timeSlot.replace(':', '-')}`;
                        const cell = document.getElementById(cellId);
                        if (cell) {
                            occupiedCells.push(cell);
                        }
                    }
                });



                
                draggedLesson.originalCells = occupiedCells;
                
                // Starta auto-scroll och markera celler EFTER en liten delay
                setTimeout(() => {
                    if (draggedLesson) {
                        markTeacherConflictCells();
                        startAutoScroll();
                    }
                }, 50);
                
                debugLog('Enhanced drag started successfully');
            }


            /**
             * Handle drag end
             */
            function handleLessonDragEnd(event) {
                event.target.style.opacity = '1';
                event.target.style.transform = 'scale(1)';
                
                // Remove visual feedback
                document.querySelectorAll('.drop-zone').forEach(cell => {
                    cell.classList.remove('drop-zone');
                    cell.style.background = '';
                });
            }



            // Update markTeacherConflictCells to handle original cell clearing properly
            // Update markTeacherConflictCells to handle original cell clearing properly
            // Update markTeacherConflictCells to handle original cell clearing properly
            // Ersätt markTeacherConflictCells funktionen med denna version
            // 6. FÖRBÄTTRA markTeacherConflictCells - anropa clearOriginalLessonCells BARA en gång
            function markTeacherConflictCells() {
                // Clear all previous markings first
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    cell.classList.remove('drop-zone', 'teacher-conflict-zone', 'room-conflict-zone');
                    cell.style.border = '';
                    cell.style.background = '';
                    cell.title = '';
                    // Remove old indicators
                    cell.querySelectorAll('.drag-conflict-indicator, .teacher-buffer-indicator').forEach(el => el.remove());
                });
                
                // Rensa ursprungscellerna BARA FÖRSTA GÅNGEN
                clearOriginalLessonCells();
                
                if (!draggedLesson) {
                    debugLog('No draggedLesson available for conflict marking');
                    return;
                }
                
                // Debug lärardata
                debugLog('Teacher data for conflict check:', {
                    teacherId: draggedLesson.teacherId,
                    teacherName: draggedLesson.teacherName
                });
                
                if (!draggedLesson.teacherId && !draggedLesson.teacherName) {
                    debugLog('No teacher data available, marking all empty cells as available');
                    // Fallback - mark all empty cells as available
                    document.querySelectorAll('.schedule-cell.empty').forEach(cell => {
                        cell.classList.add('drop-zone');
                        cell.style.border = '2px dashed #4299e1';
                        cell.style.background = 'rgba(66, 153, 225, 0.1)';
                    });
                    return;
                }
                
                // Get all lessons from DOM (excluding the one being dragged) with improved data extraction
                const allCurrentLessons = Array.from(document.querySelectorAll('.spanning-lesson'))
                    .filter(lessonEl => lessonEl.dataset.lessonId !== draggedLesson.lessonId && lessonEl.style.display !== 'none')
                    .map(lessonEl => {
                        const originalTime = lessonEl.dataset.originalTime;
                        if (!originalTime || !originalTime.includes('-')) return null;
                        
                        let teacherId = lessonEl.dataset.teacherId;
                        let teacherName = lessonEl.dataset.teacherName;
                        
                        // Fallback: hämta från editModeLessons
                        if ((!teacherId || !teacherName) && window.editModeLessons) {
                            const lesson = window.editModeLessons[lessonEl.dataset.lessonId];
                            if (lesson) {
                                teacherId = teacherId || lesson.teacher_id || lesson.teacherId;
                                teacherName = teacherName || lesson.teacher_name || lesson.teacherName || lesson.teacher;
                            }
                        }
                        
                        return {
                            id: lessonEl.dataset.lessonId,
                            day: lessonEl.dataset.originalDay,
                            time: originalTime,
                            teacherId: teacherId,
                            teacherName: teacherName,
                            room: lessonEl.dataset.room,
                            subject: lessonEl.dataset.subject
                        };
                    }).filter(Boolean);
                
                debugLog('Found lessons for conflict check:', allCurrentLessons.map(l => ({
                    subject: l.subject,
                    teacher: l.teacherName || l.teacherId,
                    time: l.time,
                    day: l.day
                })));
                
                // Mark all cells with conflict checking
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    const cellDay = cell.dataset.day;
                    const cellTime = cell.dataset.time;
                    
                    if (!cellDay || !cellTime) return;
                    
                    // Calculate time interval for the cell based on dragged lesson's length
                    const originalDuration = calculateLessonDuration(draggedLesson.originalTime);
                    const cellStartMinutes = timeToMinutes(cellTime);
                    const cellEndMinutes = cellStartMinutes + originalDuration;
                    const newTimeRange = `${cellTime}-${minutesToTime(cellEndMinutes)}`;
                    
                    // Check teacher conflict with 10 min buffer
                    const hasTeacherConflict = checkTeacherConflictForCell(
                        allCurrentLessons, cellDay, newTimeRange, draggedLesson.teacherId, draggedLesson.teacherName
                    );
                    
                    // Check room conflict
                    const hasRoomConflict = !isRoomAvailableForTimeSlot(draggedLesson.room, allCurrentLessons, cellDay, newTimeRange);
                    const availableRooms = getAvailableRoomsForTimeSlot(allCurrentLessons, cellDay, newTimeRange);
                    
                    // Set position relative for indicators
                    cell.style.position = 'relative';
                    
                    if (hasTeacherConflict) {
                        // RED marking for teacher conflicts
                        cell.classList.add('teacher-conflict-zone');
                        cell.style.border = '2px solid #f56565 !important';
                        cell.style.background = 'rgba(245, 101, 101, 0.3) !important';
                        cell.title = `⚠️ Läraren ${draggedLesson.teacherName || draggedLesson.teacherId || 'okänd'} har redan lektion här (10 min buffert krävs)`;
                        
                        // Add conflict icon
                        const conflictIcon = document.createElement('div');
                        conflictIcon.className = 'drag-conflict-indicator';
                        conflictIcon.innerHTML = '⚠️';
                        conflictIcon.style.cssText = `
                            position: absolute;
                            top: 2px;
                            right: 2px;
                            background: #f56565;
                            color: white;
                            border-radius: 50%;
                            width: 18px;
                            height: 18px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 12px;
                            z-index: 100;
                            pointer-events: none;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                        `;
                        cell.appendChild(conflictIcon);
                        
                    } else if (hasRoomConflict && availableRooms.length === 0) {
                        // RED marking for room conflict without alternatives
                        cell.classList.add('room-conflict-zone');
                        cell.style.border = '2px solid #f56565 !important';
                        cell.style.background = 'rgba(245, 101, 101, 0.2) !important';
                        cell.title = `🏫 Inga lediga rum tillgängliga för denna tid`;
                        
                        const roomIcon = document.createElement('div');
                        roomIcon.className = 'drag-conflict-indicator';
                        roomIcon.innerHTML = '🚫';
                        roomIcon.style.cssText = `
                            position: absolute;
                            top: 2px;
                            left: 2px;
                            background: #f56565;
                            color: white;
                            border-radius: 3px;
                            padding: 2px 4px;
                            font-size: 10px;
                            z-index: 100;
                            pointer-events: none;
                        `;
                        cell.appendChild(roomIcon);
                        
                    } else if (hasRoomConflict && availableRooms.length > 0) {
                        // ORANGE marking for room conflict with alternatives
                        cell.classList.add('room-conflict-zone');
                        cell.style.border = '2px dashed #ed8936 !important';
                        cell.style.background = 'rgba(237, 137, 54, 0.15) !important';
                        cell.title = `🏫 Originalsal upptagen, kommer att byta till: ${availableRooms[0]}`;
                        
                        const roomIcon = document.createElement('div');
                        roomIcon.className = 'drag-conflict-indicator';
                        roomIcon.innerHTML = '🔄';
                        roomIcon.style.cssText = `
                            position: absolute;
                            top: 2px;
                            left: 2px;
                            background: #ed8936;
                            color: white;
                            border-radius: 3px;
                            padding: 2px 4px;
                            font-size: 10px;
                            z-index: 100;
                            pointer-events: none;
                        `;
                        cell.appendChild(roomIcon);
                        
                    } else {
                        // GREEN/BLUE marking for available positions
                        cell.classList.add('drop-zone');
                        cell.style.border = '2px dashed #4299e1 !important';
                        cell.style.background = 'rgba(66, 153, 225, 0.1) !important';
                        cell.title = 'Tillgänglig - klicka för att flytta hit';
                    }
                });
            }

            /**
             * Handle drag over for drop zones
             */
            function handleDragOver(event) {
                event.preventDefault();
                event.currentTarget.style.background = 'rgba(72, 187, 120, 0.2)';
            }

            function calculateLessonDuration(timeRange) {
                if (!timeRange || typeof timeRange !== 'string' || !timeRange.includes('-')) {
                    console.warn('calculateLessonDuration received invalid timeRange:', timeRange);
                    return 60; // Default 60 minuter
                }
                const [startTime, endTime] = timeRange.split('-');
                return timeToMinutes(endTime) - timeToMinutes(startTime);
            }


            function getAvailableRoomsForTimeSlot(allLessons, targetDay, targetTimeRange) {
                const allRooms = getAvailableRooms(); // Hämta alla tillgängliga rum
                const [targetStart, targetEnd] = targetTimeRange.split('-');
                const targetStartMinutes = timeToMinutes(targetStart);
                const targetEndMinutes = timeToMinutes(targetEnd);
                
                const occupiedRooms = new Set();
                
                allLessons.forEach(lesson => {
                    if (lesson.day !== targetDay) return;
                    
                    const [lessonStart, lessonEnd] = lesson.time.split('-');
                    const lessonStartMinutes = timeToMinutes(lessonStart);
                    const lessonEndMinutes = timeToMinutes(lessonEnd);
                    
                    // Om lektionen överlappar med måltiden, markera rummet som upptaget
                    if (!(targetEndMinutes <= lessonStartMinutes || targetStartMinutes >= lessonEndMinutes)) {
                        occupiedRooms.add(lesson.room);
                    }
                });
                
                return allRooms.filter(room => !occupiedRooms.has(room));
            }

            /**
             * Kontrollera om ett specifikt rum är ledigt vid en viss tid
             */
            function isRoomAvailableForTimeSlot(room, allLessons, targetDay, targetTimeRange) {
                const availableRooms = getAvailableRoomsForTimeSlot(allLessons, targetDay, targetTimeRange);
                return availableRooms.includes(room);
}


            function checkTeacherConflictForCell(allLessons, targetDay, targetTimeRange, teacherId, teacherName) {
                if (!teacherId && !teacherName) {
                    debugLog('No teacher data available for conflict check');
                    return false;
                }
                
                const [targetStart, targetEnd] = targetTimeRange.split('-');
                const targetStartMinutes = timeToMinutes(targetStart);
                const targetEndMinutes = timeToMinutes(targetEnd);
                
                const TEACHER_BUFFER_MINUTES = 10; // Minst 10 minuter mellan lektioner
                
                return allLessons.some(lesson => {
                    if (lesson.day !== targetDay) return false;
                    
                    // Förbättrad lärarmatching - kontrollera både ID och namn
                    let sameTeacher = false;
                    
                    if (teacherId && lesson.teacherId) {
                        sameTeacher = lesson.teacherId === teacherId;
                    } else if (teacherName && lesson.teacherName) {
                        // Normalisera namn för jämförelse
                        const normalizedDraggedName = teacherName.toLowerCase().trim();
                        const normalizedLessonName = lesson.teacherName.toLowerCase().trim();
                        sameTeacher = normalizedDraggedName === normalizedLessonName;
                    }
                    
                    if (!sameTeacher) return false;
                    
                    // Kontrollera tidsöverlappning med buffert
                    const [lessonStart, lessonEnd] = lesson.time.split('-');
                    const lessonStartMinutes = timeToMinutes(lessonStart);
                    const lessonEndMinutes = timeToMinutes(lessonEnd);
                    
                    // Lägg till buffert: ny lektion får inte börja inom 10 min efter befintlig lektion slutar
                    // och befintlig lektion får inte börja inom 10 min efter ny lektion slutar
                    const bufferConflict = (targetStartMinutes < lessonEndMinutes + TEACHER_BUFFER_MINUTES && 
                                        targetEndMinutes + TEACHER_BUFFER_MINUTES > lessonStartMinutes);
                    
                    if (bufferConflict) {
                        debugLog('Teacher conflict detected:', {
                            teacher: teacherName || teacherId,
                            conflictLesson: lesson,
                            targetTime: targetTimeRange
                        });
                    }
                    
                    return bufferConflict;
                });
            }


            // Uppdaterad drop handler för diskreta tidsintervall
            async function handleLessonDropDiscrete(event) {
                event.preventDefault();
                event.currentTarget.style.background = '';
                
                if (!draggedLesson) return;
                
                const targetCell = event.currentTarget;
                const newDay = targetCell.dataset.day;
                const newTimeSlot = targetCell.dataset.time;
                const lessonElement = draggedLesson.element;
                
                // Räkna ut ny tid baserat på lektionens ursprungliga längd
                const originalTime = draggedLesson.element.dataset.originalTime;
                const [originalStart, originalEnd] = originalTime.split('-');
                const lessonDurationMinutes = timeToMinutes(originalEnd) - timeToMinutes(originalStart);
                
                const newStartMinutes = timeToMinutes(newTimeSlot);
                const newEndMinutes = newStartMinutes + lessonDurationMinutes;
                const newEndTime = minutesToTime(newEndMinutes);
                const newTimeRange = `${newTimeSlot}-${newEndTime}`;
                
                // Kontrollera om det är samma position
                if (newDay === draggedLesson.originalDay && newTimeSlot === timeToMinutes(draggedLesson.originalTime.split('-')[0])) {
                    debugLog('Dropped on same location, no action needed');
                    return;
                }
                
                // Kontrollera konflikter med ny tidsberäkning
                const conflictCheck = await checkMoveConflictsDiscrete(draggedLesson, newDay, newTimeRange);
                if (!conflictCheck.canMove) {
                    showConflictMessage(conflictCheck.reason);
                    return;
                }
                
                try {
                    // Flytta lektionen med ny start- och sluttid
                    const moveResult = await moveLesson(draggedLesson.lessonId, newDay, newTimeSlot, newEndTime);
                    if (moveResult.success) {
                        showSuccessToast(`Lektion flyttad till ${newDay} ${newTimeRange}`);
                        
                        // Ladda om schemat för att visa uppdateringen
                        reloadEditSchedule();
                        
                        debugLog('Lesson moved successfully with discrete time slots', moveResult);
                    } else {
                        throw new Error(moveResult.error || 'Kunde inte flytta lektion');
                    }
                } catch (error) {
                    console.error('Error moving lesson:', error);
                    showConflictMessage(`Fel vid flyttning: ${error.message}`);
                }
                
                draggedLesson = null;
            }

            // Uppdaterad konflikt-kontroll för diskreta tidsintervall
            function checkMoveConflictsDiscrete(lesson, newDay, newTimeRange) {
                const [newStartTime, newEndTime] = newTimeRange.split('-');
                const newStartMinutes = timeToMinutes(newStartTime);
                const newEndMinutes = timeToMinutes(newEndTime);
                
                const ROOM_BUFFER_MINUTES = 5;
                
                // Hämta alla nuvarande lektioner från schemat
                const currentLessons = Array.from(document.querySelectorAll('.spanning-lesson')).map(lessonEl => {
                    const originalTime = lessonEl.dataset.originalTime;
                    if (!originalTime || !originalTime.includes('-')) return null;
                    
                    const [startTime, endTime] = originalTime.split('-');
                    const lessonDay = lessonEl.dataset.originalDay;
                    
                    return {
                        id: lessonEl.dataset.lessonId,
                        day: lessonDay,
                        time: originalTime,
                        startMinutes: timeToMinutes(startTime),
                        endMinutes: timeToMinutes(endTime),
                        subject: lessonEl.dataset.subject,
                        room: lessonEl.dataset.room
                    };
                }).filter(Boolean);

                // Kontrollera klassrums-konflikter med 5-minuters buffer
                const roomConflicts = currentLessons.filter(l => 
                    l.day === newDay && 
                    l.id !== lesson.lessonId &&
                    l.room === lesson.room &&
                    (newStartMinutes < l.endMinutes + ROOM_BUFFER_MINUTES && 
                    newEndMinutes + ROOM_BUFFER_MINUTES > l.startMinutes)
                );

                if (roomConflicts.length > 0) {
                    const conflictDetails = roomConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Klassrumskonflikt med ${ROOM_BUFFER_MINUTES}-min buffer: ${conflictDetails}` 
                    };
                }

                // Kontrollera vanliga tidskonflikter
                const timeConflicts = currentLessons.filter(l => 
                    l.day === newDay && 
                    l.id !== lesson.lessonId &&
                    l.room !== lesson.room &&
                    newStartMinutes < l.endMinutes && newEndMinutes > l.startMinutes
                );

                if (timeConflicts.length > 0) {
                    const conflictDetails = timeConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Tidskonflikt: ${conflictDetails}` 
                    };
                }

                return { canMove: true };
            }

            /**
             * Handle lesson drop with conflict checking
             */
            // 1. Ersätt handleLessonDrop funktionen med korrekt implementation
            // 5. Fix handleLessonDrop för att kontrollera draggedLesson ordentligt
            // Uppdatera handleLessonDrop för att hantera den dolda lektionen
            // Uppdatera handleLessonDrop för att vara enklare
            // 7. FÖRBÄTTRA handleLessonDrop för att hantera dataTransfer korrekt
            async function handleLessonDrop(event) {
                event.preventDefault();
                event.stopPropagation();
                
                const targetCell = event.currentTarget;
                targetCell.style.background = '';
                targetCell.classList.remove('drop-zone', 'teacher-conflict-zone', 'room-conflict-zone');
                
                // Ta bort alla konfliktindikatorer
                document.querySelectorAll('.drag-conflict-indicator').forEach(el => el.remove());
                
                // Hämta draggedLesson från dataTransfer om det inte finns
                if (!draggedLesson) {
                    try {
                        const lessonData = event.dataTransfer.getData('application/json');
                        if (lessonData) {
                            draggedLesson = JSON.parse(lessonData);
                            debugLog('Restored draggedLesson from dataTransfer:', draggedLesson);
                        }
                    } catch (e) {
                        debugLog('Could not restore draggedLesson from dataTransfer:', e);
                    }
                }
                
                if (!draggedLesson) {
                    debugLog('handleLessonDrop: No valid draggedLesson found');
                    return;
                }
                
                const newDay = targetCell.dataset.day;
                const newTimeSlot = targetCell.dataset.time;
                
                if (!newDay || !newTimeSlot) {
                    debugLog('handleLessonDrop: Target cell missing day or time data');
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                    return;
                }
                
                // Spara draggedLesson i lokal variabel
                const currentDraggedLesson = { ...draggedLesson };
                
                // Kontrollera om det är samma position
                const originalStartTime = currentDraggedLesson.originalTime ? currentDraggedLesson.originalTime.split('-')[0] : '';
                if (newDay === currentDraggedLesson.originalDay && newTimeSlot === originalStartTime) {
                    debugLog('Dropped on exact same location, restoring');
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                    return;
                }
                
                // Förhindra drop på lärarkonfliktzoner
                if (targetCell.classList.contains('teacher-conflict-zone')) {
                    showConflictMessage('⚠️ Läraren har redan en lektion vid denna tid. Välj en annan tid.');
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                    return;
                }
                
                // Beräkna ny tid och kontrollera rumstillgänglighet
                const originalDuration = calculateLessonDuration(currentDraggedLesson.originalTime);
                const newStartMinutes = timeToMinutes(newTimeSlot);
                const newEndMinutes = newStartMinutes + originalDuration;
                const newEndTime = minutesToTime(newEndMinutes);
                const newTimeRange = `${newTimeSlot}-${newEndTime}`;
                
                // Hämta alla andra lektioner för rumskontroll
                const allCurrentLessons = Array.from(document.querySelectorAll('.spanning-lesson'))
                    .filter(el => el.dataset.lessonId !== currentDraggedLesson.lessonId && el.style.display !== 'none')
                    .map(el => ({
                        day: el.dataset.originalDay,
                        time: el.dataset.originalTime,
                        room: el.dataset.room
                    }))
                    .filter(lesson => lesson.time && lesson.day);
                
                // Bestäm vilket rum som ska användas
                let finalRoom = currentDraggedLesson.room || 'Inget rum';
                
                if (!isRoomAvailableForTimeSlot(currentDraggedLesson.room, allCurrentLessons, newDay, newTimeRange)) {
                    const availableRooms = getAvailableRoomsForTimeSlot(allCurrentLessons, newDay, newTimeRange);
                    
                    if (availableRooms.length === 0) {
                        showConflictMessage('🏫 Inga lediga rum tillgängliga för denna tid. Välj en annan tid.');
                        restoreLessonToOriginalPosition();
                        cleanupDragState();
                        return;
                    }
                    
                    finalRoom = availableRooms[0];
                    debugLog(`Room switched from ${currentDraggedLesson.room} to ${finalRoom} due to conflict`);
                }
                
                try {
                    // Flytta lektionen med eventuell salsbyte
                    const moveResult = await moveLessonWithRoomChange(
                        currentDraggedLesson.lessonId, 
                        newDay, 
                        newTimeSlot, 
                        newEndTime, 
                        finalRoom
                    );
                    
                    if (moveResult.success) {
                        if (finalRoom !== currentDraggedLesson.room) {
                            showSuccessToast(`✅ Lektion flyttad till ${newDay} ${newTimeRange} (sal ändrad till ${finalRoom})`);
                        } else {
                            showSuccessToast(`✅ Lektion flyttad till ${newDay} ${newTimeRange}`);
                        }
                        
                        // Cleanup omedelbart efter framgångsrik flytt
                        cleanupDragState();
                        
                        // Ladda om schemat efter kort delay
                        setTimeout(() => {
                            reloadEditSchedule();
                        }, 500);
                        
                        debugLog('Lesson moved successfully with potential room change', moveResult);
                    } else {
                        throw new Error(moveResult.error || 'Kunde inte flytta lektion');
                    }
                } catch (error) {
                    console.error('Error moving lesson:', error);
                    showConflictMessage(`❌ Fel vid flyttning: ${error.message}`);
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                }
            }



            /**
             * Check for conflicts when moving a lesson
             */
            // 2. Förenkla conflict checking - ta bort API-anrop som inte finns
            // Uppdatera checkMoveConflicts funktionen

            function timeToMinutes(timeStr) {
                if (!timeStr || typeof timeStr !== 'string') {
                    console.warn('timeToMinutes received invalid input:', timeStr);
                    return 0;
                }
                const parts = timeStr.split(':');
                if (parts.length < 2) {
                    console.warn('timeToMinutes received invalid time format:', timeStr);
                    return 0;
                }
                const [hours, minutes] = parts.map(Number);
                return (hours || 0) * 60 + (minutes || 0);
            }

            // Förbättrad checkMoveConflicts med 5-minuters buffer för klassrum
            // 2. Fix checkMoveConflicts för att hantera saknade tidsdata
            function checkMoveConflicts(lesson, newDay, newTime) {
                if (!newTime || typeof newTime !== 'string' || !newTime.includes('-')) {
                    console.warn('checkMoveConflicts received invalid newTime:', newTime);
                    return { canMove: false, reason: 'Ogiltig tid angiven' };
                }
                
                const [newStartTime, newEndTime] = newTime.split('-');
                const newStartMinutes = timeToMinutes(newStartTime);
                const newEndMinutes = timeToMinutes(newEndTime);
                
                const ROOM_BUFFER_MINUTES = 5;
                const TEACHER_BUFFER_MINUTES = 10;
                
                const currentLessons = Array.from(document.querySelectorAll('.spanning-lesson')).map(lessonEl => {
                    const originalTime = lessonEl.dataset.originalTime;
                    if (!originalTime || !originalTime.includes('-')) return null;
                    
                    const [startTime, endTime] = originalTime.split('-');
                    const lessonDay = lessonEl.dataset.originalDay;
                    
                    return {
                        id: lessonEl.dataset.lessonId,
                        day: lessonDay,
                        time: originalTime,
                        startMinutes: timeToMinutes(startTime),
                        endMinutes: timeToMinutes(endTime),
                        subject: lessonEl.dataset.subject,
                        room: lessonEl.dataset.room,
                        teacherId: lessonEl.dataset.teacherId,
                        teacherName: lessonEl.dataset.teacherName
                    };
                }).filter(Boolean);

                // Kontrollera lärarkonflikter med 10-minuters buffert
                const teacherConflicts = currentLessons.filter(l => {
                    if (l.day !== newDay || l.id === lesson.lessonId) return false;
                    
                    // Matcha lärare
                    const sameTeacher = (lesson.teacherId && l.teacherId === lesson.teacherId) || 
                                    (lesson.teacherName && l.teacherName === lesson.teacherName);
                    
                    if (!sameTeacher) return false;
                    
                    // Kontrollera buffertkonflikt
                    return (newStartMinutes < l.endMinutes + TEACHER_BUFFER_MINUTES && 
                            newEndMinutes + TEACHER_BUFFER_MINUTES > l.startMinutes);
                });

                if (teacherConflicts.length > 0) {
                    const conflictDetails = teacherConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Lärarkonflikt (${TEACHER_BUFFER_MINUTES} min buffert krävs): ${conflictDetails}` 
                    };
                }

                // Kontrollera klassrums-konflikter med 5-minuters buffert
                const roomConflicts = currentLessons.filter(l => 
                    l.day === newDay && 
                    l.id !== lesson.lessonId &&
                    l.room === lesson.room &&
                    (newStartMinutes < l.endMinutes + ROOM_BUFFER_MINUTES && 
                    newEndMinutes + ROOM_BUFFER_MINUTES > l.startMinutes)
                );

                if (roomConflicts.length > 0) {
                    const conflictDetails = roomConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Klassrumskonflikt med ${ROOM_BUFFER_MINUTES}-min buffert: ${conflictDetails}` 
                    };
                }

                return { canMove: true };
            }


            async function moveLessonWithRoomChange(lessonId, newDay, newStartTime, newEndTime, newRoom) {
                try {
                    debugLog('Moving lesson with room change', {
                        lessonId, newDay, newStartTime, newEndTime, newRoom
                    });
                    
                    const response = await fetch(`/api/schedule/move_lesson/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            weekday: newDay,
                            start_time: newStartTime,
                            end_time: newEndTime,
                            room: newRoom // Inkludera rum i API-anropet
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte flytta lektion');
                    }

                    return result;

                } catch (error) {
                    console.error('Error in moveLessonWithRoomChange:', error);
                    throw error;
                }
            }


            // Uppdatera moveLesson för att hantera både start och end tid
            async function moveLessonWithEndTime(lessonId, newDay, newStartTime, newEndTime) {
                try {
                    const response = await fetch(`/api/schedule/move_lesson/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            weekday: newDay,
                            start_time: newStartTime,
                            end_time: newEndTime
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte flytta lektion');
                    }

                    return result;

                } catch (error) {
                    console.error('Error moving lesson:', error);
                    throw error;
                }
            }



            /**
             * Move lesson in database
             */
            // Uppdatera moveLesson funktionen för att använda riktig API
            // 2. Uppdatera moveLesson för att acceptera både start och end tid
            async function moveLesson(lessonId, newDay, newStartTime, newEndTime = null) {
                try {
                    // Om ingen sluttid angiven, räkna ut från starttid (60 min default)
                    if (!newEndTime) {
                        const startMinutes = timeToMinutes(newStartTime);
                        const endMinutes = startMinutes + 60; // Default 60 minuter
                        newEndTime = minutesToTime(endMinutes);
                    }
                    
                    debugLog('Moving lesson via API', {
                        lessonId,
                        newDay,
                        newStartTime,
                        newEndTime
                    });
                    
                    const response = await fetch(`/api/schedule/move_lesson/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            weekday: newDay,
                            start_time: newStartTime,
                            end_time: newEndTime
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte flytta lektion');
                    }

                    return result;

                } catch (error) {
                    console.error('Error in moveLesson:', error);
                    throw error;
                }
            }

            /**
             * Perform UI update after successful lesson move
             */
            function performLessonMove(lessonElement, targetCell, newDay, newTime) {
                // Remove from original location
                const originalCell = lessonElement.parentElement;
                originalCell.classList.remove('occupied');
                originalCell.classList.add('empty');
                
                // Add to new location
                targetCell.appendChild(lessonElement);
                targetCell.classList.add('occupied');
                targetCell.classList.remove('empty');
                
                // Update lesson data attributes
                lessonElement.dataset.originalDay = newDay;
                lessonElement.dataset.originalTime = newTime;
            }

            /**
             * Check and highlight schedule conflicts
             */
            // Enhanced conflict checking with real-time validation
            // 5. Förenkla konflikt-checking
            async function checkScheduleConflicts() {
                if (!isEditMode) return;
                
                // Clear existing conflict indicators
                document.querySelectorAll('.conflict-indicator').forEach(el => el.remove());
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    cell.classList.remove('has-conflict');
                    cell.style.background = '';
                });
                
                // Get all current lessons from the UI
                const currentLessons = Array.from(document.querySelectorAll('.draggable-lesson')).map(lessonEl => {
                    const cell = lessonEl.closest('.schedule-cell');
                    return {
                        id: lessonEl.dataset.lessonId,
                        day: cell.dataset.day,
                        time: cell.dataset.time,
                        subject: lessonEl.dataset.subject,
                        room: lessonEl.dataset.room
                    };
                });
                
                // Simple client-side conflict detection
                const roomConflicts = new Map();
                const timeConflicts = new Map();
                
                currentLessons.forEach(lesson => {
                    const timeKey = `${lesson.day}-${lesson.time}`;
                    const roomKey = `${lesson.room}-${timeKey}`;
                    
                    // Check for time conflicts (multiple lessons same time)
                    if (!timeConflicts.has(timeKey)) {
                        timeConflicts.set(timeKey, []);
                    }
                    timeConflicts.get(timeKey).push(lesson);
                    
                    // Check for room conflicts
                    if (!roomConflicts.has(roomKey)) {
                        roomConflicts.set(roomKey, []);
                    }
                    roomConflicts.get(roomKey).push(lesson);
                });
                
                // Mark conflicts
                roomConflicts.forEach((lessons, roomKey) => {
                    if (lessons.length > 1) {
                        lessons.forEach(lesson => {
                            const cell = document.getElementById(`cell-${lesson.day}-${lesson.time.replace(':', '-')}`);
                            if (cell) {
                                cell.classList.add('has-conflict');
                                
                                const indicator = document.createElement('div');
                                indicator.className = 'conflict-indicator';
                                indicator.style.cssText = `
                                    position: absolute;
                                    top: 2px;
                                    left: 2px;
                                    background: #f56565;
                                    color: white;
                                    font-size: 10px;
                                    padding: 2px 4px;
                                    border-radius: 2px;
                                    z-index: 100;
                                `;
                                indicator.textContent = '⚠️';
                                indicator.title = `Konflikt: Flera lektioner använder samma rum (${lesson.room})`;
                                
                                cell.style.position = 'relative';
                                cell.appendChild(indicator);
                            }
                        });
                    }
                });
                
                debugLog('Client-side conflict check completed');
            }


            /**
             * Show conflict message to user
             */
            function showConflictMessage(message) {
                // Create temporary notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #f56565, #e53e3e);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 0.5rem;
                    box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
                    z-index: 10000;
                    font-weight: 500;
                    animation: slideIn 0.3s ease-out;
                `;
                notification.innerHTML = `⚠️ ${message}`;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            /**
             * Show success toast message
             */
            function showSuccessToast(message) {
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #48bb78, #38a169);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 0.5rem;
                    box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);
                    z-index: 10000;
                    font-weight: 500;
                    animation: slideIn 0.3s ease-out;
                `;
                toast.innerHTML = `✅ ${message}`;
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            }

            /**
             * Update edit controls in generation panel
             */
            function updateEditControls() {
                const controls = document.getElementById('generationControls');
                if (!controls) return;
                
                // Replace normal controls with edit controls
                controls.innerHTML = `
                    <div class="edit-controls-header" style="margin-bottom: 1rem; padding: 1rem; background: #fef5e7; border-radius: 0.5rem; border-left: 4px solid #ed8936;">
                        <h4 style="margin: 0 0 0.5rem 0; color: #744210;">✏️ Redigeringsläge aktiv</h4>
                        <p style="margin: 0; color: #744210; font-size: 0.9rem;">
                            Dra och släpp lektioner för att flytta dem. Alla ändringar sparas automatiskt.
                        </p>
                    </div>
                    
                    <div class="schedule-actions" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button type="button" class="btn" onclick="saveEditedSchedule()" style="background: #48bb78;">
                            💾 Spara ändringar
                        </button>
                        <button type="button" class="btn" onclick="discardScheduleChanges()" style="background: #f56565;">
                            ❌ Avbryt redigering
                        </button>
                        <button type="button" class="btn" onclick="reloadEditSchedule()" style="background: #4299e1;">
                            🔄 Ladda om schema
                        </button>
                    </div>
                    
                    <div class="edit-info" style="margin-top: 1rem; padding: 0.75rem; background: #ebf8ff; border-radius: 0.375rem; font-size: 0.85rem; color: #2a4365;">
                        <strong>💡 Tips för redigering:</strong>
                        <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
                            <li>Dra lektioner till nya tider - systemet kollar automatiskt efter konflikter</li>
                            <li>Röda celler indikerar konflikter som måste lösas</li>
                            <li>Lärare och klassrum kan inte dubbelbokas</li>
                        </ul>
                    </div>
                `;
            }

            function handleDragLeave(event) {
                const cell = event.currentTarget;
                if (cell.classList.contains('drop-zone')) {
                    cell.style.background = 'rgba(66, 153, 225, 0.1)';
                    cell.style.borderColor = '#4299e1';
                }
                cell.title = '';
            }


            // 8. LÄGG TILL CSS-FIX för att förhindra text-selection under drag
            const dragFixStyles = `
            .editable-schedule-table {
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }

            .draggable-lesson {
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                cursor: grab;
            }

            .draggable-lesson:active {
                cursor: grabbing !important;
            }

            .draggable-lesson.dragging {
                opacity: 0.7 !important;
                transform: rotate(2deg) scale(1.05) !important;
                z-index: 1000 !important;
                box-shadow: 0 8px 16px rgba(0,0,0,0.3) !important;
                pointer-events: none;
            }

            .schedule-cell {
                position: relative;
            }

            /* Förhindra hover-effekter under drag */
            body.dragging .draggable-lesson:not(.dragging):hover {
                transform: none !important;
                box-shadow: 0 2px 4px rgba(0,0,0,0.15) !important;
            }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('drag-fix-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'drag-fix-styles';
                styleElement.textContent = dragFixStyles;
                document.head.appendChild(styleElement);
            }

            // Förbättrade drag handlers
            // 3. Fix handleDragEnter för att hantera null draggedLesson
            function handleDragEnter(event) {
                event.preventDefault();
                if (!draggedLesson) {
                    console.warn('handleDragEnter called without draggedLesson');
                    return;
                }
                
                const cell = event.currentTarget;
                const day = cell.dataset.day;
                const time = cell.dataset.time;
                
                if (!day || !time) {
                    console.warn('handleDragEnter: cell missing day or time data');
                    return;
                }
                
                // Beräkna ny tidsintervall baserat på lektionens längd
                const originalDuration = calculateLessonDuration(draggedLesson.originalTime);
                const newStartMinutes = timeToMinutes(time);
                const newEndMinutes = newStartMinutes + originalDuration;
                const newTimeRange = `${time}-${minutesToTime(newEndMinutes)}`;
                
                // Quick conflict check för visuell feedback
                const conflictCheck = checkMoveConflicts(draggedLesson, day, newTimeRange);
                
                if (conflictCheck.canMove) {
                    cell.style.background = 'rgba(72, 187, 120, 0.2)';
                    cell.style.borderColor = '#48bb78';
                    cell.title = 'Drop här för att flytta lektionen';
                } else {
                    cell.style.background = 'rgba(245, 101, 101, 0.2)';
                    cell.style.borderColor = '#f56565';
                    cell.title = conflictCheck.reason;
                }
            }


            // Enhanced initialization for edit mode
            document.addEventListener('DOMContentLoaded', function() {
                // Add global error handler for drag operations
                window.addEventListener('error', function(e) {
                    if (isEditMode && e.message.includes('drag')) {
                        console.error('Drag operation error:', e);
                        showConflictMessage('Fel vid drag-and-drop operation. Ladda om sidan om problemet kvarstår.');
                    }
                });
                
                // Add visibility change handler to prevent data loss
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden && isEditMode && draggedLesson) {
                        // User switched tabs while dragging - reset drag state
                        draggedLesson = null;
                        document.querySelectorAll('.draggable-lesson').forEach(el => {
                            el.style.opacity = '1';
                            el.style.transform = 'scale(1)';
                        });
                        document.querySelectorAll('.drop-zone').forEach(el => {
                            el.classList.remove('drop-zone');
                            el.style.background = '';
                            el.style.border = '';
                        });
                    }
                });
            });


            // Add keyboard shortcuts for edit mode
            document.addEventListener('keydown', function(e) {
                if (!isEditMode) return;
                
                // Escape to exit edit mode
                if (e.key === 'Escape') {
                    e.preventDefault();
                    discardScheduleChanges();
                }
                
                // Ctrl+S to save in edit mode
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    saveEditedSchedule();
                }
                
                // Ctrl+Z for undo (reload from database)
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    reloadEditSchedule();
                }
            });

            /**
             * Save edited schedule changes
             */
            // Enhanced save function for edited schedules
            // 6. Förenkla save-funktionen för editerat schema
            // Uppdatera saveEditedSchedule för att använda rätt API
            async function saveEditedSchedule() {
                if (!confirm('Spara alla ändringar i schemat?')) {
                    return;
                }
                
                const saveButton = event.target;
                const originalText = saveButton.textContent;
                saveButton.disabled = true;
                saveButton.textContent = '💾 Sparar...';
                
                try {
                    // För redigeringsläge, spara direkt via database-uppdatering
                    // Ändringarna har redan gjorts via moveLesson API-anrop
                    
                    showSuccessToast('✅ Alla ändringar sparade i databasen!');
                    debugLog('Schedule changes saved successfully');
                    
                    // Exit edit mode och visa uppdaterat schema
                    setTimeout(() => {
                        exitEditMode();
                        // Ladda om schemat från databasen för att visa uppdateringarna
                        if (editingClassId) {
                            editClassSchedule(editingClassId, editingClassName);
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('Error saving edited schedule:', error);
                    showConflictMessage(`Fel vid sparning: ${error.message}`);
                } finally {
                    saveButton.disabled = false;
                    saveButton.textContent = originalText;
                }
            }

            /**
             * Discard changes and exit edit mode
             */
            function discardScheduleChanges() {
                if (!confirm('Avbryt redigeringen och förlora alla ändringar?')) {
                    return;
                }
                
                exitEditMode();
                showSuccessToast('Redigering avbruten - inga ändringar sparade');
            }

            /**
             * Reload schedule from database
             */
            async function reloadEditSchedule() {
                if (!confirm('Ladda om schemat från databasen? Alla osparade ändringar går förlorade.')) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/class_schedule/status/${editingClassId}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        originalScheduleData = result;
                        displayEditableSchedule(result);
                        showSuccessToast('Schema laddat om från databasen');
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error reloading schedule:', error);
                    showConflictMessage(`Fel vid laddning: ${error.message}`);
                }
            }

            // Add CSS animations for notifications
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes slideOut {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
                
                .draggable-lesson:hover {
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
                }
                
                .schedule-cell.drop-zone {
                    border: 2px dashed #4299e1 !important;
                }
                
                .schedule-cell.has-conflict {
                    background: rgba(245, 101, 101, 0.1) !important;
                    border-color: #f56565 !important;
                }
            `;
            document.head.appendChild(style);

            // Ersätt saveMultiClassSchedule funktionen med denna fixade version
            // Ersätt saveMultiClassSchedule funktionen med denna fixade version
            // Ersätt saveMultiClassSchedule funktionen med denna fixade version
            // Ersätt hela saveMultiClassSchedule funktionen med denna fixade version
            // Ersätt hela saveMultiClassSchedule funktionen med denna fixade version
            async function saveMultiClassSchedule() {
                if (!currentSchedule || !currentSchedule.lessons) {
                    alert('Inget schema att spara');
                    return;
                }
                
                // CRITICAL: Comprehensive validation before save
                const conflicts = validateScheduleBeforeSave(currentSchedule.lessons);
                
                // Check for any conflicts
                const hasConflicts = conflicts.timeOverlaps.length > 0 || 
                                    conflicts.roomConflicts.length > 0 || 
                                    conflicts.teacherConflicts.length > 0;
                
                if (hasConflicts) {
                    let errorMessage = '❌ Schema kan inte sparas på grund av konflikter:\n\n';
                    
                    if (conflicts.timeOverlaps.length > 0) {
                        errorMessage += '🕐 TIDSÖVERLAPPNINGAR:\n';
                        conflicts.timeOverlaps.forEach(conflict => {
                            errorMessage += `• ${conflict.class_name} (${conflict.day}): ${conflict.lesson1} ↔ ${conflict.lesson2}\n`;
                        });
                        errorMessage += '\n';
                    }
                    
                    if (conflicts.roomConflicts.length > 0) {
                        errorMessage += '🏫 RUMKONFLIKTER:\n';
                        conflicts.roomConflicts.forEach(conflict => {
                            errorMessage += `• ${conflict.room} (${conflict.time}): ${conflict.classes.join(' & ')}\n`;
                        });
                        errorMessage += '\n';
                    }
                    
                    if (conflicts.teacherConflicts.length > 0) {
                        errorMessage += '👨‍🏫 LÄRARKONFLIKTER:\n';
                        conflicts.teacherConflicts.forEach(conflict => {
                            errorMessage += `• ${conflict.teacher} (${conflict.time}): ${conflict.classes.join(' & ')}\n`;
                        });
                        errorMessage += '\n';
                    }
                    
                    errorMessage += 'Generera ett nytt schema för att lösa konflikterna.';
                    
                    debugLog('Save blocked due to schedule conflicts:', conflicts);
                    alert(errorMessage);
                    return;
                }
                
                try {
                    const classIds = selectedClasses.map(c => parseInt(c.id));
                    
                    // FIX: Säkerställ att alla lessons har rätt fält för backend
                    const processedLessons = currentSchedule.lessons.map(lesson => {
                        return {
                            day: lesson.day,
                            time: lesson.time,
                            class_id: parseInt(lesson.class_id),
                            class_name: lesson.class_name,
                            // FIX: Skicka både subject_id och school_subject_id för bakåtkompatibilitet
                            subject_id: lesson.school_subject_id || lesson.subject_id,
                            school_subject_id: lesson.school_subject_id || lesson.subject_id,
                            subject_name: lesson.subject_name,
                            room: lesson.room || 'Inget rum',
                            teacher_id: lesson.teacher_id,
                            teacher_name: lesson.teacher_name || 'Okänd lärare'
                        };
                    });
                    
                    const payloadData = {
                        class_ids: classIds,
                        schedule: {
                            lessons: processedLessons
                        }
                    };
                    
                    debugLog('Saving validated conflict-free schedule:', { 
                        classes: classIds.length, 
                        lessons: processedLessons.length,
                        validation: 'PASSED',
                        sampleLesson: processedLessons[0],
                        payload: payloadData
                    });
                    
                    const response = await fetch('/api/multi_class_schedule/save', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payloadData)
                    });
                    
                    let result;
                    try {
                        result = await response.json();
                    } catch (jsonError) {
                        debugLog('Failed to parse JSON response:', {
                            status: response.status,
                            statusText: response.statusText
                        });
                        throw new Error(`Server returned invalid JSON (${response.status}): ${response.statusText}`);
                    }
                    
                    debugLog('Server response:', {
                        status: response.status,
                        ok: response.ok,
                        result: result
                    });
                    
                    if (response.ok && result.success) {
                        alert(`✅ Schema sparat utan konflikter!\n\n${result.details.map(d => `${d.class_name}: ${d.lessons_saved} lektioner`).join('\n')}`);
                        
                        scheduleSaveState.hasUnsavedChanges = false;
                        scheduleSaveState.lastSavedSchedule = JSON.parse(JSON.stringify(currentSchedule));
                        updateScheduleUI();
                        updateClassScheduleStatus();
                    } else {
                        // Hantera olika typer av fel från servern
                        const errorMsg = result.error || result.message || 'Multi-class save failed';
                        debugLog('Multi-class save failed:', result);
                        throw new Error(errorMsg);
                    }
                    
                } catch (error) {
                    debugLog('Primary save method failed:', error.message);
                    
                    // FALLBACK: Försök direkt med multi_class_schedule/save_individual endpoint först
                    debugLog('Trying alternative multi-class endpoint...');
                    
                    const processedLessons = currentSchedule.lessons.map(lesson => {
                        return {
                            day: lesson.day,
                            time: lesson.time,
                            class_id: parseInt(lesson.class_id),
                            class_name: lesson.class_name,
                            subject_id: lesson.school_subject_id || lesson.subject_id,
                            school_subject_id: lesson.school_subject_id || lesson.subject_id,
                            subject_name: lesson.subject_name,
                            room: lesson.room || 'Inget rum',
                            teacher_id: lesson.teacher_id,
                            teacher_name: lesson.teacher_name || 'Okänd lärare'
                        };
                    });
                    
                    try {
                        // Försök med alternativ endpoint för multi-class individuell sparning
                        const alternativeResponse = await fetch('/api/multi_class_schedule/save_individual', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                class_ids: selectedClasses.map(c => parseInt(c.id)),
                                lessons: processedLessons
                            })
                        });
                        
                        if (alternativeResponse.ok) {
                            const altResult = await alternativeResponse.json();
                            if (altResult.success) {
                                alert(`✅ Schema sparat!\n\n${altResult.details ? altResult.details.map(d => `${d.class_name}: ${d.lessons_saved} lektioner`).join('\n') : `${processedLessons.length} lektioner sparade`}`);
                                
                                scheduleSaveState.hasUnsavedChanges = false;
                                scheduleSaveState.lastSavedSchedule = JSON.parse(JSON.stringify(currentSchedule));
                                updateScheduleUI();
                                updateClassScheduleStatus();
                                return;
                            }
                        }
                    } catch (altError) {
                        debugLog('Alternative endpoint also failed:', altError.message);
                    }
                    
                    // SISTA UTVÄG: Försök med den ursprungliga klass-för-klass metoden
                    debugLog('Trying final fallback: individual class saves...');
                    
                    try {
                        const saveResults = [];
                        let totalSaved = 0;
                        
                        for (const cls of selectedClasses) {
                            const classLessons = processedLessons.filter(lesson => 
                                parseInt(lesson.class_id) === parseInt(cls.id)
                            );
                            
                            if (classLessons.length === 0) continue;
                            
                            debugLog(`Attempting individual save for class ${cls.name}:`, {
                                classId: cls.id,
                                lessons: classLessons.length
                            });
                            
                            // Prova olika endpoints för klassparning
                            const endpoints = [
                                `/api/schedule/save/${cls.id}`,
                                `/api/class/${cls.id}/schedule/save`,
                                `/api/schedules/class/${cls.id}/save`
                            ];
                            
                            let classSaved = false;
                            
                            for (const endpoint of endpoints) {
                                try {
                                    const classResponse = await fetch(endpoint, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                            class_id: parseInt(cls.id),
                                            lessons: classLessons
                                        })
                                    });
                                    
                                    if (classResponse.ok) {
                                        const classResult = await classResponse.json();
                                        
                                        if (classResult.success) {
                                            saveResults.push(`${cls.name}: ${classResult.lessons_saved || classLessons.length} lektioner`);
                                            totalSaved += classResult.lessons_saved || classLessons.length;
                                            debugLog(`✓ Successfully saved class ${cls.name} via ${endpoint}`);
                                            classSaved = true;
                                            break;
                                        }
                                    }
                                } catch (endpointError) {
                                    debugLog(`Failed ${endpoint}:`, endpointError.message);
                                    continue;
                                }
                            }
                            
                            if (!classSaved) {
                                debugLog(`✗ Failed to save class ${cls.name} via all endpoints`);
                                throw new Error(`Kunde inte spara schema för ${cls.name} - inga fungerande API-endpoints`);
                            }
                        }
                        
                        if (totalSaved > 0) {
                            alert(`✅ Schema sparat med individuell metod!\n\n${saveResults.join('\n')}\n\nTotalt: ${totalSaved} lektioner`);
                            
                            scheduleSaveState.hasUnsavedChanges = false;
                            scheduleSaveState.lastSavedSchedule = JSON.parse(JSON.stringify(currentSchedule));
                            updateScheduleUI();
                            updateClassScheduleStatus();
                        } else {
                            throw new Error('Inga lektioner kunde sparas via någon metod');
                        }
                        
                    } catch (fallbackError) {
                        console.error('All save methods failed:', {
                            primaryError: error.message,
                            fallbackError: fallbackError.message
                        });
                        debugLog('All save methods failed:', {
                            primaryError: error.message,
                            fallbackError: fallbackError.message,
                            currentSchedule: currentSchedule,
                            selectedClasses: selectedClasses,
                            processedLessons: processedLessons.slice(0, 2) // Sample for debug
                        });
                        
                        alert(`❌ Alla sparmetoder misslyckades:\n\n` +
                            `Primär metod: ${error.message}\n` +
                            `Fallback metod: ${fallbackError.message}\n\n` +
                            `Möjliga lösningar:\n` +
                            `• Kontrollera att backend-servern körs\n` +
                            `• Verifiera att API-endpoints finns\n` +
                            `• Kontrollera schemastrukturen\n` +
                            `• Försök generera schemat igen`);
                    }
                }
            }

            document.addEventListener('mousemove', function(e) {
                window.currentMousePosition = { x: e.clientX, y: e.clientY };
            });

            // Stop auto-scroll
            function stopAutoScroll() {
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                    autoScrollInterval = null;
                }
            }


            // Lägg till detta efter displayEditableScheduleWithAutoScroll funktionen
            function attachScrollListeners() {
                if (scheduleScrollContainer) {
                    scheduleScrollContainer.addEventListener('scroll', function() {
                        if (draggedLesson) {
                            setupAutoScrollBounds();
                        }
                    });
                    
                    scheduleScrollContainer.addEventListener('mouseenter', function() {
                        if (isEditMode) {
                            setupAutoScrollBounds();
                        }
                    });
                }
            }



            // Funktion för att ladda lärarens rumsbehörigheter
            async function loadTeacherRoomRestrictions(scheduleData) {
                if (!scheduleData || !scheduleData.lessons_by_day) return;
                
                // Samla alla unika lärare från schemat
                const teacherIds = new Set();
                
                Object.values(scheduleData.lessons_by_day).forEach(lessons => {
                    lessons.forEach(lesson => {
                        if (lesson.teacher_id) {
                            teacherIds.add(lesson.teacher_id);
                        }
                    });
                });
                
                debugLog('Loading room restrictions for teachers:', Array.from(teacherIds));
                
                // Ladda rumsbehörigheter för varje lärare
                for (const teacherId of teacherIds) {
                    try {
                        const response = await fetch(`/api/teacher/${teacherId}/room_access`);
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.success) {
                                if (result.unrestricted_access) {
                                    window.teacherRoomRestrictions[teacherId] = null; // Null = inga begränsningar
                                } else {
                                    window.teacherRoomRestrictions[teacherId] = result.allowed_rooms || [];
                                }
                                
                                debugLog(`Teacher ${teacherId} room access:`, window.teacherRoomRestrictions[teacherId]);
                            } else {
                                debugLog(`Failed to load room access for teacher ${teacherId}:`, result.error);
                                // Default: inga begränsningar
                                window.teacherRoomRestrictions[teacherId] = null;
                            }
                        } else {
                            debugLog(`HTTP error loading room access for teacher ${teacherId}:`, response.status);
                            window.teacherRoomRestrictions[teacherId] = null;
                        }
                        
                    } catch (error) {
                        console.error(`Error loading room access for teacher ${teacherId}:`, error);
                        window.teacherRoomRestrictions[teacherId] = null;
                    }
                }
                
                debugLog('Teacher room restrictions loaded:', window.teacherRoomRestrictions);
            }



  

            function startAutoScroll() {
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                }
                
                autoScrollInterval = setInterval(() => {
                    if (!draggedLesson || !scheduleScrollContainer || !window.currentMousePosition) {
                        return;
                    }
                    
                    const mousePos = window.currentMousePosition;
                    const containerRect = scheduleScrollContainer.getBoundingClientRect();
                    
                    // Kolla om musen är inom scroll-containern
                    const mouseInContainer = mousePos.x >= containerRect.left && 
                                            mousePos.x <= containerRect.right && 
                                            mousePos.y >= containerRect.top && 
                                            mousePos.y <= containerRect.bottom;
                    
                    if (!mouseInContainer) return;
                    
                    const scrollSpeed = 15;
                    const edgeZone = 40; // Större zon för lättare scroll
                    let didScroll = false;
                    
                    // Vertikal scroll - när musen är nära övre eller nedre kanten av containern
                    const distanceFromTop = mousePos.y - containerRect.top;
                    const distanceFromBottom = containerRect.bottom - mousePos.y;
                    
                    if (distanceFromTop < edgeZone && scheduleScrollContainer.scrollTop > 0) {
                        // Scroll upp
                        const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromTop) / edgeZone);
                        scheduleScrollContainer.scrollTop -= scrollAmount;
                        didScroll = true;
                    } else if (distanceFromBottom < edgeZone) {
                        // Scroll ner
                        const maxScroll = scheduleScrollContainer.scrollHeight - scheduleScrollContainer.clientHeight;
                        if (scheduleScrollContainer.scrollTop < maxScroll) {
                            const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromBottom) / edgeZone);
                            scheduleScrollContainer.scrollTop += scrollAmount;
                            didScroll = true;
                        }
                    }
                    
                    // Horizontal scroll - när musen är nära vänster eller höger kanten
                    const distanceFromLeft = mousePos.x - containerRect.left;
                    const distanceFromRight = containerRect.right - mousePos.x;
                    
                    if (distanceFromLeft < edgeZone && scheduleScrollContainer.scrollLeft > 0) {
                        // Scroll vänster
                        const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromLeft) / edgeZone);
                        scheduleScrollContainer.scrollLeft -= scrollAmount;
                        didScroll = true;
                    } else if (distanceFromRight < edgeZone) {
                        // Scroll höger
                        const maxScrollLeft = scheduleScrollContainer.scrollWidth - scheduleScrollContainer.clientWidth;
                        if (scheduleScrollContainer.scrollLeft < maxScrollLeft) {
                            const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromRight) / edgeZone);
                            scheduleScrollContainer.scrollLeft += scrollAmount;
                            didScroll = true;
                        }
                    }
                    
                    if (didScroll) {
                        debugLog('Auto-scrolled container', {
                            scrollTop: scheduleScrollContainer.scrollTop,
                            scrollLeft: scheduleScrollContainer.scrollLeft,
                            mousePos: mousePos,
                            containerRect: containerRect
                        });
                    }
                    
                }, 16); // ~60 FPS
            }


            const teacherBufferStyles = `
            .teacher-buffer-indicator {
                pointer-events: none;
                user-select: none;
                font-weight: bold;
                text-shadow: 0 1px 1px rgba(0,0,0,0.3);
            }

            .teacher-conflict-zone {
                position: relative;
            }

            .teacher-conflict-zone::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 2px;
                background: linear-gradient(90deg, transparent, #f56565, transparent);
                opacity: 0.8;
            }
            `;



            // Lägg till styles
            if (!document.getElementById('teacher-buffer-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'teacher-buffer-styles';
                styleElement.textContent = teacherBufferStyles;
                document.head.appendChild(styleElement);
            }

            // Lägg till CSS för nya klasser
            const enhancedConflictStyles = `
                .teacher-conflict-zone {
                    border: 2px solid #f56565 !important;
                    background: rgba(245, 101, 101, 0.3) !important;
                }

                .room-conflict-zone {
                    border: 2px dashed #ed8936 !important;
                    background: rgba(237, 137, 54, 0.15) !important;
                }

                .drop-zone {
                    border: 2px dashed #4299e1 !important;
                    background: rgba(66, 153, 225, 0.1) !important;
                }

                .drag-conflict-indicator {
                    pointer-events: none !important;
                    user-select: none;
                    font-weight: bold;
                }

                .schedule-cell {
                    transition: all 0.2s ease;
                    position: relative;
                }
                
                /* Förstärk markeringen */
                .schedule-cell.teacher-conflict-zone {
                    border-color: #f56565 !important;
                    border-style: solid !important;
                    border-width: 2px !important;
                }
                
                .schedule-cell.room-conflict-zone {
                    border-color: #ed8936 !important;
                    border-style: dashed !important;  
                    border-width: 2px !important;
                }
                
                .schedule-cell.drop-zone {
                    border-color: #4299e1 !important;
                    border-style: dashed !important;
                    border-width: 2px !important;
                }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('enhanced-conflict-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'enhanced-conflict-styles';
                styleElement.textContent = enhancedConflictStyles;
                document.head.appendChild(styleElement);
            }




            // Förbättrad showRoomChangeModal med bättre felhantering och UI
            async function showRoomChangeModal(lessonId, event) {
                event.stopPropagation();
                event.preventDefault();
                
                // Stäng eventuell befintlig dropdown
                const existingDropdown = document.querySelector('.room-dropdown');
                if (existingDropdown) {
                    existingDropdown.remove();
                }
                
                const lessonElement = document.getElementById(`lesson-${lessonId}`);
                if (!lessonElement) {
                    debugLog('Lesson element not found for room change');
                    showConflictMessage('Kunde inte hitta lektionen för rumsbyte');
                    return;
                }
                
                const currentRoom = lessonElement.dataset.room;
                const teacherId = lessonElement.dataset.teacherId;
                const day = lessonElement.dataset.originalDay;
                const time = lessonElement.dataset.originalTime;
                const subject = lessonElement.dataset.subject;
                
                try {
                    // Hämta alla tillgängliga rum
                    const allRooms = getAvailableRooms();
                    
                    // Hämta alla andra lektioner för konfliktcheck
                    const allCurrentLessons = Array.from(document.querySelectorAll('.spanning-lesson'))
                        .filter(el => el.dataset.lessonId !== lessonId && el.style.display !== 'none')
                        .map(el => ({
                            day: el.dataset.originalDay,
                            time: el.dataset.originalTime,
                            room: el.dataset.room
                        }))
                        .filter(lesson => lesson.time && lesson.day);
                    
                    // Kontrollera vilka rum som är tillgängliga för denna tid
                    const availableRooms = getAvailableRoomsForTimeSlot(allCurrentLessons, day, time);
                    
                    // Kontrollera lärarens rumsbegränsningar
                    const teacherAllowedRooms = teacherId ? getAvailableRoomsForTeacher(teacherId) : allRooms;
                    
                    // Få knappens position
                    const buttonRect = event.target.getBoundingClientRect();
                    
                    // Skapa dropdown
                    const dropdown = document.createElement('div');
                    dropdown.className = 'room-dropdown';
                    dropdown.innerHTML = `
                        <div class="room-dropdown-header">
                            <div style="font-weight: 600; font-size: 12px; margin-bottom: 4px;">${escapeHtml(subject)}</div>
                            <div style="font-size: 10px; color: #666; margin-bottom: 8px;">Nuvarande: ${escapeHtml(currentRoom)}</div>
                        </div>
                        <div class="room-dropdown-list">
                            ${generateCompactRoomOptions(allRooms, availableRooms, teacherAllowedRooms, currentRoom)}
                        </div>
                    `;
                    
                    // Positionera dropdown
                    dropdown.style.cssText = `
                        position: fixed;
                        left: ${buttonRect.left}px;
                        top: ${buttonRect.bottom + 5}px;
                        z-index: 10000;
                        background: white;
                        border: 1px solid #e2e8f0;
                        border-radius: 6px;
                        box-shadow: 0 8px 16px rgba(0,0,0,0.15);
                        min-width: 200px;
                        max-width: 280px;
                        max-height: 300px;
                        overflow-y: auto;
                        padding: 8px;
                    `;
                    
                    document.body.appendChild(dropdown);
                    
                    // FIX: Lägg till klick-lyssnare DIREKT på room options med bättre selektor
                    dropdown.querySelectorAll('.room-dropdown-option').forEach(option => {
                        option.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            
                            if (option.classList.contains('occupied') || option.classList.contains('restricted')) {
                                return; // Ignorera klick på otillgängliga rum
                            }
                            
                            const newRoom = option.dataset.room;
                            if (newRoom && newRoom !== currentRoom) {
                                dropdown.remove();
                                await changeRoomForLesson(lessonId, newRoom);
                            }
                        });
                    });
                    
                    // Stäng dropdown vid klick utanför
                    const outsideClickHandler = (e) => {
                        if (!dropdown.contains(e.target)) {
                            dropdown.remove();
                            document.removeEventListener('click', outsideClickHandler);
                        }
                    };
                    
                    // Lägg till lyssnaren efter en kort delay
                    setTimeout(() => {
                        document.addEventListener('click', outsideClickHandler);
                    }, 100);
                    
                    // ESC-tangent för att stänga
                    const escapeHandler = (e) => {
                        if (e.key === 'Escape') {
                            dropdown.remove();
                            document.removeEventListener('keydown', escapeHandler);
                            document.removeEventListener('click', outsideClickHandler);
                        }
                    };
                    document.addEventListener('keydown', escapeHandler);
                    
                } catch (error) {
                    console.error('Error opening room change dropdown:', error);
                    showConflictMessage('Fel vid öppning av rumsbyte-dialog');
                }
            }


            // Ny funktion för att generera kompakta rum-alternativ för dropdown
            function generateCompactRoomOptions(allRooms, availableRooms, teacherAllowedRooms, currentRoom) {
                return allRooms.map(room => {
                    const isCurrentRoom = room === currentRoom;
                    const isAvailable = availableRooms.includes(room);
                    const isTeacherAllowed = teacherAllowedRooms.includes(room);
                    
                    let className = 'room-dropdown-option';
                    let statusIcon = '🏫';
                    let clickable = true;
                    let statusText = '';
                    
                    if (isCurrentRoom) {
                        className += ' current';
                        statusIcon = '✅';
                        statusText = ' (nuvarande)';
                    } else if (!isTeacherAllowed) {
                        className += ' restricted';
                        statusIcon = '🚫';
                        clickable = false;
                        statusText = ' (ej tillgängligt)';
                    } else if (!isAvailable) {
                        className += ' occupied';
                        statusIcon = '⚠️';
                        clickable = false;
                        statusText = ' (upptaget)';
                    } else {
                        statusIcon = '✅';
                        statusText = ' (ledigt)';
                    }
                    
                    return `
                        <div class="${className}" 
                            data-room="${escapeHtml(room)}" 
                            style="cursor: ${clickable ? 'pointer' : 'not-allowed'};"
                            title="${escapeHtml(room)}${statusText}">
                            <span style="display: flex; align-items: center; justify-content: space-between;">
                                <span>${statusIcon} ${escapeHtml(room)}</span>
                                ${isCurrentRoom ? '<span style="color: #48bb78; font-size: 10px;">●</span>' : ''}
                            </span>
                        </div>
                    `;
                }).join('');
            }

            // Förbättrad generateRoomOptions med bättre kategorisering
            function generateRoomOptions(allRooms, availableRooms, teacherAllowedRooms, currentRoom) {
                return allRooms.map(room => {
                    const isCurrentRoom = room === currentRoom;
                    const isAvailable = availableRooms.includes(room);
                    const isTeacherAllowed = teacherAllowedRooms.includes(room);
                    
                    let className = 'room-option';
                    let status = '';
                    let statusIcon = '🏫';
                    let clickable = true;
                    
                    if (isCurrentRoom) {
                        className += ' current';
                        status = ' (nuvarande rum)';
                        statusIcon = '✅';
                    } else if (!isTeacherAllowed) {
                        className += ' restricted';
                        status = ' (ej tillgängligt för läraren)';
                        statusIcon = '🚫';
                        clickable = false;
                    } else if (!isAvailable) {
                        className += ' occupied';
                        status = ' (upptaget denna tid)';
                        statusIcon = '⚠️';
                        clickable = false;
                    } else {
                        statusIcon = '✅';
                        status = ' (tillgängligt)';
                    }
                    
                    return `
                        <div class="${className}" 
                            data-room="${escapeHtml(room)}" 
                            ${clickable ? `style="cursor: pointer;"` : 'style="cursor: not-allowed;"'}>
                            <span>
                                ${statusIcon} ${escapeHtml(room)}${status}
                            </span>
                            ${isCurrentRoom ? '<span style="color: #48bb78; font-weight: bold;">●</span>' : ''}
                        </div>
                    `;
                }).join('');
            }

            // Funktion för att byta rum för en lektion
            // Förbättrad changeRoomForLesson med bättre feedback
            async function changeRoomForLesson(lessonId, newRoom) {
                const lessonElement = document.getElementById(`lesson-${lessonId}`);
                const originalRoom = lessonElement?.dataset.room;
                
                if (!lessonElement) {
                    showConflictMessage('Kunde inte hitta lektionen för rumsbyte');
                    return;
                }
                
                if (originalRoom === newRoom) {
                    showConflictMessage('Det valda rummet är redan tilldelat denna lektion');
                    return;
                }
                
                try {
                    debugLog('Changing room for lesson:', { lessonId, from: originalRoom, to: newRoom });
                    
                    // Visa laddningsindikator
                    const originalOpacity = lessonElement.style.opacity || '1';
                    lessonElement.style.opacity = '0.6';
                    lessonElement.style.pointerEvents = 'none';
                    
                    // Lägg till en laddningsindikator
                    const loadingIndicator = document.createElement('div');
                    loadingIndicator.id = `loading-${lessonId}`;
                    loadingIndicator.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(255,255,255,0.9);
                        padding: 4px 8px;
                        border-radius: 4px;
                        font-size: 10px;
                        color: #4a5568;
                        z-index: 1000;
                    `;
                    loadingIndicator.textContent = 'Byter rum...';
                    lessonElement.appendChild(loadingIndicator);
                    
                    const response = await fetch(`/api/schedule/change_room/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            room: newRoom
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte byta klassrum');
                    }

                    // Uppdatera UI
                    lessonElement.dataset.room = newRoom;
                    
                    // Uppdatera rumstexten i room-info div
                    const roomInfoDiv = lessonElement.querySelector('.room-info span');
                    if (roomInfoDiv) {
                        roomInfoDiv.textContent = `📍 ${newRoom}`;
                    }
                    
                    // Uppdatera även i window.editModeLessons om det finns
                    if (window.editModeLessons && window.editModeLessons[lessonId]) {
                        window.editModeLessons[lessonId].room = newRoom;
                    }
                    
                    // Återställ interaktivitet
                    lessonElement.style.opacity = originalOpacity;
                    lessonElement.style.pointerEvents = 'auto';
                    
                    // Lägg till visuell framgångs-feedback
                    lessonElement.style.boxShadow = '0 0 10px rgba(72, 187, 120, 0.5)';
                    lessonElement.style.borderColor = 'rgba(72, 187, 120, 0.8)';
                    
                    setTimeout(() => {
                        lessonElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.15)';
                        lessonElement.style.borderColor = 'rgba(255,255,255,0.3)';
                    }, 2000);

                    showSuccessToast(`✅ Klassrum ändrat från "${originalRoom}" till "${newRoom}"`);
                    debugLog('Room changed successfully:', result);

                } catch (error) {
                    console.error('Error changing room:', error);
                    
                    // Återställ UI vid fel
                    lessonElement.style.opacity = originalOpacity || '1';
                    lessonElement.style.pointerEvents = 'auto';
                    
                    showConflictMessage(`❌ Fel vid rumsbyte: ${error.message}`);
                } finally {
                    // Ta bort laddningsindikator
                    const loadingIndicator = document.getElementById(`loading-${lessonId}`);
                    if (loadingIndicator) {
                        loadingIndicator.remove();
                    }
                }
            }



            // Uppdaterade CSS-stilar för room-change funktionalitet
            const enhancedRoomChangeStyles = `
                .room-change-btn-inline {
                    background: rgba(255, 255, 255, 0.8) !important;
                    border: 1px solid rgba(0,0,0,0.2) !important;
                    border-radius: 50% !important;
                    width: 16px !important;
                    height: 16px !important;
                    cursor: pointer !important;
                    font-size: 8px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    transition: all 0.2s ease !important;
                    flex-shrink: 0 !important;
                }
                
                .room-change-btn-inline:hover {
                    background: white !important;
                    transform: scale(1.1) !important;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
                    border-color: rgba(66, 153, 225, 0.5) !important;
                }
                
                .room-info {
                    display: flex !important;
                    align-items: center !important;
                    justify-content: space-between !important;
                    gap: 4px !important;
                }
                
                .room-change-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    animation: fadeIn 0.2s ease-out;
                }
                
                .room-change-content {
                    background: white;
                    padding: 2rem;
                    border-radius: 0.5rem;
                    max-width: 500px;
                    max-height: 80vh;
                    overflow-y: auto;
                    margin: 1rem;
                    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                    animation: slideIn 0.2s ease-out;
                }
                
                .room-option {
                    padding: 0.75rem;
                    border: 1px solid #e2e8f0;
                    border-radius: 0.375rem;
                    margin-bottom: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .room-option:hover:not(.occupied):not(.restricted) {
                    background: #f7fafc;
                    border-color: #4299e1;
                    transform: translateX(2px);
                }
                
                .room-option.occupied {
                    background: #fed7d7;
                    border-color: #f56565;
                    cursor: not-allowed;
                    opacity: 0.7;
                }
                
                .room-option.restricted {
                    background: #f7fafc;
                    border-color: #a0aec0;
                    cursor: not-allowed;
                    opacity: 0.6;
                }
                
                .room-option.current {
                    background: #c6f6d5;
                    border-color: #48bb78;
                    font-weight: 600;
                }
                
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                
                @keyframes slideIn {
                    from { 
                        opacity: 0;
                        transform: translateY(-20px) scale(0.95);
                    }
                    to { 
                        opacity: 1;
                        transform: translateY(0) scale(1);
                    }
                }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('enhanced-room-change-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'enhanced-room-change-styles';
                styleElement.textContent = enhancedRoomChangeStyles;
                document.head.appendChild(styleElement);
            }

            // Förbättrat visuell feedback system
            const enhancedStyles = `
                .schedule-cell.drop-zone {
                    border: 2px dashed #4299e1 !important;
                    background: rgba(66, 153, 225, 0.1) !important;
                }
                
                .schedule-cell.invalid-drop-zone {
                    border: 2px dashed #f56565 !important;
                    background: rgba(245, 101, 101, 0.1) !important;
                }
                
                .draggable-lesson:active {
                    cursor: grabbing !important;
                }
                
                .schedule-cell:hover {
                    background: rgba(0, 0, 0, 0.02);
                }
                
                #scheduleScrollContainer::-webkit-scrollbar {
                    width: 8px;
                    height: 8px;
                }
                
                #scheduleScrollContainer::-webkit-scrollbar-track {
                    background: #f1f1f1;
                    border-radius: 4px;
                }
                
                #scheduleScrollContainer::-webkit-scrollbar-thumb {
                    background: #c1c1c1;
                    border-radius: 4px;
                }
                
                #scheduleScrollContainer::-webkit-scrollbar-thumb:hover {
                    background: #a8a8a8;
                }
                
                .buffer-indicator {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 2px;
                    background: linear-gradient(90deg, transparent, #ffd700, transparent);
                    opacity: 0.8;
                }
            `;



            const preserveGridStyles = `
                .schedule-cell.lesson-start,
                .schedule-cell.lesson-middle,
                .schedule-cell.empty {
                    height: 20px !important;
                    border: 1px solid #e2e8f0 !important;
                    position: relative !important;
                    vertical-align: top !important;
                }
                
                /* Bevara rutnätet även när celler är tomma under drag */
                .schedule-cell {
                    min-height: 20px !important;
                    box-sizing: border-box !important;
                }
                
                /* Förhindra att lesson-middle celler kollapsar */
                .schedule-cell.lesson-middle {
                    background: linear-gradient(135deg, #4299e1, #3182ce) !important;
                    border-left: 1px solid rgba(255,255,255,0.3) !important;
                    border-right: 1px solid rgba(255,255,255,0.3) !important;
                }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('preserve-grid-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'preserve-grid-styles';
                styleElement.textContent = preserveGridStyles;
                document.head.appendChild(styleElement);
            }


            window.addEventListener('resize', setupAutoScrollBounds);

            window.addEventListener('resize', function() {
                if (scheduleScrollContainer) {
                    setupAutoScrollBounds();
                }
            });

            // Cleanup vid page unload
            window.addEventListener('beforeunload', function() {
                stopAutoScroll();
            });


            function restoreHiddenLesson() {
                if (draggedLesson && draggedLesson.originalCells) {
                    draggedLesson.originalCells.forEach(cell => {
                        const hiddenLesson = cell.querySelector(`#lesson-${draggedLesson.lessonId}`);
                        if (hiddenLesson && hiddenLesson.style.display === 'none') {
                            hiddenLesson.style.display = 'block';
                            // Återställ cellens läge
                            cell.classList.remove('empty');
                            if (cell === draggedLesson.originalCells[0]) {
                                cell.classList.add('lesson-start');
                            } else {
                                cell.classList.add('lesson-middle');
                            }
                        }
                    });
                }
            }


            // New function to restore lesson to original position if drop failed
            function restoreLessonToOriginalPosition() {
                if (!draggedLesson || !draggedLesson.originalCells) {
                    debugLog('Cannot restore lesson - missing data');
                    return;
                }
                
                debugLog('Restoring lesson to original position');
                
                draggedLesson.originalCells.forEach((cell, index) => {
                    const hiddenLesson = cell.querySelector(`#lesson-${draggedLesson.lessonId}`);
                    
                    if (hiddenLesson) {
                        // Återställ synligheten
                        hiddenLesson.style.display = 'block';
                    }
                    
                    // Återställ ursprungliga cellklasser utan att störa rutnätet
                    if (index === 0) {
                        // Första cellen behåller lesson-start
                        if (!cell.classList.contains('lesson-start')) {
                            cell.classList.add('lesson-start');
                        }
                        cell.classList.remove('empty');
                    } else {
                        // Mellan-celler behåller lesson-middle
                        if (!cell.classList.contains('lesson-middle')) {
                            cell.classList.add('lesson-middle');
                        }
                        cell.classList.remove('empty');
                    }
                });
            }

            // 3. FÖRBÄTTRA clearOriginalLessonCells - anropa ENDAST från markTeacherConflictCells
            function clearOriginalLessonCells() {
                if (!draggedLesson || !draggedLesson.originalCells || clearOriginalLessonCells.hasRun) {
                    return;
                }
                
                // Förhindra dubbelanrop
                clearOriginalLessonCells.hasRun = true;
                
                debugLog('Clearing original lesson cells', draggedLesson.originalCells.length);
                
                draggedLesson.originalCells.forEach((cell, index) => {
                    // Ta bort lesson content men behåll cell structure
                    const lessonInCell = cell.querySelector(`#lesson-${draggedLesson.lessonId}`);
                    if (lessonInCell) {
                        // Gör lektionen osynlig istället för att ta bort den helt
                        lessonInCell.style.display = 'none';
                    }
                    
                    // VIKTIGT: Behåll cellernas ursprungliga klasser och struktur
                    // Ta INTE bort lesson-start/lesson-middle klasserna här - det påverkar rutnätet
                    
                    // Behåll cell styling och drop handlers utan att ändra grundläggande struktur
                    if (!cell.hasAttribute('ondrop')) {
                        cell.setAttribute('ondrop', 'handleLessonDrop(event)');
                        cell.setAttribute('ondragover', 'handleDragOver(event)');
                        cell.setAttribute('ondragenter', 'handleDragEnter(event)');
                        cell.setAttribute('ondragleave', 'handleDragLeave(event)');
                    }
                });
            }



            // Also update the cleanupDragState function to better handle cell restoration:
            // 5. FÖRBÄTTRA cleanupDragState
            function cleanupDragState() {
                debugLog('Starting drag state cleanup');
                
                stopAutoScroll();
                
                // Reset clearOriginalLessonCells flag
                clearOriginalLessonCells.hasRun = false;
                
                // Ta bort alla visuella feedback-klasser
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    cell.classList.remove('drop-zone', 'teacher-conflict-zone', 'room-conflict-zone');
                    
                    // Återställ cell styling till default
                    if (cell.classList.contains('empty')) {
                        cell.style.cssText = `
                            padding: 0; 
                            border: 1px solid #e2e8f0; 
                            height: 20px;
                            position: relative; 
                            vertical-align: top;
                            transition: all 0.2s ease;
                            background: transparent;
                        `;
                    } else if (cell.classList.contains('lesson-middle')) {
                        cell.style.cssText = `
                            padding: 0; 
                            border: 1px solid #e2e8f0; 
                            height: 20px;
                            position: relative; 
                            vertical-align: top;
                            background: linear-gradient(135deg, #4299e1, #3182ce);
                            border-left: 1px solid rgba(255,255,255,0.3);
                            border-right: 1px solid rgba(255,255,255,0.3);
                        `;
                    }
                    
                    cell.title = '';
                });
                
                // Ta bort konfliktindikatorer
                document.querySelectorAll('.drag-conflict-indicator, .teacher-buffer-indicator').forEach(el => el.remove());
                
                // Reset draggedLesson
                draggedLesson = null;
                
                debugLog('Drag state cleanup completed');
            }






            // Update handleLessonDragEndEnhanced to handle restoration better:
            // Update handleLessonDragEndEnhanced to handle restoration better:
            // 2. FÖRBÄTTRA handleLessonDragEndEnhanced
            function handleLessonDragEndEnhanced(event) {
                event.stopPropagation();
                
                if (!draggedLesson) {
                    debugLog('Drag end called but no draggedLesson found');
                    return;
                }
                
                const lessonElement = event.target.closest('.draggable-lesson');
                if (lessonElement) {
                    // Återställ visuell feedback
                    lessonElement.style.opacity = '1';
                    lessonElement.style.transform = 'scale(1)';
                    lessonElement.style.zIndex = '';
                    lessonElement.style.boxShadow = '';
                }
                
                // Kontrollera om lektionen droppades framgångsrikt
                const wasSuccessfullyMoved = !draggedLesson.originalCells.some(cell => 
                    cell.contains(lessonElement)
                );
                
                if (!wasSuccessfullyMoved) {
                    debugLog('Drag ended without successful drop - restoring lesson');
                    restoreLessonToOriginalPosition();
                }
                
                // Cleanup efter en kort delay för att låta drop-handler köra först
                setTimeout(() => {
                    cleanupDragState();
                }, 100);
                
                debugLog('Enhanced drag ended');
            }

            // Lägg till styles
            if (!document.getElementById('enhanced-schedule-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'enhanced-schedule-styles';
                styleElement.textContent = enhancedStyles;
                document.head.appendChild(styleElement);
            }


            // Lägg till denna CSS för rum-knappen
            const roomChangeStyles = `
                .room-change-btn {
                    position: absolute;
                    top: 2px;
                    left: 2px;
                    width: 16px;
                    height: 16px;
                    background: rgba(255, 255, 255, 0.9);
                    color: #4a5568;
                    border: 1px solid rgba(0,0,0,0.1);
                    border-radius: 3px;
                    cursor: pointer;
                    font-size: 10px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 200;
                    transition: all 0.2s ease;
                    hover: background: white;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                }
                
                .room-change-btn:hover {
                    background: white !important;
                    transform: scale(1.1);
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                }
                
                .room-change-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                
                .room-change-content {
                    background: white;
                    padding: 2rem;
                    border-radius: 0.5rem;
                    max-width: 500px;
                    max-height: 80vh;
                    overflow-y: auto;
                    margin: 1rem;
                    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                }
                
                .room-option {
                    padding: 0.75rem;
                    border: 1px solid #e2e8f0;
                    border-radius: 0.375rem;
                    margin-bottom: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .room-option:hover {
                    background: #f7fafc;
                    border-color: #4299e1;
                }
                
                .room-option.occupied {
                    background: #fed7d7;
                    border-color: #f56565;
                    cursor: not-allowed;
                    opacity: 0.7;
                }
                
                .room-option.current {
                    background: #c6f6d5;
                    border-color: #48bb78;
                    font-weight: 600;
                }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('room-change-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'room-change-styles';
                styleElement.textContent = roomChangeStyles;
                document.head.appendChild(styleElement);
            }



            const roomDropdownStyles = `
            .room-dropdown-option {
                padding: 8px 12px;
                margin: 2px 0;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
                border: 1px solid transparent;
                user-select: none;
            }

            .room-dropdown-option:hover:not(.occupied):not(.restricted) {
                background: #f0f8ff;
                border-color: #4299e1;
            }

            .room-dropdown-option.occupied {
                background: #fed7d7;
                color: #744210;
                cursor: not-allowed;
                opacity: 0.6;
            }

            .room-dropdown-option.restricted {
                background: #f7fafc;
                color: #a0aec0;
                cursor: not-allowed;
                opacity: 0.6;
            }

            .room-dropdown-option.current {
                background: #c6f6d5;
                border-color: #48bb78;
                font-weight: 600;
            }
            `;

            // Lägg till styles
            if (!document.getElementById('room-dropdown-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'room-dropdown-styles';
                styleElement.textContent = roomDropdownStyles;
                document.head.appendChild(styleElement);
            }


            // Ersätt befintliga funktioner med förbättrade versioner
            window.displayEditableSchedule = displayEditableScheduleWithAutoScroll;
            window.createEditableLessonBlock = createEditableLessonBlockEnhanced;
            window.handleLessonDragStart = handleLessonDragStartEnhanced;
            window.handleLessonDragEnd = handleLessonDragEndEnhanced;


            window.markTeacherConflictCells = markTeacherConflictCells;
            window.clearOriginalLessonCells = clearOriginalLessonCells;
            window.restoreLessonToOriginalPosition = restoreLessonToOriginalPosition;
            window.cleanupDragState = cleanupDragState;


            debugLog('Enhanced drag-and-drop schedule editor loaded with 5-minute room buffer and auto-scroll');
            window.handleLessonDrop = handleLessonDrop;
            window.createEditableLessonBlockSpanning = createEditableLessonBlockSpanningWithRoomButton;




            window.showRoomChangeModal = showRoomChangeModal;
            window.changeRoomForLesson = changeRoomForLesson;
            window.generateRoomOptions = generateRoomOptions;
            window.createEditableLessonBlockSpanningWithRoomButton = createEditableLessonBlockSpanningWithRoomButton;

            function setupAutoScrollBounds() {
                if (!scheduleScrollContainer) return;
                
                const rect = scheduleScrollContainer.getBoundingClientRect();
                
                dragScrollBounds = {
                    top: rect.top,
                    bottom: rect.bottom,
                    left: rect.left,
                    right: rect.right,
                    containerRect: rect
                };
                
                debugLog('Auto-scroll bounds updated:', {
                    bounds: dragScrollBounds,
                    scrollHeight: scheduleScrollContainer.scrollHeight,
                    clientHeight: scheduleScrollContainer.clientHeight,
                    scrollWidth: scheduleScrollContainer.scrollWidth,
                    clientWidth: scheduleScrollContainer.clientWidth
                });
            }


            // Initiera när sidan laddas
            document.addEventListener('DOMContentLoaded', function() {
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
            });
    </script>
</body>
</html>
