<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schemagenerator - {{ school.name if school else 'Okänd skola' }}</title>
    <style>
        /* --- (Samma stil som innan, oförändrad) --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem 2rem;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            color: #2d3748;
            font-size: 1.8rem;
        }
        .back-btn {
            background: #718096;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .back-btn:hover {
            background: #4a5568;
        }
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }
        .generator-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .card {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        .card h3 {
            margin-top: 0;
            color: #2d3748;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #4a5568;
        }
        .form-group select, .form-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        /* Multi-select klasser */
        .classes-container {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            background: #f7fafc;
            max-height: 200px;
            overflow-y: auto;
        }
        .class-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #e2e8f0;
        }
        .class-item:last-child {
            margin-bottom: 0;
        }
        .class-item input[type="checkbox"] {
            margin-right: 0.75rem;
            width: auto;
        }
        .class-item-info {
            flex: 1;
        }
        .class-name {
            font-weight: 600;
            color: #2d3748;
        }
        .class-details {
            font-size: 0.85rem;
            color: #718096;
        }
        .subjects-container {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            background: #f7fafc;
        }
        .class-subject-section {
            margin-bottom: 1rem;
        }
        .class-subject-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            gap: 0.5rem;
        }
        .subject-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 1rem;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }
        .subject-item:last-child {
            margin-bottom: 0;
        }
        .subject-item input, .subject-item select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        .add-subject-btn {
            background: #48bb78;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }
        .add-subject-btn:hover {
            background: #38a169;
        }
        .remove-subject-btn {
            background: #f56565;
            color: white;
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .remove-subject-btn:hover {
            background: #e53e3e;
        }
        .rooms-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .room-item {
            display: flex;
            align-items: center;
            background: #f7fafc;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .room-item input[type="checkbox"] {
            margin-right: 0.5rem;
            width: auto;
        }
        .constraints-section {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            background: #f7fafc;
        }
        .constraint-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .constraint-item input[type="checkbox"] {
            margin-right: 0.5rem;
            width: auto;
        }
        .time-range {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .lesson-duration-section {
            margin-top: 1rem;
            padding: 1rem;
            background: #f0f8ff;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
        }
        .btn {
            background: #4299e1;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s;
            font-weight: 600;
        }
        .btn:hover {
            background: #3182ce;
            transform: translateY(-1px);
        }
        .btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }
        .btn-generate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 100%;
            justify-self: center;
        }
        .btn-generate:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }
        .schedule-preview {
            min-height: 400px;
            background: #f7fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #718096;
            font-size: 1.1rem;
            position: relative;
            overflow-x: auto;
        }
        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 800px;
        }




        .schedule-status-indicator {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .class-item {
            position: relative;
            transition: all 0.2s ease;
        }

        .class-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .generation-controls {
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .reset-schedule-btn:hover {
            background: #e53e3e !important;
            transform: scale(1.02);
        }

        .save-status {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.85rem;
            margin: 0.5rem 0;
        }

        .save-status.unsaved {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }

        .save-status.saved {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .schedule-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .schedule-actions .btn {
            min-width: 120px;
            transition: all 0.2s ease;
        }

        .schedule-actions .btn:hover {
            transform: translateY(-1px);
        }

        .loading-save {
            opacity: 0.7;
            pointer-events: none;
        }

        /* Enhanced schedule table styles */
        .schedule-table {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .lesson-cell {
            vertical-align: top !important;
        }

        .lesson-subject {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: #2d3748;
        }

        .lesson-class {
            font-size: 0.8rem;
            color: #4a5568;
            margin-bottom: 0.25rem;
        }
        .schedule-table th {
            background: #4299e1;
            color: white;
            padding: 0.75rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }
        .schedule-table td {
            padding: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            text-align: center;
            vertical-align: middle;
            font-size: 0.85rem;
            min-width: 120px;
        }
        .schedule-table tr:hover {
            background: #f7fafc;
        }
        .lesson-cell {
            background: #ebf8ff;
            border-left: 3px solid #4299e1;
            font-size: 0.8rem;
            line-height: 1.1;
            text-align: left;
            padding: 0.4rem;
        }
        .lesson-subject {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.8rem;
        }
        .lesson-class {
            color: #4299e1;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .schedule-cell {
            overflow: visible !important; /* tillåt att .draggable-lesson sticker ut */
        }
        .spanning-lesson {
            box-sizing: border-box; /* säkerställ att padding inkluderas i höjden */
        }

        .lesson-room {
            color: #718096;
            font-size: 0.7rem;
        }
        .empty-cell {
            color: #a0aec0;
            font-style: italic;
            font-size: 0.8rem;
        }
        .generation-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #4299e1;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .alert {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            border-left: 4px solid;
        }
        .alert-success {
            background: #f0fff4;
            color: #22543d;
            border-color: #38a169;
        }
        .alert-error {
            background: #fed7d7;
            color: #c53030;
            border-color: #e53e3e;
        }
        .alert-info {
            background: #ebf8ff;
            color: #2c5282;
            border-color: #4299e1;
        }
        .alert-warning {
            background: #fffbeb;
            color: #744210;
            border-color: #f59e0b;
        }
        .debug-info {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #4a5568;
        }
        .validation-warning {
            background: #fffbeb;
            border-left: 4px solid #f59e0b;
            color: #744210;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 6px;
        }
        .selected-classes-info {
            background: #e6fffa;
            border: 1px solid #38b2ac;
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.5rem;
            color: #234e52;
        }
        .class-color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        @media (max-width: 1200px) {
            .generator-layout {
                grid-template-columns: 1fr;
            }
            .subject-item {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            .rooms-container {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📅 Multi-klass Schemagenerator - {{ school.name if school else 'Testskolan' }}</h1>
        <a href="#" class="back-btn">← Tillbaka till Dashboard</a>
    </div>

    <div class="container">



        <!-- Lägg till denna sektion INNAN formuläret i schedule_generator.html -->
        <!-- Lägg till denna sektion INNAN formuläret i schedule_generator.html -->
        <div class="card" style="margin-bottom: 2rem;">
            <h3>📚 Hantera Skolämnen & Lärarbehörigheter</h3>
            
            <div class="form-group">
                <label>Lägg till nytt ämne:</label>
                <div style="display: flex; gap: 1rem; align-items: end;">
                    <div style="flex: 1;">
                        <input type="text" id="newSubjectName" placeholder="Ämnesnamn (t.ex. Matematik, Svenska, Historia)" style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px;">
                    </div>
                    <button type="button" class="btn" onclick="addNewSubject()" style="background: #48bb78; white-space: nowrap;">+ Lägg till</button>
                </div>
            </div>
            
            <div class="form-group">
                <label>Befintliga ämnen & behöriga lärare:</label>
                <div id="existingSubjects" class="subjects-list" style="border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem; background: #f7fafc; min-height: 100px; max-height: 400px; overflow-y: auto;">
                    <div style="color: #666; text-align: center;" id="noSubjectsMessage">
                        Inga ämnen ännu. Lägg till ämnen ovan.
                    </div>
                </div>
            </div>
            
            <div class="alert alert-info" style="margin-top: 1rem;">
                <strong>💡 Tips:</strong> Ämnena du skapar här kommer att vara tillgängliga för alla klasser när du genererar scheman. Endast lärare som är markerade som behöriga kan schemaläggas för respektive ämne.
            </div>
        </div>

        <!-- Modal för lärarhantering -->
        <div id="teacherModal" class="modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
            <div class="modal-content" style="background: white; margin: 5% auto; padding: 2rem; width: 80%; max-width: 600px; border-radius: 12px; max-height: 80vh; overflow-y: auto;">
                <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #e2e8f0; padding-bottom: 1rem;">
                    <h3 id="modalTitle" style="margin: 0; color: #2d3748;">Hantera Lärarbehörigheter</h3>
                    <button class="close" onclick="closeTeacherModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>
                </div>
                
                <div id="modalContent" style="margin-bottom: 1.5rem;">
                    <!-- Content fylls dynamiskt -->
                </div>
                
                <div class="modal-footer" style="border-top: 1px solid #e2e8f0; padding-top: 1rem; text-align: right;">
                    <button type="button" class="btn" onclick="closeTeacherModal()" style="background: #718096;">Stäng</button>
                </div>
            </div>
        </div>

        
        <!-- Informationsbox om nya regler -->
        <div class="alert alert-info">
            <h4>📋 Multi-klass schemaläggningsregler</h4>
            <ul style="margin: 0.5rem 0;">
                <li><strong>5-minutersintervall:</strong> Lektioner kan starta var 5:e minut för flexibilitet</li>
                <li><strong>10-minuters paus:</strong> Minst 10 minuter mellan alla lektioner</li>
                <li><strong>Max 1 ämne per dag per klass:</strong> Varje klass kan bara ha 1 lektion i samma ämne per dag</li>
                <li><strong>Ingen klassrumskonflikt:</strong> Samma klassrum kan inte användas samtidigt av flera klasser</li>
                <li><strong>Max 5 lektioner per ämne:</strong> Per vecka och klass (1 per dag × 5 dagar)</li>
            </ul>
        </div>





        <!-- Add a schedule management section before the main generator -->
        <div class="card" style="margin-bottom: 2rem;" id="scheduleManagement">
            <h3>📅 Schemahantering</h3>
            
            <div class="form-group">
                <label>Snabbåtgärder:</label>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem;">
                    <button type="button" class="btn" onclick="viewAllClassSchedules()" style="background: #4299e1;">
                        👁️ Visa alla klassers scheman
                    </button>
                    <button type="button" class="btn" onclick="exportSchedulesToCSV()" style="background: #38b2ac;">
                        📊 Exportera scheman
                    </button>
                    <button type="button" class="btn" onclick="showScheduleStatistics()" style="background: #9f7aea;">
                        📈 Schemastatistik
                    </button>
                </div>
            </div>
            
            <div id="scheduleOverview" style="margin-top: 1rem; display: none;">
                <!-- Schedule overview will be populated by JavaScript -->
            </div>
        </div>

        <div class="generator-layout">
            <!-- Vänster sida - Inställningar -->
            <div class="card">
                <h3>⚙️ Multi-klass Schemainställningar</h3>
                
                <form id="scheduleForm">
                    <!-- Klassval - Nu multi-select -->
                    <div class="form-group">
                        <label>Välj klasser (flera klasser tillåtet):</label>
                        <div class="classes-container" id="classesContainer">
                            {% if classes %}
                                {% for class in classes %}
                                    <div class="class-item">
                                        <input type="checkbox" name="class_ids[]" value="{{ class.id }}" id="class_{{ class.id }}" onchange="updateSelectedClasses()">
                                        <div class="class-item-info">
                                            <div class="class-name">{{ class.name }}</div>
                                            <div class="class-details">
                                                {{ class.users|length if class.users else 0 }} elever
                                                {% if class.year_level %} - Årskurs {{ class.year_level }}{% endif %}
                                            </div>
                                        </div>
                                        <div class="class-color-indicator" style="background-color: {{ loop.cycle('#4299e1', '#48bb78', '#f56565', '#ed8936', '#9f7aea', '#38b2ac') }};"></div>
                                    </div>
                                {% endfor %}
                            {% else %}
                                <div style="text-align: center; color: #666;">
                                    <p>Inga klasser tillgängliga</p>
                                </div>
                            {% endif %}
                        </div>
                        <div class="selected-classes-info" id="selectedClassesInfo" style="display: none;">
                            <strong>Valda klasser:</strong> <span id="selectedClassesList"></span>
                        </div>
                    </div>

                    <!-- Ämnen och timmar per klass -->
                    <div class="form-group">
                        <label>Ämnen och timmar per vecka (per klass):</label>
                        <div class="validation-warning" id="subjectValidation" style="display: none;">
                            <strong>⚠️ Viktigt:</strong> Varje ämne kan max ha 5 lektioner per vecka per klass (1 per dag).
                        </div>
                        <div class="subjects-container" id="subjectsContainer">
                            <div id="subjectsPlaceholder" style="color:#666;">
                                Välj en eller flera klasser till vänster för att ange ämnen och timmar per klass.
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Tillgängliga klassrum:</label>
                        <div class="rooms-container">
                            {% if school and school.classrooms %}
                                {% set classrooms = school.classrooms | from_json %}
                                {% for classroom in classrooms %}
                                    <div class="room-item">
                                        <input type="checkbox" name="rooms[]" value="{{ classroom }}" id="room_{{ loop.index }}" checked>
                                        <label for="room_{{ loop.index }}">{{ classroom }}</label>
                                    </div>
                                {% endfor %}
                            {% else %}
                                <!-- Fallback if no classrooms are defined -->
                                <div class="room-item">
                                    <input type="checkbox" name="rooms[]" value="Sal A" id="room_a" checked>
                                    <label for="room_a">Sal A</label>
                                </div>
                                <div class="room-item">
                                    <input type="checkbox" name="rooms[]" value="Sal B" id="room_b" checked>
                                    <label for="room_b">Sal B</label>
                                </div>
                                <div class="room-item">
                                    <input type="checkbox" name="rooms[]" value="Sal C" id="room_c" checked>
                                    <label for="room_c">Sal C</label>
                                </div>
                            {% endif %}
                        </div>
                    </div>

                    <!-- Tidsinställningar -->
                    <div class="form-group">
                        <label>Schema-begränsningar:</label>
                        <div class="constraints-section">
                            <div class="constraint-item">
                                <input type="checkbox" id="balanced_days" name="constraints[]" value="balanced_days" checked>
                                <label for="balanced_days">Jämn fördelning över veckan</label>
                            </div>
                            <div class="constraint-item">
                                <input type="checkbox" id="morning_priority" name="constraints[]" value="morning_priority">
                                <label for="morning_priority">Prioritera förmiddagstid</label>
                            </div>
                            <div class="constraint-item">
                                <input type="checkbox" id="no_room_conflicts" name="constraints[]" value="no_room_conflicts" checked disabled>
                                <label for="no_room_conflicts">Förhindra klassrumskonflikter (automatiskt aktivt)</label>
                            </div>
                            
                            <div style="margin-top: 1rem;">
                                <label>Skoldagens timmar:</label>
                                <div class="time-range">
                                    <input type="time" name="start_time" value="08:00">
                                    <input type="time" name="end_time" value="15:00">
                                </div>
                            </div>

                            <!-- Lektionslängd sektion -->
                            <div class="lesson-duration-section">
                                <label for="lesson_duration">Lektionslängd (minuter):</label>
                                <select name="lesson_duration" id="lesson_duration">
                                    <option value="45">45 minuter</option>
                                    <option value="60" selected>60 minuter</option>
                                    <option value="90">90 minuter</option>
                                </select>
                                <p style="font-size: 0.85rem; margin-top: 0.5rem; color: #666;">
                                    💡 Multi-klass schema med automatisk klassrumshantering.
                                </p>
                            </div>
                        </div>
                    </div>

                    <button type="button" class="btn btn-generate" onclick="generateMultiClassSchedule()">
                        🎲 Generera Multi-klass Schema
                    </button>
                </form>
                
                <!-- Debug info -->
                <div id="debugInfo" class="debug-info" style="display: none;">
                    <h4>Debug Information:</h4>
                    <div id="debugContent"></div>
                </div>
            </div>

            <!-- Höger sida - Schemaförhandsvisning -->
            <div class="card">
                <h3>📋 Multi-klass Schemaförhandsvisning</h3>

                <div style="display:flex; gap:0.75rem; align-items:center; margin-bottom:0.75rem;">
                    <label for="classFilter" style="margin:0; font-weight:600; color:#4a5568;">Visa:</label>
                    <select id="classFilter" onchange="onClassFilterChange()" style="padding:0.5rem; border-radius:6px; border:1px solid #e2e8f0;">
                        <option value="all">Alla klasser</option>
                        <!-- JS fyller resterande -->
                    </select>

                    <label for="teacherFilter" style="margin:0; font-weight:600; color:#4a5568;">Lärare:</label>
                    <select id="teacherFilter" onchange="onTeacherFilterChange()" style="padding:0.5rem; border-radius:6px; border:1px solid #e2e8f0;">
                        <option value="all">Alla lärare</option>
                        <!-- JS fyller resterande -->
                    </select>
                </div>




                
                <div class="schedule-preview" id="schedulePreview">
                    <div style="text-align: center;">
                        <p>Välj klasser och ämnen för att generera ett multi-klass schema</p>
                        <p style="color: #a0aec0; font-size: 0.9rem;">
                            Multi-klass schema följer:<br>
                            • Automatisk klassrumshantering<br>
                            • Max 1 ämne per dag per klass<br>
                            • 5-minutersintervall med 10-min paus
                        </p>
                    </div>
                </div>

                <div class="generation-controls" id="generationControls" style="display: none;">
                    <div class="schedule-actions">
                        <button type="button" class="btn" onclick="generateMultiClassSchedule()">
                            🔄 Generera nytt
                        </button>
                        <button type="button" class="btn" style="background: #48bb78;" onclick="saveMultiClassSchedule()">
                            💾 Spara schema
                        </button>
                        <button type="button" class="btn reset-schedule-btn" style="background: #f56565;" onclick="resetClassSchedules()">
                            🗑️ Rensa scheman
                        </button>
                    </div>
                    
                    <div id="saveStatus" class="save-status" style="display: none;">
                        <!-- Status information will be populated by JavaScript -->
                    </div>
                    
                    <div class="alert alert-info" style="margin-top: 1rem; font-size: 0.85rem;">
                        <strong>💡 Tips:</strong>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>Spara schema:</strong> Sparar schemat permanent till databasen</li>
                            <li><strong>Rensa scheman:</strong> Tar bort befintliga scheman för valda klasser</li>
                            <li><strong>Generera nytt:</strong> Skapar ett nytt schema (ersätter inte sparat schema)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
            let availableTeachers = {{ available_teachers | tojson | safe }} || [];

            let currentSchedule = null;
            let availableSubjects = {{ available_subjects | tojson }};
            let availableClasses = {{ classes | tojson }};
            let selectedClasses = [];


            let scheduleScrollContainer = null;
            let autoScrollInterval = null;
            let dragScrollBounds = null;

            let isEditMode = false;
            let editingClassId = null;
            let editingClassName = null;
            let originalScheduleData = null;
            let draggedLesson = null;


            let isDragging = false;

            document.addEventListener('dragstart', function(e) {
                if (e.target.classList.contains('draggable-lesson')) {
                    isDragging = true;
                    document.body.classList.add('dragging');
                    e.target.classList.add('dragging');
                }
            });

            document.addEventListener('dragend', function(e) {
                if (e.target.classList.contains('draggable-lesson')) {
                    isDragging = false;
                    document.body.classList.remove('dragging');
                    e.target.classList.remove('dragging');
                }
            });

            // Lägg högst upp (efter att serverdata injicerats)
            let schoolSubjects = (typeof availableSubjects !== 'undefined' && Array.isArray(availableSubjects))
                ? availableSubjects.slice()   // kopiera så vi inte muterar originalet oväntat
                : (window.schoolSubjects || []);

            // och lägg gärna tillbaka på window om andra moduler förväntar sig det
            window.schoolSubjects = schoolSubjects;
            // Class colors for visual distinction
            const classColors = ['#4299e1', '#48bb78', '#f56565', '#ed8936', '#9f7aea', '#38b2ac', '#ec407a', '#26c6da', '#ab47bc', '#66bb6a'];

            // Debug flag
            const DEBUG = true;

            function debugLog(message, data = null) {
                if (DEBUG) {
                    console.log(`[MULTI-CLASS SCHEDULE DEBUG] ${message}`, data);
                    
                    const debugInfo = document.getElementById('debugInfo');
                    const debugContent = document.getElementById('debugContent');
                    
                    debugInfo.style.display = 'block';
                    debugContent.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${message}</div>`;
                    if (data) {
                        debugContent.innerHTML += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                    }
                }
            }

            function updateSelectedClasses() {
                const checkboxes = document.querySelectorAll('input[name="class_ids[]"]:checked');
                const infoDiv = document.getElementById('selectedClassesInfo');
                const listSpan = document.getElementById('selectedClassesList');
                
                // Build selectedClasses anew
                const tempSelected = Array.from(checkboxes).map(cb => {
                    const classId = cb.value;
                    const classData = availableClasses.find(c => c.id == classId);
                    return {
                        id: classId,
                        name: classData ? classData.name : `Klass ${classId}`
                    };
                });

                selectedClasses = tempSelected;

                if (selectedClasses.length > 0) {
                    infoDiv.style.display = 'block';
                    listSpan.innerHTML = selectedClasses.map((cls, index) => 
                        `<span style="color: ${classColors[index % classColors.length]};">●</span> ${cls.name}`
                    ).join(', ');
                    debugLog('Selected classes updated:', selectedClasses);
                } else {
                    infoDiv.style.display = 'none';
                    debugLog('No classes selected');
                }

                // Re-render per-class subject sections
                renderClassSubjectSections();
            }


            // Fyll klass-filtret (finns redan i din kod om du följde tidigare steg)
            function populateClassFilter() {
                const sel = document.getElementById('classFilter');
                if (!sel) return;
                // Ta bort tidigare genererade options
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());
                availableClasses.forEach(cls => {
                    const opt = document.createElement('option');
                    opt.value = cls.id;
                    opt.textContent = cls.name;
                    opt.setAttribute('data-generated', '1');
                    sel.appendChild(opt);
                });
            }



            
            // JavaScript för ämneshantering - lägg till i <script>-sektionen


            


            function updateClassStatusIndicators(statusData) {
                // Update class checkboxes with status indicators
                selectedClasses.forEach(cls => {
                    const checkbox = document.getElementById(`class_${cls.id}`);
                    if (!checkbox) return;

                    const classItem = checkbox.closest('.class-item');
                    if (!classItem) return;

                    // Remove existing status indicators
                    const existingIndicator = classItem.querySelector('.schedule-status-indicator');
                    if (existingIndicator) existingIndicator.remove();

                    // Find class status
                    const status = statusData.classes_status.find(s => s.class_id == cls.id);
                    
                    if (status) {
                        const indicator = document.createElement('div');
                        indicator.className = 'schedule-status-indicator';
                        indicator.style.cssText = `
                            font-size: 0.75rem; 
                            margin-top: 0.25rem;
                            padding: 0.125rem 0.375rem;
                            border-radius: 0.25rem;
                            ${status.has_schedule ? 
                                'background: #c6f6d5; color: #22543d; border: 1px solid #9ae6b4;' : 
                                'background: #fed7d7; color: #742a2a; border: 1px solid #feb2b2;'
                            }
                        `;
                        
                        if (status.has_schedule) {
                            indicator.innerHTML = `✅ Schema sparat (${status.lesson_count} lektioner)`;
                        } else {
                            indicator.innerHTML = `📝 Inget sparat schema`;
                        }

                        const classDetails = classItem.querySelector('.class-details');
                        if (classDetails) {
                            classDetails.appendChild(indicator);
                        }
                    }
                });

                // Update summary info
                updateScheduleSummary(statusData.summary);
            }


            async function updateClassScheduleStatus() {
                if (selectedClasses.length === 0) return;

                try {
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: selectedClasses.map(c => parseInt(c.id))
                        })
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        // Update status cache
                        result.classes_status.forEach(cls => {
                            scheduleSaveState.classScheduleStatus[cls.class_id] = cls;
                        });

                        // Update UI indicators
                        updateClassStatusIndicators(result);
                        debugLog('Class schedule status updated:', result);
                    }

                } catch (error) {
                    console.error('Error updating class schedule status:', error);
                    debugLog('Status update failed:', error);
                }
            }


            async function addNewSubject() {
                const input = document.getElementById('newSubjectName');
                const subjectName = input.value.trim();
                
                if (!subjectName) {
                    alert('Ange ett ämnesnamn');
                    return;
                }
                
                try {
                    const response = await fetch('/api/school_subjects', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ name: subjectName })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        schoolSubjects.push(data.subject);
                        availableSubjects.push(data.subject); // Uppdatera även global variabel
                        input.value = '';
                        renderSubjects();
                        debugLog('Subject added successfully:', data.subject);
                    } else {
                        alert(data.error || 'Fel vid sparande av ämne');
                    }
                } catch (error) {
                    console.error('Error adding subject:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }

            async function removeSubject(subjectId) {
                if (!confirm('Är du säker på att du vill ta bort detta ämne?')) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/school_subjects/${subjectId}`, {
                        method: 'DELETE'
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        schoolSubjects = schoolSubjects.filter(s => s.id !== subjectId);
                        availableSubjects = availableSubjects.filter(s => s.id !== subjectId); // Uppdatera även global variabel
                        renderSubjects();
                        debugLog('Subject removed successfully:', subjectId);
                    } else {
                        alert(data.error || 'Fel vid borttagning av ämne');
                    }
                } catch (error) {
                    console.error('Error removing subject:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }



            function updateScheduleSummary(summary) {
                const infoDiv = document.getElementById('selectedClassesInfo');
                if (!infoDiv) return;

                // Add summary after class list
                let existingSummary = infoDiv.querySelector('.schedule-summary');
                if (existingSummary) existingSummary.remove();

                if (summary.total_classes > 0) {
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'schedule-summary';
                    summaryDiv.style.cssText = `
                        margin-top: 0.5rem; 
                        padding: 0.5rem; 
                        background: #f7fafc; 
                        border-radius: 0.375rem; 
                        font-size: 0.85rem;
                        border-left: 3px solid #4299e1;
                    `;

                    summaryDiv.innerHTML = `
                        <strong>📊 Schemastatus:</strong><br>
                        ${summary.classes_with_schedule}/${summary.total_classes} klasser har scheman (${summary.total_lessons} totalt lektioner)<br>
                        ${summary.all_classes_have_schedule ? 
                            '<span style="color: #38a169;">✅ Alla klasser har scheman</span>' : 
                            '<span style="color: #d69e2e;">⚠️ Vissa klasser saknar scheman</span>'
                        }
                    `;

                    infoDiv.appendChild(summaryDiv);
                }
            }

            /**
             * Update the overall schedule UI based on current state
             */
            function updateScheduleUI() {
                const controls = document.getElementById('generationControls');
                if (!controls) return;

                // Check if we have unsaved changes
                const hasUnsaved = scheduleSaveState.hasUnsavedChanges;
                
                // Update save button
                const saveButton = controls.querySelector('button[onclick="saveMultiClassSchedule()"]');
                if (saveButton) {
                    if (hasUnsaved) {
                        saveButton.style.background = '#ed8936';
                        saveButton.innerHTML = '💾 Spara (osparade ändringar)';
                    } else {
                        saveButton.style.background = '#48bb78';
                        saveButton.innerHTML = '💾 Sparat';
                    }
                }

                // Add reset button if it doesn't exist
                let resetButton = controls.querySelector('.reset-schedule-btn');
                if (!resetButton) {
                    resetButton = document.createElement('button');
                    resetButton.type = 'button';
                    resetButton.className = 'btn reset-schedule-btn';
                    resetButton.style.cssText = 'background: #f56565; margin-left: 0.5rem;';
                    resetButton.onclick = resetClassSchedules;
                    resetButton.innerHTML = '🗑️ Rensa scheman';
                    controls.appendChild(resetButton);
                }
            }


            function updateSubjectDropdowns() {
                const subjectSelects = document.querySelectorAll('select[name^="subjects_"]');
                subjectSelects.forEach(select => {
                    // spara nuvarande val (kan vara string eller number)
                    const currentValue = String(select.value);

                    // bygg options från schoolSubjects
                    let optionsHtml = '<option value="">Välj ämne...</option>';
                    schoolSubjects.forEach(subject => {
                    optionsHtml += `<option value="${subject.id}">${subject.name}</option>`;
                    });

                    select.innerHTML = optionsHtml;

                    // återställ tidigare värde (jämför som sträng för säkerhet)
                    if (currentValue) {
                    const optToSet = Array.from(select.options).find(o => String(o.value) === currentValue);
                    if (optToSet) select.value = currentValue;
                    }
                });
            }



            let scheduleSaveState = {
                hasUnsavedChanges: false,
                lastSavedSchedule: null,
                classScheduleStatus: {}
            };

            // Uppdatera createSubjectItem funktionen för att använda schoolSubjects
           

            // Initiera ämneslistan när sidan laddas
            document.addEventListener('DOMContentLoaded', function() {
                renderSubjects();
            });


            
            


            
                

            // Fyll lärar-filtret - försök med availableTeachers, annars lämna "Alla lärare" tills schemat finns
            function populateTeacherFilter() {
                const sel = document.getElementById('teacherFilter');
                if (!sel) return;
                // Rensa tidigare genererade
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());

                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                    availableTeachers.forEach(t => {
                        const opt = document.createElement('option');
                        opt.value = t.id ?? t.name;
                        opt.textContent = t.name ?? t.displayName ?? t.id;
                        opt.setAttribute('data-generated', '1');
                        sel.appendChild(opt);
                    });
                    return;
                }

                // Om inga lärardata finns ännu - lämna standard 'Alla lärare' (vi kommer att fylla från schedule senare)
            }

            // Fyll teacher-filter från ett genererat schema (används efter generering om backend ej skickade teachers)
            function populateTeacherFilterFromSchedule(schedule) {
                const sel = document.getElementById('teacherFilter');
                if (!sel || !schedule || !Array.isArray(schedule.lessons)) return;
                // Ta bort gamla genererade options
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());

                const teacherSet = new Map();
                schedule.lessons.forEach(lesson => {
                    // Förväntar att lesson har property lesson.teacher_name eller lesson.teacher_id
                    const teacherName = lesson.teacher_name || lesson.teacher || null;
                    const teacherId = lesson.teacher_id || lesson.teacher || teacherName;
                    if (teacherName) {
                        if (!teacherSet.has(teacherId)) teacherSet.set(teacherId, teacherName);
                    }
                });

                Array.from(teacherSet.entries()).forEach(([id, name]) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = name;
                    opt.setAttribute('data-generated', '1');
                    sel.appendChild(opt);
                });
            }

            // Händelsehanterare för filter
            function onClassFilterChange() {
                const classSel = document.getElementById('classFilter');
                const teacherSel = document.getElementById('teacherFilter');
                const classVal = classSel && classSel.value !== 'all' ? classSel.value : null;
                const teacherVal = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
                if (currentSchedule) displayMultiClassSchedule(currentSchedule, classVal, teacherVal);
            }

            function onTeacherFilterChange() {
                const classSel = document.getElementById('classFilter');
                const teacherSel = document.getElementById('teacherFilter');
                const classVal = classSel && classSel.value !== 'all' ? classSel.value : null;
                const teacherVal = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
                if (currentSchedule) displayMultiClassSchedule(currentSchedule, classVal, teacherVal);
            }

            // Efter att currentSchedule deklarerats:
            window.currentSchedule = window.currentSchedule || null;
            window.multiClassSchedule = window.multiClassSchedule || window.currentSchedule;

            // När du uppdaterar schemat, håll båda synkade:
            function setCurrentSchedule(schedule) {
            currentSchedule = schedule;
            window.currentSchedule = schedule;
            window.multiClassSchedule = schedule;
            }


            function renderClassSubjectSections() {
                const container = document.getElementById('subjectsContainer');
                const placeholder = document.getElementById('subjectsPlaceholder');
                container.innerHTML = ''; // clear

                if (selectedClasses.length === 0) {
                    placeholder && container.appendChild(placeholder);
                    return;
                }

                // For each selected class, create a section
                selectedClasses.forEach((cls, idx) => {
                    const section = document.createElement('div');
                    section.className = 'class-subject-section';
                    section.id = `class_subjects_${cls.id}`;
                    section.setAttribute('data-class-id', cls.id);

                    const header = document.createElement('div');
                    header.className = 'class-subject-header';
                    header.innerHTML = `
                        <div style="display:flex; align-items:center; gap:0.5rem;">
                            <span class="class-color-indicator" style="background:${classColors[idx % classColors.length]}"></span>
                            <strong>${cls.name}</strong>
                            <span style="color:#718096; font-size:0.9rem; margin-left:0.5rem;">(Ange ämnen & timmar för denna klass)</span>
                        </div>
                        <div>
                            <button type="button" class="add-subject-btn" onclick="addSubjectForClass('${cls.id}')">+ Lägg till ämne</button>
                        </div>
                    `;
                    section.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'class-subject-list';
                    list.id = `class_subject_list_${cls.id}`;

                    // Add initial subject row
                    const subjectRow = createSubjectItem(cls.id);
                    list.appendChild(subjectRow);

                    section.appendChild(list);
                    container.appendChild(section);
                });

                // Re-validate subjects UI
                validateSubjectHours();
            }



            function populateClassFilter() {
                const sel = document.getElementById('classFilter');
                if (!sel) return;
                // Rensa utom 'Alla'
                sel.querySelectorAll('option[data-generated]').forEach(o => o.remove());
                // Lägg till klasser från availableClasses
                availableClasses.forEach(cls => {
                    const opt = document.createElement('option');
                    opt.value = cls.id;
                    opt.textContent = cls.name;
                    opt.setAttribute('data-generated', '1');
                    sel.appendChild(opt);
                });
            }


            // Uppdatera renderSubjects funktionen för att inkludera lärarhantering
            function renderSubjects() {
                const container = document.getElementById('existingSubjects');
                const noMessage = document.getElementById('noSubjectsMessage');
                
                if (schoolSubjects.length === 0) {
                    noMessage.style.display = 'block';
                    container.innerHTML = '<div style="color: #666; text-align: center;" id="noSubjectsMessage">Inga ämnen ännu. Lägg till ämnen ovan.</div>';
                    return;
                }
                
                noMessage.style.display = 'none';
                
                let html = '';
                schoolSubjects.forEach(subject => {
                    html += `
                        <div class="subject-item" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: white; border-radius: 6px; margin-bottom: 0.5rem; border: 1px solid #e2e8f0;">
                            <div style="flex: 1;">
                                <div>
                                    <strong style="color: #2d3748;">${subject.name}</strong>
                                    <span id="teacherCount_${subject.id}" style="color: #718096; font-size: 0.85rem; margin-left: 0.5rem;">
                                        (Laddar lärare...)
                                    </span>
                                </div>
                                <div id="qualifiedTeachers_${subject.id}" style="margin-top: 0.25rem; font-size: 0.8rem; color: #4a5568;">
                                    <!-- Behöriga lärare visas här -->
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <button type="button" class="btn" onclick="manageTeachers(${subject.id}, '${subject.name}')" 
                                        style="background: #4299e1; color: white; padding: 0.375rem 0.75rem; font-size: 0.8rem;">
                                    👨‍🏫 Lärare
                                </button>
                                <button type="button" class="remove-subject-btn" onclick="removeSubject(${subject.id})" 
                                        style="background: #f56565; color: white; padding: 0.25rem 0.5rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                    Ta bort
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                
                // Ladda lärarbehörigheter för varje ämne
                schoolSubjects.forEach(subject => {
                    loadTeacherQualifications(subject.id);
                });
                
                // Uppdatera ämnesdropdowns i formuläret
                updateSubjectDropdowns();
            }

            // Ladda och visa behöriga lärare för ett ämne
            async function loadTeacherQualifications(subjectId) {
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const countSpan = document.getElementById(`teacherCount_${subjectId}`);
                        const teachersDiv = document.getElementById(`qualifiedTeachers_${subjectId}`);
                        
                        const qualifiedCount = data.qualified_teachers.length;
                        countSpan.textContent = `(${qualifiedCount} behörig${qualifiedCount !== 1 ? 'a' : ''} lärare)`;
                        countSpan.style.color = qualifiedCount > 0 ? '#38a169' : '#e53e3e';
                        
                        if (qualifiedCount > 0) {
                            const teacherNames = data.qualified_teachers.map(t => t.name).slice(0, 3);
                            let displayText = teacherNames.join(', ');
                            if (qualifiedCount > 3) {
                                displayText += ` +${qualifiedCount - 3} till`;
                            }
                            teachersDiv.innerHTML = `Behöriga: ${displayText}`;
                        } else {
                            teachersDiv.innerHTML = '<span style="color: #e53e3e;">⚠️ Inga behöriga lärare - schema kan inte genereras</span>';
                        }
                    }
                } catch (error) {
                    console.error('Error loading teacher qualifications:', error);
                    const countSpan = document.getElementById(`teacherCount_${subjectId}`);
                    if (countSpan) {
                        countSpan.textContent = '(Fel vid laddning)';
                        countSpan.style.color = '#e53e3e';
                    }
                }
            }


            function markScheduleAsUnsaved() {
                scheduleSaveState.hasUnsavedChanges = true;
                updateScheduleUI();
            }

            // Hantera lärare för ett ämne
            async function manageTeachers(subjectId, subjectName) {
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        alert('Fel vid laddning av lärardata');
                        return;
                    }
                    
                    const modalTitle = document.getElementById('modalTitle');
                    const modalContent = document.getElementById('modalContent');
                    
                    modalTitle.textContent = `Lärarbehörigheter för ${subjectName}`;
                    
                    let html = `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="color: #2d3748; margin-bottom: 0.75rem;">Behöriga lärare (${data.qualified_teachers.length})</h4>
                            <div id="qualifiedTeachersList" style="background: #f0fff4; border: 1px solid #38a169; border-radius: 6px; padding: 1rem; min-height: 60px;">
                    `;
                    
                    if (data.qualified_teachers.length > 0) {
                        data.qualified_teachers.forEach(teacher => {
                            html += `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: white; border-radius: 4px; margin-bottom: 0.5rem; border: 1px solid #c6f6d5;">
                                    <div>
                                        <strong>${teacher.name}</strong>
                                        <span style="color: #666; font-size: 0.9rem; margin-left: 0.5rem;">(${teacher.username})</span>
                                    </div>
                                    <button onclick="removeTeacherQualification(${subjectId}, ${teacher.id}, '${teacher.name}', '${subjectName}')" 
                                            style="background: #f56565; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">
                                        Ta bort
                                    </button>
                                </div>
                            `;
                        });
                    } else {
                        html += '<p style="color: #666; text-align: center; margin: 0;">Inga behöriga lärare ännu</p>';
                    }
                    
                    html += `
                            </div>
                        </div>
                        
                        <div>
                            <h4 style="color: #2d3748; margin-bottom: 0.75rem;">Lägg till behörig lärare</h4>
                            <div style="background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 1rem;">
                                <select id="teacherSelect" style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; margin-bottom: 1rem;">
                                    <option value="">Välj lärare...</option>
                    `;
                    
                    data.available_teachers.forEach(teacher => {
                        if (!teacher.is_qualified) {
                            html += `<option value="${teacher.id}">${teacher.name} (${teacher.username})</option>`;
                        }
                    });
                    
                    html += `
                                </select>
                                <button onclick="addTeacherQualification(${subjectId}, '${subjectName}')" 
                                        style="background: #48bb78; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                    + Lägg till behörighet
                                </button>
                            </div>
                        </div>
                    `;
                    
                    modalContent.innerHTML = html;
                    document.getElementById('teacherModal').style.display = 'block';
                    
                } catch (error) {
                    console.error('Error loading teachers:', error);
                    alert('Fel vid laddning av lärardata');
                }
            }

            // Lägg till lärarbehörighet
            async function addTeacherQualification(subjectId, subjectName) {
                const select = document.getElementById('teacherSelect');
                const teacherId = select.value;
                
                if (!teacherId) {
                    alert('Välj en lärare först');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ teacher_id: parseInt(teacherId) })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Stäng modal och uppdatera visning
                        closeTeacherModal();
                        loadTeacherQualifications(subjectId);
                        alert(data.message);
                    } else {
                        alert(data.error || 'Fel vid tillägg av behörighet');
                    }
                } catch (error) {
                    console.error('Error adding teacher qualification:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }



            // Ta bort lärarbehörighet
            async function removeTeacherQualification(subjectId, teacherId, teacherName, subjectName) {
                if (!confirm(`Är du säker på att du vill ta bort ${teacherName}s behörighet att undervisa i ${subjectName}?`)) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/teacher_qualifications/${subjectId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ teacher_id: teacherId })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Stäng modal och uppdatera visning
                        closeTeacherModal();
                        loadTeacherQualifications(subjectId);
                        alert(data.message);
                    } else {
                        alert(data.error || 'Fel vid borttagning av behörighet');
                    }
                } catch (error) {
                    console.error('Error removing teacher qualification:', error);
                    alert('Fel vid kommunikation med servern');
                }
            }

            function closeTeacherModal() {
                document.getElementById('teacherModal').style.display = 'none';
            }

            // Stäng modal vid klick utanför
            window.onclick = function(event) {
                const modal = document.getElementById('teacherModal');
                if (event.target === modal) {
                    closeTeacherModal();
                }
            }

            



            function createSubjectItem(classId, selectedSubjectId = '') {
                const item = document.createElement('div');
                item.className = 'subject-item';

                let optionsHtml = '<option value="">Välj ämne...</option>';
                schoolSubjects.forEach(subject => {
                    optionsHtml += `<option value="${subject.id}">${subject.name}</option>`;
                });

                item.innerHTML = `
                    <select name="subjects_${classId}[]" required onchange="validateSubjectHours()">
                    ${optionsHtml}
                    </select>
                    <input type="number" name="hours_${classId}[]" min="1" max="5" placeholder="Timmar/vecka (max 5)" required onchange="validateSubjectHours()">
                    <button type="button" class="remove-subject-btn" onclick="removeSubject(this)">Ta bort</button>
                `;

                // sätt valt ämne om det skickats in
                if (selectedSubjectId) {
                    item.querySelector('select').value = String(selectedSubjectId);
                }

                return item;
            }


            function getSubjectNameById(subjectId) {
                if (subjectId === null || subjectId === undefined) return null;
                const idStr = String(subjectId);

                // 1) Sök i schoolSubjects (primärt)
                const fromSchool = (Array.isArray(schoolSubjects) ? schoolSubjects : []).find(x => String(x.id) === idStr);
                if (fromSchool) return fromSchool.name;

                // 2) Sök i availableSubjects (fallback / äldre tabell)
                const fromAvailable = (Array.isArray(availableSubjects) ? availableSubjects : []).find(x => String(x.id) === idStr);
                if (fromAvailable) return fromAvailable.name;

                return null;
            }



    




            function addSubjectForClass(classId) {
                const list = document.getElementById(`class_subject_list_${classId}`);
                if (!list) return;
                const newRow = createSubjectItem(classId);
                list.appendChild(newRow);
                debugLog(`Added subject row for class ${classId}`);
            }

            function removeSubject(button) {
                const list = button.parentElement.parentElement; // .class-subject-list or just parent
                const sectionList = list.classList && list.classList.contains('class-subject-list') ? list : button.parentElement.parentElement;
                // Try to find the sibling rows to ensure at least one remains per class
                const container = button.closest('.class-subject-section');
                if (!container) return;
                const rows = container.querySelectorAll('.subject-item');
                if (rows.length > 1) {
                    button.parentElement.remove();
                    validateSubjectHours();
                    debugLog('Removed subject row', {classSection: container.id});
                } else {
                    // Don't allow removing last row
                    alert('Minst ett ämne måste finnas per klass. Lägg till ett annat ämne först om du vill ta bort detta.');
                    debugLog('Attempted to remove last subject row - blocked');
                }
            }

            function validateSubjectHours() {
                const allHourInputs = document.querySelectorAll('input[type="number"][name^="hours_"]');
                const validationWarning = document.getElementById('subjectValidation');
                let hasViolation = false;

                allHourInputs.forEach(input => {
                    const value = parseInt(input.value);
                    if (value > 5) {
                        hasViolation = true;
                        input.style.borderColor = '#e53e3e';
                        input.style.backgroundColor = '#fed7d7';
                    } else {
                        input.style.borderColor = '#e2e8f0';
                        input.style.backgroundColor = 'white';
                    }
                });

                if (hasViolation) {
                    validationWarning.style.display = 'block';
                } else {
                    validationWarning.style.display = 'none';
                }
            }

            function getAvailableRooms() {
                // Fallback om availableRooms inte är definierad
                if (typeof availableRooms !== 'undefined' && Array.isArray(availableRooms)) {
                    return availableRooms;
                }
                
                // Extrahera rum från DOM om de inte finns globalt
                const roomsFromDOM = new Set();
                document.querySelectorAll('.spanning-lesson').forEach(lessonEl => {
                    const room = lessonEl.dataset.room;
                    if (room && room !== 'Inget rum') {
                        roomsFromDOM.add(room);
                    }
                });
                
                // Lägg till några standard rum om inga hittades
                if (roomsFromDOM.size === 0) {
                    return ['Sal A', 'Sal B', 'Sal C', 'Sal D', 'Sal E'];
                }
                
                return Array.from(roomsFromDOM);
            }


            function mapSchoolSubjectToSubject(schoolSubjectId) {
                // This function should map from SchoolSubject ID to Subject ID
                // You'll need to implement the mapping logic based on your database structure
                
                // Option 1: If you have a direct mapping in your backend data
                // Look for a mapping table or field that connects SchoolSubject to Subject
                
                // Option 2: Match by name (if names are consistent)
                const schoolSubject = schoolSubjects.find(s => String(s.id) === String(schoolSubjectId));
                if (schoolSubject) {
                    // Look for matching subject in main subjects table by name
                    const matchingSubject = availableSubjects.find(s => s.name === schoolSubject.name);
                    if (matchingSubject) {
                        return matchingSubject.id;
                    }
                }
                
                // Option 3: Return the school subject ID if no mapping exists
                // (This assumes your backend can handle school_subject_ids in the subject_id field)
                return schoolSubjectId;
            }







            // --- Klistra in denna funktion i din scriptsektion (funktion-deklaration, alltså hoistas) ---
            function generateMultiClassScheduleWithConstraints(classes, classSubjectMap, rooms, startTime, endTime, lessonDuration) {
                debugLog('Generating multi-class schedule with teacher conflict prevention:', {
                    classes: classes.length, 
                    classSubjectMap, 
                    rooms: rooms.length, 
                    startTime, 
                    endTime, 
                    lessonDuration
                });

                const actualRooms = (rooms && rooms.length) ? rooms : getAvailableRooms();
                if (!actualRooms || actualRooms.length === 0) {
                    throw new Error('Inga klassrum valda. Välj minst ett klassrum.');
                }

                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                const timeSlots = generateTimeSlots(startTime || '08:00', endTime || '15:00', lessonDuration);
                const allLessons = [];

                // Create teacher availability tracker
                const teacherAvailability = {};
                const teacherMinBreak = 5; // 5 minutes minimum break between lessons
                
                // Initialize teacher availability structure
                if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                    availableTeachers.forEach(teacher => {
                        teacherAvailability[teacher.id] = {};
                        weekdays.forEach(day => {
                            teacherAvailability[teacher.id][day] = []; // Array of {start, end, lessonId} objects
                        });
                    });
                }

                // Create subject plans for each class
                const classSubjectPlans = {};
                let totalLessonsNeeded = 0;
                
                classes.forEach(classInfo => {
                    const cid = classInfo.id;
                    classSubjectPlans[cid] = [];

                    const items = classSubjectMap[cid] || [];
                    items.forEach(item => {
                        const subjectId = item.subject_id;
                        // sjökfunktion (lägg högst upp i filen om du inte redan har den)
                            function getSubjectNameById(subjectId) {
                            if (subjectId === null || subjectId === undefined) return null;
                            const s = (Array.isArray(schoolSubjects) ? schoolSubjects : []).find(x => String(x.id) === String(subjectId));
                            return s ? s.name : null;
                        }

                            // sedan här:
                        const subjectName = getSubjectNameById(subjectId) || (availableSubjects.find(s => String(s.id) === String(subjectId))?.name) || `Ämne ${subjectId}`;


                        const hoursPerWeek = parseInt(item.hours);

                        if (hoursPerWeek > 5) {
                            throw new Error(`Ämnet "${subjectName}" för klass ${classInfo.name} har ${hoursPerWeek} lektioner, men max 5 är tillåtet (1 per dag)`);
                        }

                        for (let h = 0; h < hoursPerWeek; h++) {
                            classSubjectPlans[cid].push({
                                class_id: classInfo.id,
                                class_name: classInfo.name,
                                subject_id: subjectId,
                                subject_name: subjectName,
                                color: classInfo.color || classColors[Math.floor(Math.random() * classColors.length)]
                            });
                            totalLessonsNeeded++;
                        }
                    });
                });

                // Global schedule structures for conflict management
                const globalSchedule = {};
                const roomOccupancy = {};
                const classSubjectsByDay = {};
                
                // Initialize structures
                weekdays.forEach(day => {
                    globalSchedule[day] = [];
                    roomOccupancy[day] = {};
                    classSubjectsByDay[day] = {};
                    
                    classes.forEach(classInfo => {
                        classSubjectsByDay[day][classInfo.id] = new Set();
                    });
                    
                    timeSlots.forEach(slot => {
                        roomOccupancy[day][slot] = new Set();
                    });
                });

                // Enhanced function to check teacher availability
                function isTeacherAvailable(teacherId, day, timeSlot, lessonDuration) {
                    if (!teacherAvailability[teacherId] || !teacherAvailability[teacherId][day]) {
                        return true; // If teacher tracking is not available, assume available
                    }

                    const [startTime, endTime] = timeSlot.split('-');
                    const startMinutes = timeToMinutes(startTime);
                    const endMinutes = timeToMinutes(endTime);

                    const teacherLessons = teacherAvailability[teacherId][day];

                    for (const lesson of teacherLessons) {
                        // Check for overlap or insufficient break time
                        if (!(endMinutes + teacherMinBreak <= lesson.start || 
                            startMinutes >= lesson.end + teacherMinBreak)) {
                            return false; // Conflict found
                        }
                    }

                    return true; // No conflicts
                }

                // Enhanced function to assign teacher to lesson
                // Enhanced function to assign teacher to lesson with subject qualification check
                // Fix 3: Improved teacher qualification checking
                function assignTeacherToLesson(lesson, day, timeSlot) {
                    const [startTime, endTime] = timeSlot.split('-');
                    const startMinutes = timeToMinutes(startTime);
                    const endMinutes = timeToMinutes(endTime);

                    if (typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0) {
                        // Filter teachers who are both available AND qualified for this subject
                        const qualifiedAndAvailableTeachers = availableTeachers.filter(teacher => {
                            // Check if teacher is available at this time
                            const isTimeAvailable = isTeacherAvailable(teacher.id, day, timeSlot, 60);
                            
                            // Check if teacher is qualified for this subject
                            let isQualified = true; // Default to true for backward compatibility
                            if (teacher.qualified_subjects && Array.isArray(teacher.qualified_subjects)) {
                                isQualified = teacher.qualified_subjects.includes(parseInt(lesson.subject_id));
                            }
                            
                            return isTimeAvailable && isQualified;
                        });

                        if (qualifiedAndAvailableTeachers.length > 0) {
                            const selectedTeacher = qualifiedAndAvailableTeachers[Math.floor(Math.random() * qualifiedAndAvailableTeachers.length)];
                            
                            // Reserve the teacher for this time slot
                            if (!teacherAvailability[selectedTeacher.id]) {
                                teacherAvailability[selectedTeacher.id] = {};
                            }
                            if (!teacherAvailability[selectedTeacher.id][day]) {
                                teacherAvailability[selectedTeacher.id][day] = [];
                            }

                            teacherAvailability[selectedTeacher.id][day].push({
                                start: startMinutes,
                                end: endMinutes,
                                lessonId: `${lesson.class_name}-${lesson.subject_name}-${timeSlot}`,
                                class: lesson.class_name,
                                subject: lesson.subject_name
                            });

                            return {
                                teacher_id: selectedTeacher.id,
                                teacher_name: selectedTeacher.name || selectedTeacher.username || 'Lärare'
                            };
                        } else {
                            // No qualified AND available teachers
                            debugLog(`No qualified teachers available for ${lesson.class_name} - ${lesson.subject_name} on ${day} at ${timeSlot}`);
                            return null;
                        }
                    } else {
                        // Fallback to generic teacher names if no teacher data available
                        const fallbackTeachers = ['Lärare A', 'Lärare B', 'Lärare C', 'Lärare D', 'Lärare E'];
                        return {
                            teacher_id: 'fallback',
                            teacher_name: fallbackTeachers[Math.floor(Math.random() * fallbackTeachers.length)]
                        };
                    }
                }

                // Place lessons for all classes with teacher availability checking
                const allLessonsToPlace = [];
                Object.keys(classSubjectPlans).forEach(classId => {
                    classSubjectPlans[classId].forEach(lesson => {
                        allLessonsToPlace.push(lesson);
                    });
                });

                // Randomize for better distribution
                allLessonsToPlace.sort(() => Math.random() - 0.5);

                debugLog('Starting lesson placement with teacher availability checking...', {totalLessons: allLessonsToPlace.length});

                let placedLessons = 0;
                let teacherConflicts = 0;

                for (const lesson of allLessonsToPlace) {
                    let placed = false;
                    let attempts = 0;
                    const maxAttempts = 300; // Increased attempts due to teacher constraints

                    while (!placed && attempts < maxAttempts) {
                        // Choose day that doesn't already have this subject for this class
                        const availableDays = weekdays.filter(day => 
                            !classSubjectsByDay[day][lesson.class_id].has(lesson.subject_name)
                        );
                        
                        if (availableDays.length === 0) {
                            throw new Error(`Kan inte placera fler lektioner i ${lesson.subject_name} för klass ${lesson.class_name} - alla dagar upptagna`);
                        }

                        // Prioritize days with fewer lessons for this class
                        availableDays.sort((a, b) => {
                            const aCount = globalSchedule[a].filter(l => l.class_id === lesson.class_id).length;
                            const bCount = globalSchedule[b].filter(l => l.class_id === lesson.class_id).length;
                            return aCount - bCount;
                        });
                        
                        const day = availableDays[0];

                        // Find available time slots for this class
                        const availableSlots = findAvailableTimeSlotsForClass(
                            globalSchedule[day], lesson.class_id, timeSlots, 10
                        );
                        
                        if (availableSlots.length > 0) {
                            // Try to find a slot with both room and teacher availability
                            let slotFound = false;
                            
                            for (const timeSlot of availableSlots) {
                                // Check room availability
                                const occupiedRooms = roomOccupancy[day][timeSlot];
                                const availableRooms = actualRooms.filter(room => !occupiedRooms.has(room));
                                
                                if (availableRooms.length > 0) {
                                    // Try to assign a teacher
                                    const teacherAssignment = assignTeacherToLesson(lesson, day, timeSlot);
                                    
                                    if (teacherAssignment) {
                                        const selectedRoom = availableRooms[Math.floor(Math.random() * availableRooms.length)];
                                        
                                        const lessonData = {
                                            day: day,
                                            time: timeSlot,
                                            class_id: lesson.class_id,
                                            class_name: lesson.class_name,
                                            // Skicka både för säkerhets skull — backend använder school_subject_id
                                            subject_id: lesson.subject_id || null,
                                            school_subject_id: lesson.school_subject_id || lesson.subject_id || null,
                                            subject_name: getSubjectNameById(lesson.subject_id) || lesson.subject_name || 'Okänt ämne',
                                            room: selectedRoom,
                                            teacher_id: teacherAssignment.teacher_id,
                                            teacher_name: teacherAssignment.teacher_name,
                                            color: lesson.color,
                                            start_minutes: timeToMinutes(timeSlot.split('-')[0])
                                        };



                                        // Place the lesson
                                        globalSchedule[day].push(lessonData);
                                        roomOccupancy[day][timeSlot].add(selectedRoom);
                                        classSubjectsByDay[day][lesson.class_id].add(lesson.subject_name);
                                        allLessons.push(lessonData);
                                        
                                        placed = true;
                                        placedLessons++;
                                        slotFound = true;

                                        debugLog(`Placed lesson ${placedLessons}/${allLessonsToPlace.length}: ${lesson.class_name} - ${lesson.subject_name} on ${day} at ${timeSlot} in ${selectedRoom} with ${teacherAssignment.teacher_name}`);
                                        break;
                                    } else {
                                        teacherConflicts++;
                                        debugLog(`Teacher conflict for ${lesson.class_name} - ${lesson.subject_name} on ${day} at ${timeSlot}`);
                                    }
                                }
                            }
                            
                            if (!slotFound) {
                                debugLog(`No available slots (room+teacher) for ${lesson.class_name} - ${lesson.subject_name} on ${day}`);
                            }
                        }

                        attempts++;
                    }

                    if (!placed) {
                        throw new Error(`Kunde inte placera lektion i ${lesson.subject_name} för klass ${lesson.class_name} efter ${maxAttempts} försök. Försök med fler lärare, klassrum eller färre klasser.`);
                    }
                }

                // Clean up helper data
                allLessons.forEach(lesson => {
                    delete lesson.start_minutes;
                });

                debugLog('Multi-class lesson placement completed with teacher management:', {
                    totalPlaced: placedLessons,
                    totalNeeded: allLessonsToPlace.length,
                    teacherConflicts: teacherConflicts
                });

                return {
                    lessons: allLessons,
                    time_slots: timeSlots,
                    classes: classes,
                    stats: {
                        total_lessons: allLessons.length,
                        lessons_per_class: classes.reduce((acc, cls) => {
                            acc[cls.name] = allLessons.filter(l => l.class_id === cls.id).length;
                            return acc;
                        }, {}),
                        rooms_used: [...new Set(allLessons.map(l => l.room))],
                        teachers_used: [...new Set(allLessons.map(l => l.teacher_name))],
                        balance_score: calculateMultiClassBalanceScore(globalSchedule, classes),
                        room_conflicts: checkRoomConflicts(allLessons),
                        teacher_conflicts: checkTeacherConflicts(allLessons),
                        constraint_violations: validateMultiClassConstraints(globalSchedule, classes),
                        teacher_conflict_attempts: teacherConflicts
                    }
                };
            }
            // --- Slut på funktionen ---


            // Fix 1: Remove duplicate function declaration
            async function generateMultiClassSchedule() {
                const preview = document.getElementById('schedulePreview');
                const controls = document.getElementById('generationControls');

                // Säkerställ att selectedClasses speglar DOM
                const checkedBoxes = Array.from(document.querySelectorAll('input[name="class_ids[]"]:checked'));
                if (checkedBoxes.length > 0) {
                    selectedClasses = checkedBoxes.map(cb => {
                        const classId = cb.value;
                        const classData = availableClasses.find(c => c.id == classId);
                        return {
                            id: classId,
                            name: classData ? classData.name : `Klass ${classId}`
                        };
                    });
                }

                if (selectedClasses.length === 0) {
                    alert('Välj minst en klass!');
                    debugLog('Validation failed: No classes selected');
                    return;
                }

                // Bygg per-klass ämneskartor
                const classSubjectMap = {};
                for (const cls of selectedClasses) {
                    const classId = cls.id;
                    const container = document.getElementById(`class_subjects_${classId}`);
                    if (!container) {
                        alert(`Ingen ämnessektion hittades för klass ${cls.name}.`);
                        debugLog('Validation failed: missing class subject container', {class: cls});
                        return;
                    }

                    const rows = Array.from(container.querySelectorAll('.subject-item'));
                    if (rows.length === 0) {
                        alert(`Ingen ämneskonfiguration för klass ${cls.name}. Ange minst ett ämne.`);
                        debugLog('Validation failed: No subject rows for class', {class: cls});
                        return;
                    }

                    const items = [];
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];
                        const subjSelect = row.querySelector('select');
                        const hourInput = row.querySelector('input[type="number"]');

                        const subjVal = subjSelect ? subjSelect.value.trim() : '';
                        const hrsValRaw = hourInput ? hourInput.value.trim() : '';
                        const hrsVal = hrsValRaw === '' ? NaN : parseInt(hrsValRaw, 10);

                        if (!subjVal) {
                            alert(`Välj ämne i alla rader för klass ${cls.name}`);
                            debugLog('Validation failed: empty subject row', {class: cls, index: i});
                            return;
                        }
                        if (isNaN(hrsVal) || hrsVal <= 0) {
                            alert(`Ange giltigt antal timmar för ämnet i klass ${cls.name}`);
                            debugLog('Validation failed: invalid hours', {class: cls, index: i, hours: hrsValRaw});
                            return;
                        }
                        if (hrsVal > 5) {
                            alert(`Max 5 lektioner per vecka per ämne. Du angav ${hrsVal} för ämnet i klass ${cls.name}`);
                            debugLog('Validation failed: hours > 5', {class: cls, hours: hrsVal});
                            return;
                        }

                        // Försök tolka valt värde som ett SchoolSubject-id
                        const schoolSubjectId = parseInt(subjVal, 10);

                        // Hämta namn från schoolSubjects (fallback: availableSubjects)
                        const subjectNameFromSchool = getSubjectNameById(schoolSubjectId);
                        const subjectNameFromAvailable = (availableSubjects||[]).find(s => String(s.id) === String(schoolSubjectId))?.name;
                        const resolvedSubjectName = subjectNameFromSchool || subjectNameFromAvailable || `Ämne ${schoolSubjectId}`;

                        // Push med både school_subject_id och subject_id (bakåtkompatibilitet)
                        items.push({
                            subject_id: schoolSubjectId,          // backend-fallback (tidigare fält)
                            school_subject_id: schoolSubjectId,   // uttryckligt school_subject id
                            subject_name: resolvedSubjectName,
                            hours: hrsVal
                        });

                        // Debug-logg (ta bort när det funkar)
                        debugLog('Added subject item', { classId, schoolSubjectId, resolvedSubjectName, hours: hrsVal });


                    }

                    classSubjectMap[classId] = items;
                }

                const rooms = getAvailableRooms();
                const maxSimultaneousClasses = selectedClasses.length;
                if (rooms.length < maxSimultaneousClasses) {
                    const proceed = confirm(
                        `Du har valt ${maxSimultaneousClasses} klasser men bara ${rooms.length} klassrum. ` +
                        `Detta kan orsaka schemaläggningsproblem när klasser har lektioner samtidigt. Fortsätt ändå?`
                    );
                    if (!proceed) {
                        debugLog('User cancelled due to insufficient rooms');
                        return;
                    }
                }

                debugLog('Multi-class validation passed, generating schedule...', {
                    classes: selectedClasses.length,
                    classSubjectMap,
                    rooms: rooms.length
                });

                // Visa loading
                preview.innerHTML = `
                    <div style="text-align: center;">
                        <div class="loading-spinner"></div>
                        <p style="margin-top: 1rem;">Genererar multi-klass schema...</p>
                        <p style="font-size: 0.9rem; color: #666;">
                            Schemaläggning för ${selectedClasses.length} klasser med klassrumshantering
                        </p>
                        <p style="font-size: 0.85rem; color: #888;">
                            Följer: Ingen klassrumskonflikt, max 1 ämne/dag per klass, 5-min intervall
                        </p>
                    </div>
                `;

                try {
                    const form = document.getElementById('scheduleForm');
                    const formData = new FormData(form);
                    const lessonDuration = parseInt(formData.get('lesson_duration') || '60');
                    const multiClassSchedule = generateMultiClassScheduleWithConstraints(
                        selectedClasses, classSubjectMap, rooms, 
                        formData.get('start_time'), formData.get('end_time'), lessonDuration
                    );

                    setTimeout(() => {
                        debugLog('Multi-class schedule generated successfully', multiClassSchedule);
                        currentSchedule = multiClassSchedule;
                        
                        // Fill teacher filter from schedule if not already available
                        if (!(typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0)) {
                            populateTeacherFilterFromSchedule(currentSchedule);
                        }
                        
                        // Display with current filters
                        const classSel = document.getElementById('classFilter');
                        const teacherSel = document.getElementById('teacherFilter');
                        const selectedClass = classSel && classSel.value !== 'all' ? classSel.value : null;
                        const selectedTeacher = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
                        
                        displayMultiClassSchedule(currentSchedule, selectedClass, selectedTeacher);
                        controls.style.display = 'flex';
                    }, 1000);

                } catch (error) {
                    debugLog('Error generating multi-class schedule:', error);
                    console.error('Error generating multi-class schedule:', error);
                    preview.innerHTML = `
                        <div style="text-align: center; color: #e53e3e;">
                            <p>❌ Fel vid multi-klass schemagenerering</p>
                            <p style="font-size: 0.9rem;">${error.message}</p>
                            <p style="font-size: 0.85rem; color: #666;">
                                Tips: Minska antalet lektioner, öka antalet klassrum, eller minska antalet klasser
                            </p>
                        </div>
                    `;
                    controls.style.display = 'none';
                }
            }

            // Fix 2: Ensure availableTeachers is properly initialized
            function initializeData() {
                // Make sure availableTeachers is defined
                if (typeof availableTeachers === 'undefined') {
                    availableTeachers = [];
                }
                
                // Make sure other global variables are properly initialized
                if (typeof availableSubjects === 'undefined') {
                    availableSubjects = [];
                }
                
                if (typeof availableClasses === 'undefined') {
                    availableClasses = [];
                }
                
                if (typeof schoolSubjects === 'undefined') {
                    schoolSubjects = availableSubjects || [];
                }
            }



            


            function findAvailableTimeSlotsForClass(daySchedule, classId, allTimeSlots, minBreakMinutes) {
                const availableSlots = [];
                const classLessons = daySchedule.filter(lesson => lesson.class_id === classId);
                
                for (const timeSlot of allTimeSlots) {
                    const [startTime, endTime] = timeSlot.split('-');
                    const startMinutes = timeToMinutes(startTime);
                    const endMinutes = timeToMinutes(endTime);
                    
                    let canPlace = true;
                    
                    // Kontrollera mot denna klass befintliga lektioner
                    for (const existingLesson of classLessons) {
                        const [existingStart, existingEnd] = existingLesson.time.split('-');
                        const existingStartMinutes = timeToMinutes(existingStart);
                        const existingEndMinutes = timeToMinutes(existingEnd);
                        
                        // Kontrollera överlappning och paus
                        if (!(endMinutes + minBreakMinutes <= existingStartMinutes || 
                            startMinutes >= existingEndMinutes + minBreakMinutes)) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        availableSlots.push(timeSlot);
                    }
                }
                
                return availableSlots;
            }


            function checkTeacherConflicts(lessons) {
                const conflicts = [];
                
                // Gruppera lektioner efter dag och tid
                const lessonsByDayTime = {};
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!lessonsByDayTime[key]) {
                        lessonsByDayTime[key] = [];
                    }
                    lessonsByDayTime[key].push(lesson);
                });
                
                // Kontrollera lärarkonflikter
                Object.keys(lessonsByDayTime).forEach(key => {
                    const timeLessons = lessonsByDayTime[key];
                    const teachersUsed = {};
                    
                    timeLessons.forEach(lesson => {
                        const teacherKey = lesson.teacher_id || lesson.teacher_name || lesson.teacher;
                        if (teacherKey && teachersUsed[teacherKey]) {
                            conflicts.push({
                                teacher: teacherKey,
                                time: key,
                                classes: [teachersUsed[teacherKey].class_name, lesson.class_name]
                            });
                        } else if (teacherKey) {
                            teachersUsed[teacherKey] = lesson;
                        }
                    });
                });
                
                return conflicts;
            }

            function checkRoomConflicts(lessons) {
                const conflicts = [];
                
                // Gruppera lektioner efter dag och tid
                const lessonsByDayTime = {};
                lessons.forEach(lesson => {
                    const key = `${lesson.day}-${lesson.time}`;
                    if (!lessonsByDayTime[key]) {
                        lessonsByDayTime[key] = [];
                    }
                    lessonsByDayTime[key].push(lesson);
                });
                
                // Kontrollera konflikter
                Object.keys(lessonsByDayTime).forEach(key => {
                    const timeLessons = lessonsByDayTime[key];
                    const roomsUsed = {};
                    
                    timeLessons.forEach(lesson => {
                        if (roomsUsed[lesson.room]) {
                            conflicts.push({
                                room: lesson.room,
                                time: key,
                                classes: [roomsUsed[lesson.room].class_name, lesson.class_name]
                            });
                        } else {
                            roomsUsed[lesson.room] = lesson;
                        }
                    });
                });
                
                return conflicts;
            }

            function calculateMultiClassBalanceScore(schedule, classes) {
                let totalBalance = 0;
                
                classes.forEach(classInfo => {
                    const dailyCounts = Object.keys(schedule).map(day => 
                        schedule[day].filter(lesson => lesson.class_id === classInfo.id).length
                    );
                    const max = Math.max(...dailyCounts);
                    const min = Math.min(...dailyCounts);
                    
                    const balance = max === 0 ? 100 : Math.round((1 - (max - min) / max) * 100);
                    totalBalance += balance;
                });
                
                return Math.round(totalBalance / classes.length);
            }

            function validateMultiClassConstraints(schedule, classes) {
                let violations = 0;
                
                classes.forEach(classInfo => {
                    Object.values(schedule).forEach(dayLessons => {
                        const classLessons = dayLessons.filter(l => l.class_id === classInfo.id);
                        const subjects = classLessons.map(l => l.subject_name);
                        const uniqueSubjects = new Set(subjects);
                        if (subjects.length !== uniqueSubjects.size) {
                            violations++;
                        }
                    });
                });
                
                return violations;
            }

            // classFilter: null eller classId
            // teacherFilter: null eller teacherId/name
            function escapeHtml(str) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
            function timeToMinutes(t) { const [hh, mm] = String(t).split(':').map(Number); return hh*60 + (mm||0); }

                // Robust display-funktion (ersätt befintlig)
            function displayMultiClassSchedule(schedule, classFilter = null, teacherFilter = null) {
                    const preview = document.getElementById('schedulePreview');
                    if (!preview) {
                        console.warn('displayMultiClassSchedule: schedulePreview saknas i DOM');
                        return;
                    }
                    if (!schedule || !Array.isArray(schedule.lessons)) {
                        preview.innerHTML = '<div style="text-align:center;color:#666;">Inget schema att visa</div>';
                        return;
                    }

                    // Bygg lessonMap per dag för snabbare uppslag
                    const lessonMap = {};
                    schedule.lessons.forEach(ls => {
                        // ls är säkert definierad här
                        const day = ls.day || 'okänd';
                        if (!lessonMap[day]) lessonMap[day] = [];
                        lessonMap[day].push(ls);
                    });

                    // times: använd schedule.time_slots om tillgänglig, annars fallback
                    const times = Array.isArray(schedule.time_slots) && schedule.time_slots.length > 0
                        ? schedule.time_slots.slice()
                        : (typeof generateTimeSlots === 'function' ? generateTimeSlots('08:00','15:00', 60) : ['08:00-09:00']);

                    const weekdays = ['måndag','tisdag','onsdag','torsdag','fredag'];

                    // Bygg HTML-tabell
                    let html = '<div style="overflow-x:auto;"><table class="schedule-table" style="width:100%; border-collapse:collapse;">';
                    html += '<thead><tr><th style="min-width:70px; text-align:left; padding:6px;">Tid</th>';
                    weekdays.forEach(d => html += `<th style="text-align:left; padding:6px;">${d.charAt(0).toUpperCase()+d.slice(1)}</th>`);
                    html += '</tr></thead><tbody>';

                    times.forEach(currentTime => {
                        html += `<tr><td style="padding:6px; font-weight:600; vertical-align:top;">${escapeHtml(currentTime)}</td>`;

                        weekdays.forEach(day => {
                        const dayLessons = lessonMap[day] || [];
                        // Hitta lektioner som täcker currentTime
                        const activeLessons = dayLessons.filter(l => {
                            if (!l.time) return false;
                            const parts = String(l.time).split('-');
                            if (parts.length !== 2) return false;
                            const start = parts[0].trim(), end = parts[1].trim();
                            const cur = timeToMinutes(currentTime.split('-')[0]);
                            return cur >= timeToMinutes(start) && cur < timeToMinutes(end);
                        });

                        if (activeLessons.length === 0) {
                            html += '<td class="empty-cell" style="padding:6px; color:#a0aec0;">-</td>';
                        } else {
                            // Skapa cellinnehåll för varje aktiv lektion (använd local variabel 'les' i map)
                            const cellContent = activeLessons.map(les => {
                            // säkra fält

                            // Försök i denna ordning: explicit subject_name -> lookup via school_subject_id -> lookup via subject_id -> fallback
                            const subjectLabel =
                                les.subject_name
                                || getSubjectNameById(les.school_subject_id)
                                || getSubjectNameById(les.subject_id)
                                || 'Okänt ämne';

                            const classLabel = les.class_name || les.class_id || '';
                            const room = les.room || '';
                            const teacher = les.teacher_name || les.teacher || '';
                            const color = les.color || '#9f7aea';

                            return `
                                <div style="margin-bottom:6px; padding:6px; border-left:4px solid ${escapeHtml(color)}; background: ${escapeHtml(color)}15; border-radius:6px;">
                                <div style="font-weight:700;">${escapeHtml(subjectLabel)}</div>
                                <div style="font-size:0.9rem; color:#4a5568;">${escapeHtml(classLabel)} • <span style="font-size:0.8rem; color:#718096">${escapeHtml(room)}</span></div>
                                ${teacher ? `<div style="font-size:0.85rem; color:#4a5568;">Lärare: ${escapeHtml(teacher)}</div>` : ''}
                                </div>
                            `;
                            }).join('');
                            html += `<td class="lesson-cell" style="padding:6px; vertical-align:top;">${cellContent}</td>`;
                        }
                        });

                        html += '</tr>';
                    });

                    html += '</tbody></table></div>';

                    preview.innerHTML = html;

                    // Visa generationControls (om vi har ett schema att visa)
                    const controls = document.getElementById('generationControls');
                    if (controls) controls.style.display = '';
                    
                    // Fyll teacher-filter om tomt
                    populateTeacherFilterFromSchedule(schedule);
            }


            document.addEventListener('DOMContentLoaded', function() {
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
            });

            document.addEventListener('DOMContentLoaded', function() {
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
                populateTeacherFilter();
            });

            document.addEventListener('DOMContentLoaded', function() {
                initializeData();
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
                populateTeacherFilter();
                renderSubjects();
            });




            // Efter att schemat skapats
            currentSchedule = multiClassSchedule;
            // Fyll teacher-filter från schemat om backend inte skickade teachers
            if (!(typeof availableTeachers !== 'undefined' && Array.isArray(availableTeachers) && availableTeachers.length > 0)) {
                populateTeacherFilterFromSchedule(currentSchedule);
            }
            // Rendera med eventuellt redan valt filter
            const classSel = document.getElementById('classFilter');
            const teacherSel = document.getElementById('teacherFilter');
            const selectedClass = classSel && classSel.value !== 'all' ? classSel.value : null;
            const selectedTeacher = teacherSel && teacherSel.value !== 'all' ? teacherSel.value : null;
            displayMultiClassSchedule(currentSchedule, selectedClass, selectedTeacher);
            controls.style.display = 'flex';




            

            function minutesToTime(minutes) {
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            }

            function generateTimeSlots(startTime, endTime, lessonDuration) {
                const slots = [];
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                
                let currentTime = startMinutes;
                
                while (currentTime + lessonDuration <= endMinutes) {
                    const slotStart = minutesToTime(currentTime);
                    const slotEnd = minutesToTime(currentTime + lessonDuration);
                    slots.push(`${slotStart}-${slotEnd}`);
                    
                    // In edit mode, use 5-minute intervals, in normal mode use lesson duration
                    currentTime += isEditMode ? 5 : lessonDuration;
                }
                
                return slots;
            }









            function hideScheduleOverview() {
                document.getElementById('scheduleOverview').style.display = 'none';
            }

            /**
             * View detailed schedule for a specific class
             */
            async function viewClassScheduleDetails(classId, className) {
                try {
                    debugLog(`Loading schedule details for class ${className} (${classId})`);
                    
                    const response = await fetch(`/api/class_schedule/status/${classId}`);
                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta schemadetaljer');
                    }

                    // Create modal to show schedule details
                    showClassScheduleModal(result);
                    
                } catch (error) {
                    console.error('Error loading class schedule details:', error);
                    alert(`Fel vid laddning av schemadetaljer: ${error.message}`);
                }
            }

            /**
             * Show class schedule in modal
             */
            function showClassScheduleModal(scheduleData) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 10000;
                    display: flex; align-items: center; justify-content: center;
                    overflow-y: auto; padding: 1rem;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; border-radius: 0.5rem; max-width: 800px; width: 100%;
                    max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                `;

                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                
                let scheduleHtml = `
                    <div style="padding: 1.5rem; border-bottom: 1px solid #e2e8f0;">
                        <h3 style="margin: 0; display: flex; justify-content: space-between; align-items: center;">
                            📅 Schema för ${scheduleData.class_name}
                            <button onclick="this.closest('[style*=position]').remove()" 
                                    style="background: #f56565; color: white; border: none; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer;">
                                ✕
                            </button>
                        </h3>
                        <p style="margin: 0.5rem 0 0 0; color: #666;">
                            Totalt ${scheduleData.lesson_count} lektioner per vecka
                        </p>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                `;

                if (scheduleData.has_schedule) {
                    scheduleHtml += `<div style="overflow-x: auto;"><table class="schedule-table" style="width: 100%; border-collapse: collapse;">`;
                    scheduleHtml += `<thead><tr style="background: #f7fafc;"><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Dag</th><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Tid</th><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Ämne</th><th style="padding: 0.75rem; border: 1px solid #e2e8f0;">Rum</th></tr></thead><tbody>`;

                    weekdays.forEach(day => {
                        const dayLessons = scheduleData.lessons_by_day[day] || [];
                        
                        if (dayLessons.length === 0) {
                            scheduleHtml += `
                                <tr>
                                    <td style="padding: 0.75rem; border: 1px solid #e2e8f0; font-weight: 600; text-transform: capitalize;">${day}</td>
                                    <td colspan="3" style="padding: 0.75rem; border: 1px solid #e2e8f0; color: #999; font-style: italic;">Inga lektioner</td>
                                </tr>
                            `;
                        } else {
                            dayLessons.forEach((lesson, index) => {
                                scheduleHtml += `
                                    <tr>
                                        ${index === 0 ? `<td rowspan="${dayLessons.length}" style="padding: 0.75rem; border: 1px solid #e2e8f0; font-weight: 600; text-transform: capitalize; vertical-align: top;">${day}</td>` : ''}
                                        <td style="padding: 0.75rem; border: 1px solid #e2e8f0; font-family: monospace;">${lesson.time}</td>
                                        <td style="padding: 0.75rem; border: 1px solid #e2e8f0;">${lesson.subject}</td>
                                        <td style="padding: 0.75rem; border: 1px solid #e2e8f0;">${lesson.room}</td>
                                    </tr>
                                `;
                            });
                        }
                    });

                    scheduleHtml += `</tbody></table></div>`;
                } else {
                    scheduleHtml += `<div style="text-align: center; color: #666; font-style: italic;">Inget schema har skapats för denna klass.</div>`;
                }

                scheduleHtml += `
                    </div>
                `;

                content.innerHTML = scheduleHtml;
                modal.appendChild(content);
                document.body.appendChild(modal);

                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            /**
             * Edit schedule for a specific class
             */
            async function editClassSchedule(classId, className) {
                try {
                    debugLog(`Starting edit mode for class ${className} (${classId})`);
                    
                    // Set edit mode state
                    isEditMode = true;
                    editingClassId = classId;
                    editingClassName = className;
                    
                    // Select only this class
                    document.querySelectorAll('input[name="class_ids[]"]').forEach(cb => {
                        cb.checked = cb.id === `class_${classId}`;
                    });
                    
                    // Update selected classes
                    updateSelectedClasses();
                    
                    // Load existing schedule data
                    const response = await fetch(`/api/class_schedule/status/${classId}`);
                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte ladda befintligt schema');
                    }
                    
                    if (!result.has_schedule) {
                        // No existing schedule - redirect to creation
                        alert(`Klass "${className}" har inget befintligt schema. Du kommer att skapa ett nytt schema istället.`);
                        isEditMode = false;
                        editingClassId = null;
                        editingClassName = null;
                        document.getElementById('scheduleForm').scrollIntoView({ behavior: 'smooth', block: 'start' });
                        return;
                    }
                    
                    // Store original data for potential rollback
                    originalScheduleData = result;
                    
                    // Enter edit mode UI
                    enterEditMode(result);
                    
                    // Display editable schedule
                    displayEditableSchedule(result);
                    
                    // Update controls
                    updateEditControls();
                    
                    // Show controls
                    document.getElementById('generationControls').style.display = 'flex';
                    
                    // Scroll to preview
                    document.getElementById('schedulePreview').scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // Hide overview if visible
                    const overview = document.getElementById('scheduleOverview');
                    if (overview && overview.style.display === 'block') {
                        hideScheduleOverview();
                    }
                    
                    debugLog('Edit mode entered successfully', { classId, className, lessonCount: result.lesson_count });
                    
                } catch (error) {
                    console.error('Error entering edit mode:', error);
                    
                    // Reset edit state on error
                    isEditMode = false;
                    editingClassId = null;
                    editingClassName = null;
                    originalScheduleData = null;
                    
                    handleApiError(error, 'redigering av schema');
                }
            }

            /**
             * Create schedule for a specific class
             */
            function createScheduleForClass(classId, className) {
                editClassSchedule(classId, className);
            }

            /**
             * Reset schedule for a single class
             */
            async function resetSingleClassSchedule(classId, className) {
                if (!confirm(`Är du säker på att du vill ta bort schemat för "${className}"?\n\nDetta kan inte ångras.`)) {
                    return;
                }

                try {
                    const response = await fetch(`/api/class_schedule/reset/${classId}`, {
                        method: 'DELETE'
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        alert(`✅ Schema för "${className}" har rensats.\n${result.deleted_lessons} lektioner togs bort.`);
                        
                        // Refresh overview
                        viewAllClassSchedules();
                    } else {
                        throw new Error(result.error || 'Okänt fel');
                    }

                } catch (error) {
                    console.error('Error resetting single class schedule:', error);
                    alert(`❌ Fel vid rensning av schema: ${error.message}`);
                }
            }

            /**
             * Export schedules to CSV
             */
            async function exportSchedulesToCSV() {
                try {
                    debugLog('Exporting schedules to CSV...');
                    
                    // Get all class schedules
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });

                    const result = await response.json();
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta scheman');
                    }

                    // Get detailed schedule data for classes with schedules
                    const classesWithSchedule = result.classes_status.filter(cls => cls.has_schedule);
                    
                    if (classesWithSchedule.length === 0) {
                        alert('Inga scheman att exportera');
                        return;
                    }

                    // Prepare CSV data
                    const csvRows = [];
                    csvRows.push(['Klass', 'Dag', 'Starttid', 'Sluttid', 'Ämne', 'Rum', 'Antal lektioner']);

                    // Get detailed data for each class
                    for (const cls of classesWithSchedule) {
                        const detailResponse = await fetch(`/api/class_schedule/status/${cls.class_id}`);
                        const detailResult = await detailResponse.json();
                        
                        if (detailResult.success && detailResult.lessons_by_day) {
                            Object.entries(detailResult.lessons_by_day).forEach(([day, lessons]) => {
                                lessons.forEach(lesson => {
                                    const [startTime, endTime] = lesson.time.split('-');
                                    csvRows.push([
                                        cls.class_name,
                                        day,
                                        startTime,
                                        endTime,
                                        lesson.subject,
                                        lesson.room,
                                        '1'
                                    ]);
                                });
                            });
                        }
                    }

                    // Generate CSV
                    const csvContent = csvRows.map(row => 
                        row.map(field => `"${field}"`).join(',')
                    ).join('\n');

                    // Download CSV
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `scheman_${new Date().toISOString().split('T')[0]}.csv`;
                    link.click();

                    debugLog('CSV export completed');
                    alert(`✅ Scheman exporterade!\n${csvRows.length - 1} lektioner från ${classesWithSchedule.length} klasser.`);

                } catch (error) {
                    console.error('Error exporting schedules:', error);
                    alert(`❌ Fel vid export: ${error.message}`);
                }
            }

            /**
             * Show schedule statistics
             */
            async function showScheduleStatistics() {
                try {
                    debugLog('Loading schedule statistics...');
                    
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });

                    const result = await response.json();
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta statistik');
                    }

                    // Calculate statistics
                    const stats = calculateScheduleStatistics(result);
                    
                    // Show statistics modal
                    showStatisticsModal(stats);
                    
                } catch (error) {
                    console.error('Error loading statistics:', error);
                    alert(`❌ Fel vid laddning av statistik: ${error.message}`);
                }
            }

            /**
             * Calculate schedule statistics
             */
            function calculateScheduleStatistics(statusData) {
                const { classes_status, summary } = statusData;
                
                const stats = {
                    total_classes: summary.total_classes,
                    classes_with_schedule: summary.classes_with_schedule,
                    total_lessons: summary.total_lessons,
                    avg_lessons_per_class: summary.classes_with_schedule > 0 ? 
                        (summary.total_lessons / summary.classes_with_schedule).toFixed(1) : 0,
                    schedule_coverage: summary.total_classes > 0 ? 
                        ((summary.classes_with_schedule / summary.total_classes) * 100).toFixed(1) : 0,
                    
                    lessons_by_class: {},
                    most_lessons: { class: null, count: 0 },
                    least_lessons: { class: null, count: Infinity },
                    
                    completion_rate: summary.all_classes_have_schedule ? 100 : 
                        (summary.classes_with_schedule / summary.total_classes * 100).toFixed(1)
                };
                
                // Analyze per class
                classes_status.forEach(cls => {
                    if (cls.has_schedule) {
                        stats.lessons_by_class[cls.class_name] = cls.lesson_count;
                        
                        if (cls.lesson_count > stats.most_lessons.count) {
                            stats.most_lessons = { class: cls.class_name, count: cls.lesson_count };
                        }
                        
                        if (cls.lesson_count < stats.least_lessons.count) {
                            stats.least_lessons = { class: cls.class_name, count: cls.lesson_count };
                        }
                    }
                });
                
                // Reset least if no classes have schedules
                if (stats.least_lessons.count === Infinity) {
                    stats.least_lessons = { class: null, count: 0 };
                }
                
                return stats;
            }

            /**
             * Show statistics modal
             */
            function showStatisticsModal(stats) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 10000;
                    display: flex; align-items: center; justify-content: center;
                    overflow-y: auto; padding: 1rem;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; border-radius: 0.5rem; max-width: 600px; width: 100%;
                    max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                `;

                let html = `
                    <div style="padding: 1.5rem; border-bottom: 1px solid #e2e8f0;">
                        <h3 style="margin: 0; display: flex; justify-content: space-between; align-items: center;">
                            📈 Schemastatistik
                            <button onclick="this.closest('[style*=position]').remove()" 
                                    style="background: #f56565; color: white; border: none; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer;">
                                ✕
                            </button>
                        </h3>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div style="text-align: center; padding: 1rem; background: #f0fff4; border-radius: 0.5rem; border: 1px solid #9ae6b4;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #22543d;">${stats.total_classes}</div>
                                <div style="color: #4a5568;">Totalt klasser</div>
                            </div>
                            
                            <div style="text-align: center; padding: 1rem; background: #ebf8ff; border-radius: 0.5rem; border: 1px solid #90cdf4;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #2a4365;">${stats.classes_with_schedule}</div>
                                <div style="color: #4a5568;">Med scheman</div>
                            </div>
                            
                            <div style="text-align: center; padding: 1rem; background: #fef5e7; border-radius: 0.5rem; border: 1px solid #f6ad55;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #744210;">${stats.total_lessons}</div>
                                <div style="color: #4a5568;">Totalt lektioner</div>
                            </div>
                            
                            <div style="text-align: center; padding: 1rem; background: #f7fafc; border-radius: 0.5rem; border: 1px solid #cbd5e0;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #2d3748;">${stats.avg_lessons_per_class}</div>
                                <div style="color: #4a5568;">⌀ per klass</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin-bottom: 0.75rem; color: #2d3748;">🎯 Schemaläggningsstatus</h4>
                            <div style="background: #f7fafc; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #4299e1;">
                                <div style="margin-bottom: 0.5rem;">
                                    <strong>Täckningsgrad:</strong> ${stats.schedule_coverage}% 
                                    (${stats.classes_with_schedule}/${stats.total_classes} klasser)
                                </div>
                                <div style="background: #e2e8f0; height: 0.5rem; border-radius: 0.25rem; overflow: hidden;">
                                    <div style="background: ${stats.completion_rate == 100 ? '#38a169' : stats.completion_rate > 50 ? '#ed8936' : '#f56565'}; 
                                                height: 100%; width: ${stats.completion_rate}%; transition: width 0.3s ease;"></div>
                                </div>
                            </div>
                        </div>
                `;

                if (Object.keys(stats.lessons_by_class).length > 0) {
                    html += `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin-bottom: 0.75rem; color: #2d3748;">📊 Lektioner per klass</h4>
                            <div style="max-height: 200px; overflow-y: auto; background: #f7fafc; padding: 1rem; border-radius: 0.5rem;">
                    `;

                    Object.entries(stats.lessons_by_class)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([className, lessonCount]) => {
                            const percentage = (lessonCount / Math.max(...Object.values(stats.lessons_by_class))) * 100;
                            html += `
                                <div style="margin-bottom: 0.75rem;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                        <span>${className}</span>
                                        <strong>${lessonCount} lektioner</strong>
                                    </div>
                                    <div style="background: #e2e8f0; height: 0.25rem; border-radius: 0.125rem; overflow: hidden;">
                                        <div style="background: #4299e1; height: 100%; width: ${percentage}%; transition: width 0.3s ease;"></div>
                                    </div>
                                </div>
                            `;
                        });

                    html += `</div></div>`;

                    if (stats.most_lessons.class && stats.least_lessons.class) {
                        html += `
                            <div>
                                <h4 style="margin-bottom: 0.75rem; color: #2d3748;">🏆 Extremvärden</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div style="background: #c6f6d5; padding: 1rem; border-radius: 0.5rem; border: 1px solid #9ae6b4;">
                                        <div style="font-weight: bold; color: #22543d;">Mest lektioner</div>
                                        <div>${stats.most_lessons.class}</div>
                                        <div style="font-size: 1.2rem; font-weight: bold; color: #22543d;">${stats.most_lessons.count} lektioner</div>
                                    </div>
                                    <div style="background: #fed7d7; padding: 1rem; border-radius: 0.5rem; border: 1px solid #feb2b2;">
                                        <div style="font-weight: bold; color: #742a2a;">Minst lektioner</div>
                                        <div>${stats.least_lessons.class}</div>
                                        <div style="font-size: 1.2rem; font-weight: bold; color: #742a2a;">${stats.least_lessons.count} lektioner</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }

                html += `
                        <div style="text-align: center; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e2e8f0;">
                            <div style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                                Statistik genererad: ${new Date().toLocaleString('sv-SE')}
                            </div>
                            <button type="button" class="btn" onclick="exportStatisticsReport()" style="background: #48bb78; margin-right: 0.5rem;">
                                📊 Exportera rapport
                            </button>
                            <button type="button" class="btn" onclick="this.closest('[style*=position]').remove()" style="background: #718096;">
                                Stäng
                            </button>
                        </div>
                    </div>
                `;

                content.innerHTML = html;
                modal.appendChild(content);
                document.body.appendChild(modal);

                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                // Store stats globally for export
                window.currentScheduleStats = stats;
            }

            /**
             * Export statistics report
             */
            function exportStatisticsReport() {
                if (!window.currentScheduleStats) {
                    alert('Ingen statistik att exportera');
                    return;
                }

                const stats = window.currentScheduleStats;
                const timestamp = new Date().toLocaleString('sv-SE');
                
                let report = `SCHEMASTATISTIK RAPPORT\n`;
                report += `Genererad: ${timestamp}\n`;
                report += `${'='.repeat(50)}\n\n`;
                
                report += `ÖVERSIKT:\n`;
                report += `- Totalt klasser: ${stats.total_classes}\n`;
                report += `- Klasser med scheman: ${stats.classes_with_schedule}\n`;
                report += `- Totalt lektioner: ${stats.total_lessons}\n`;
                report += `- Genomsnitt lektioner per klass: ${stats.avg_lessons_per_class}\n`;
                report += `- Schematäckningsgrad: ${stats.schedule_coverage}%\n\n`;
                
                if (Object.keys(stats.lessons_by_class).length > 0) {
                    report += `LEKTIONER PER KLASS:\n`;
                    Object.entries(stats.lessons_by_class)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([className, lessonCount]) => {
                            report += `- ${className}: ${lessonCount} lektioner\n`;
                        });
                    report += `\n`;
                    
                    if (stats.most_lessons.class && stats.least_lessons.class) {
                        report += `EXTREMVÄRDEN:\n`;
                        report += `- Mest lektioner: ${stats.most_lessons.class} (${stats.most_lessons.count} lektioner)\n`;
                        report += `- Minst lektioner: ${stats.least_lessons.class} (${stats.least_lessons.count} lektioner)\n\n`;
                    }
                }
                
                report += `REKOMMENDATIONER:\n`;
                if (stats.completion_rate < 100) {
                    report += `- ${stats.total_classes - stats.classes_with_schedule} klasser saknar scheman\n`;
                }
                if (stats.most_lessons.count > stats.least_lessons.count + 5) {
                    report += `- Överväg att balansera lektioner mellan klasser\n`;
                }
                if (stats.completion_rate == 100) {
                    report += `- Alla klasser har scheman - bra jobbat!\n`;
                }

                // Create and download report
                const blob = new Blob([report], { type: 'text/plain;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `schemastatistik_${new Date().toISOString().split('T')[0]}.txt`;
                link.click();

                debugLog('Statistics report exported');
            }

            /**
             * Enhanced initialization function
             */
            function initializeScheduleManagement() {
                // Initialize data
                initializeData();
                
                // Setup auto-save detection
                let scheduleChangeDetected = false;
                
                // Monitor for schedule changes
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.target.id === 'schedulePreview' && currentSchedule) {
                            if (!scheduleChangeDetected) {
                                scheduleChangeDetected = true;
                                markScheduleAsUnsaved();
                            }
                        }
                    });
                });
                
                const previewElement = document.getElementById('schedulePreview');
                if (previewElement) {
                    observer.observe(previewElement, {
                        childList: true,
                        subtree: true
                    });
                }
                
                // Auto-update status periodically
                setInterval(() => {
                    if (selectedClasses.length > 0) {
                        updateClassScheduleStatus();
                    }
                }, 30000); // Every 30 seconds
                
                debugLog('Schedule management initialized');
            }

            /**
             * Enhanced error handling for API calls
             */
            function handleApiError(error, context = '') {
                console.error(`API Error ${context}:`, error);
                
                let userMessage = 'Ett fel uppstod';
                if (context) userMessage += ` vid ${context}`;
                
                if (error.message.includes('Unauthorized') || error.message.includes('403')) {
                    userMessage += '.\n\nDu har inte behörighet för denna åtgärd.';
                } else if (error.message.includes('Not Found') || error.message.includes('404')) {
                    userMessage += '.\n\nData hittades inte. Sidan kan behöva laddas om.';
                } else if (error.message.includes('500')) {
                    userMessage += '.\n\nServerfel. Försök igen senare.';
                } else {
                    userMessage += `.\n\nDetaljer: ${error.message}`;
                }
                
                alert(`❌ ${userMessage}`);
                debugLog(`Error handled for ${context}:`, error);
            }

            /**
             * Utility function to format time strings
             */
            function formatTimeRange(timeRange) {
                if (!timeRange || !timeRange.includes('-')) return timeRange;
                
                const [start, end] = timeRange.split('-');
                return `${start}–${end}`;
            }

            /**
             * Utility function to get class color by ID
             */
            function getClassColorById(classId) {
                const classIndex = availableClasses.findIndex(c => c.id == classId);
                return classIndex >= 0 ? classColors[classIndex % classColors.length] : '#718096';
            }

            /**
             * Debounce function for API calls
             */
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Debounced version of updateClassScheduleStatus
            const debouncedUpdateStatus = debounce(updateClassScheduleStatus, 500);

            // Override the existing DOMContentLoaded handler
            document.addEventListener('DOMContentLoaded', function() {
                // Call original initialization
                initializeData();
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
                populateClassFilter();
                populateTeacherFilter();
                renderSubjects();
                
                // Initialize schedule management
                initializeScheduleManagement();
                
                // Add keyboard shortcuts
                document.addEventListener('keydown', function(e) {
                    // Ctrl+S to save
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        if (currentSchedule) {
                            saveMultiClassSchedule();
                        }
                    }
                    
                    // Ctrl+R to reset (with confirmation)
                    if (e.ctrlKey && e.key === 'r' && selectedClasses.length > 0) {
                        e.preventDefault();
                        resetClassSchedules();
                    }
                    
                    // Ctrl+G to generate
                    if (e.ctrlKey && e.key === 'g') {
                        e.preventDefault();
                        generateMultiClassSchedule();
                    }
                });
                
                debugLog('Enhanced schedule management loaded with keyboard shortcuts');
            });
    



            function displayAllClassSchedules(statusData) {
                const overviewDiv = document.getElementById('scheduleOverview');
                const { classes_status, summary } = statusData;

                let html = `
                    <div class="schedule-overview-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 0.5rem;">
                        <h4 style="margin: 0;">📊 Översikt - Alla klasser</h4>
                        <div style="text-align: right; font-size: 0.9rem;">
                            <div><strong>${summary.classes_with_schedule}/${summary.total_classes}</strong> klasser har scheman</div>
                            <div style="color: #666;"><strong>${summary.total_lessons}</strong> totalt lektioner</div>
                        </div>
                    </div>

                    <div class="classes-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">
                `;

                classes_status.forEach((cls, index) => {
                    const classColor = classColors[index % classColors.length];
                    const statusColor = cls.has_schedule ? '#38a169' : '#e53e3e';
                    const statusIcon = cls.has_schedule ? '✅' : '❌';
                    const statusText = cls.has_schedule ? 'Schema sparat' : 'Inget schema';

                    html += `
                        <div class="class-schedule-card" style="border: 2px solid ${classColor}; border-radius: 0.5rem; padding: 1rem; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                <h5 style="margin: 0; color: ${classColor};">${cls.class_name}</h5>
                                <span style="color: ${statusColor}; font-weight: 600;">${statusIcon} ${statusText}</span>
                            </div>
                            
                            ${cls.has_schedule ? `
                                <div style="margin-bottom: 0.75rem;">
                                    <div style="font-size: 0.9rem; color: #4a5568;">
                                        📚 <strong>${cls.lesson_count}</strong> lektioner per vecka
                                    </div>
                                </div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <button type="button" class="btn" onclick="viewClassScheduleDetails(${cls.class_id}, '${cls.class_name}')" 
                                            style="background: #4299e1; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                        👁️ Visa
                                    </button>
                                    <button type="button" class="btn" onclick="editClassSchedule(${cls.class_id}, '${cls.class_name}')" 
                                            style="background: #ed8936; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                        ✏️ Redigera
                                    </button>
                                    <button type="button" class="btn" onclick="resetSingleClassSchedule(${cls.class_id}, '${cls.class_name}')" 
                                            style="background: #f56565; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                        🗑️ Rensa
                                    </button>
                                </div>
                            ` : `
                                <div style="color: #666; font-style: italic; margin-bottom: 0.75rem;">
                                    Inget schema har skapats för denna klass än.
                                </div>
                                <button type="button" class="btn" onclick="createScheduleForClass(${cls.class_id}, '${cls.class_name}')" 
                                        style="background: #48bb78; font-size: 0.8rem; padding: 0.25rem 0.5rem;">
                                    ➕ Skapa schema
                                </button>
                            `}
                        </div>
                    `;
                });

                html += `
                    </div>
                    
                    <div style="text-align: center; margin-top: 1.5rem;">
                        <button type="button" class="btn" onclick="hideScheduleOverview()" style="background: #718096;">
                            ⬆️ Dölj översikt
                        </button>
                    </div>
                `;

                overviewDiv.innerHTML = html;
                debugLog('All class schedules displayed');
            }




            async function viewAllClassSchedules() {
                try {
                    debugLog('Loading all class schedules...');
                    
                    // Show loading state
                    const overviewDiv = document.getElementById('scheduleOverview');
                    overviewDiv.style.display = 'block';
                    overviewDiv.innerHTML = '<div style="text-align: center;"><div class="loading-spinner"></div><p>Laddar scheman...</p></div>';

                    // Get status for all classes in school
                    const allClassIds = availableClasses.map(c => c.id);
                    const response = await fetch('/api/multi_class_schedule/status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            class_ids: allClassIds
                        })
                    });

                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte hämta scheman');
                    }

                    // Display overview
                    displayAllClassSchedules(result);
                    
                } catch (error) {
                    console.error('Error loading all schedules:', error);
                    const overviewDiv = document.getElementById('scheduleOverview');
                    overviewDiv.innerHTML = `<div style="color: #e53e3e; text-align: center;">Fel vid laddning: ${error.message}</div>`;
                }
            }




            async function resetClassSchedules() {
                if (selectedClasses.length === 0) {
                    alert('Inga klasser valda för rensning');
                    return;
                }

                // Check which classes have existing schedules
                const classesWithSchedule = [];
                const classesWithoutSchedule = [];
                
                for (const cls of selectedClasses) {
                    const status = scheduleSaveState.classScheduleStatus[cls.id];
                    if (status && status.has_schedule) {
                        classesWithSchedule.push(cls);
                    } else {
                        classesWithoutSchedule.push(cls);
                    }
                }

                if (classesWithSchedule.length === 0) {
                    alert('Inga av de valda klasserna har befintliga scheman att rensa');
                    return;
                }

                // Confirm reset
                let confirmMessage = `⚠️ VARNING: Detta kommer att permanent ta bort scheman för:\n\n`;
                classesWithSchedule.forEach(cls => {
                    const status = scheduleSaveState.classScheduleStatus[cls.id];
                    confirmMessage += `• ${cls.name} (${status ? status.lesson_count : '?'} lektioner)\n`;
                });
                
                if (classesWithoutSchedule.length > 0) {
                    confirmMessage += `\nFöljande klasser har inga befintliga scheman:\n`;
                    classesWithoutSchedule.forEach(cls => confirmMessage += `• ${cls.name}\n`);
                }
                
                confirmMessage += `\nÄr du säker på att du vill fortsätta?`;

                if (!confirm(confirmMessage)) {
                    debugLog('Reset cancelled by user');
                    return;
                }

                try {
                    debugLog('Resetting class schedules...', {classes: classesWithSchedule.map(c => c.name)});

                    let totalDeleted = 0;
                    let resetResults = [];

                    // Reset each class individually
                    for (const cls of classesWithSchedule) {
                        const response = await fetch(`/api/class_schedule/reset/${cls.id}`, {
                            method: 'DELETE'
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            totalDeleted += result.deleted_lessons;
                            resetResults.push(`${cls.name}: ${result.deleted_lessons} lektioner`);
                            debugLog(`Reset successful for class ${cls.name}:`, result);
                        } else {
                            throw new Error(`Fel för ${cls.name}: ${result.error}`);
                        }
                    }

                    // Clear current schedule if it was for the reset classes
                    currentSchedule = null;
                    const preview = document.getElementById('schedulePreview');
                    preview.innerHTML = `
                        <div style="text-align: center; color: #38a169;">
                            <h3>✅ Scheman rensade framgångsrikt</h3>
                            <p><strong>Totalt ${totalDeleted} lektioner borttagna</strong></p>
                            <div style="margin-top: 1rem; text-align: left; display: inline-block;">
                                ${resetResults.map(r => `<div>📚 ${r}</div>`).join('')}
                            </div>
                            <p style="margin-top: 1.5rem;">Generera ett nytt schema för att fortsätta.</p>
                        </div>
                    `;

                    // Hide generation controls
                    const controls = document.getElementById('generationControls');
                    if (controls) controls.style.display = 'none';

                    // Update status
                    await updateClassScheduleStatus();
                    
                    // Update save state
                    scheduleSaveState.hasUnsavedChanges = false;
                    scheduleSaveState.lastSavedSchedule = null;

                    showSuccessMessage(`✅ Scheman rensade framgångsrikt!\n\n${totalDeleted} lektioner borttagna från ${classesWithSchedule.length} klass${classesWithSchedule.length !== 1 ? 'er' : ''}.`);

                } catch (error) {
                    console.error('Error resetting schedules:', error);
                    alert(`❌ Fel vid rensning av scheman:\n${error.message}`);
                    debugLog('Reset failed:', error);
                }
            }


            function showSuccessMessage(message) {
                // Create simple success modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.5); z-index: 10000; 
                    display: flex; align-items: center; justify-content: center;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; padding: 2rem; border-radius: 0.5rem; 
                    max-width: 500px; margin: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                `;

                content.innerHTML = `
                    <div style="text-align: center;">
                        <div style="white-space: pre-line; margin-bottom: 1.5rem;">${message}</div>
                        <button onclick="this.closest('[style*=position]').remove()" 
                                style="background: #48bb78; color: white; padding: 0.5rem 1.5rem; 
                                    border: none; border-radius: 0.375rem; cursor: pointer;">
                            OK
                        </button>
                    </div>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (modal.parentNode) modal.remove();
                }, 5000);
            }


            document.addEventListener('DOMContentLoaded', function() {
                // Add event listener for page unload to warn about unsaved changes
                window.addEventListener('beforeunload', function(e) {
                    if (scheduleSaveState.hasUnsavedChanges) {
                        const message = 'Du har osparade ändringar i schemat. Är du säker på att du vill lämna sidan?';
                        e.returnValue = message;
                        return message;
                    }
                });
                
                // Update status after initial load
                setTimeout(() => {
                    if (selectedClasses.length > 0) {
                        updateClassScheduleStatus();
                    }
                }, 500);
            });


            const originalUpdateSelectedClasses = updateSelectedClasses;
            updateSelectedClasses = function() {
                // Call original function
                originalUpdateSelectedClasses();
                
                // Update status for newly selected classes
                setTimeout(() => {
                    updateClassScheduleStatus();
                }, 100);
            };



            const originalGenerateMultiClassSchedule = generateMultiClassSchedule;
            generateMultiClassSchedule = async function() {
                // Call original function
                await originalGenerateMultiClassSchedule();
                
                // Mark as having unsaved changes if generation was successful
                if (currentSchedule) {
                    markScheduleAsUnsaved();
                    await updateClassScheduleStatus();
                }
            };



            

            /**
             * Enter edit mode UI state
             */
            function enterEditMode(scheduleData) {
                // Update header to show edit mode
                
                
                // Hide class selection (already selected)
                const classContainer = document.getElementById('classesContainer');
                if (classContainer) {
                    classContainer.style.opacity = '0.5';
                    classContainer.style.pointerEvents = 'none';
                }
                
                // Disable subject configuration
                const subjectsContainer = document.getElementById('subjectsContainer');
                if (subjectsContainer) {
                    subjectsContainer.innerHTML = `
                        <div style="padding: 1rem; background: #f7fafc; border-radius: 0.5rem; border: 1px solid #e2e8f0; text-align: center; color: #4a5568;">
                            <strong>Redigeringsläge:</strong> Ämnen och timmar bestäms av befintligt schema
                        </div>
                    `;
                }
            }

            /**
             * Exit edit mode and return to normal state
             */
            function exitEditMode() {
                isEditMode = false;
                editingClassId = null;
                editingClassName = null;
                originalScheduleData = null;
                
                // Remove edit header
                const editHeader = document.getElementById('editModeHeader');
                if (editHeader) editHeader.remove();
                
                // Restore UI elements
                const classContainer = document.getElementById('classesContainer');
                if (classContainer) {
                    classContainer.style.opacity = '1';
                    classContainer.style.pointerEvents = 'auto';
                }
                
                // Restore subject configuration
                renderClassSubjectSections();
                
                // Clear preview
                const preview = document.getElementById('schedulePreview');
                preview.innerHTML = `
                    <div style="text-align: center;">
                        <p>Välj klasser och ämnen för att generera ett multi-klass schema</p>
                    </div>
                `;
                
                // Hide controls
                document.getElementById('generationControls').style.display = 'none';
                
                debugLog('Edit mode exited');
            }


            // Ny funktion för att generera diskreta tidsintervall
            function generateDiscreteTimeSlots(startTime, endTime, intervalMinutes) {
                const slots = [];
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);
                
                let currentTime = startMinutes;
                
                while (currentTime <= endMinutes) {
                    slots.push(minutesToTime(currentTime));
                    currentTime += intervalMinutes;
                }
                
                return slots;
            }

            // Ny funktion för att skapa lesson grid med spanning
            // 4. Förbättra createLessonGrid för korrekt lesson ID hantering
            function createLessonGrid(scheduleData, weekdays, discreteTimeSlots) {
                const grid = {};
                
                // Initiera grid
                weekdays.forEach(day => {
                    grid[day] = {};
                    discreteTimeSlots.forEach(timeSlot => {
                        grid[day][timeSlot] = { type: 'empty', lesson: null, spanRows: 0 };
                    });
                });
                
                // Placera lektioner i grid
                if (scheduleData.lessons_by_day) {
                    Object.entries(scheduleData.lessons_by_day).forEach(([day, lessons]) => {
                        lessons.forEach((lesson, lessonIndex) => {
                            // Skapa unikt lesson ID om det inte finns
                            if (!lesson.id) {
                                lesson.id = `${day}-${lessonIndex}-${lesson.subject?.replace(/\s+/g, '')}-${lesson.time?.replace(/[:-]/g, '')}`;
                            }
                            
                            const [lessonStartTime, lessonEndTime] = lesson.time.split('-');
                            const lessonStartMinutes = timeToMinutes(lessonStartTime);
                            const lessonEndMinutes = timeToMinutes(lessonEndTime);
                            
                            // RÄTT metod: Hitta närmaste tidslot som är <= lektionens starttid
                            let startIndex = -1;
                            let bestMatch = -1;
                            
                            discreteTimeSlots.forEach((timeSlot, index) => {
                                const slotMinutes = timeToMinutes(timeSlot);
                                
                                // Hitta den senaste tidslot som är <= lektionens starttid
                                if (slotMinutes <= lessonStartMinutes) {
                                    if (slotMinutes > bestMatch) {
                                        bestMatch = slotMinutes;
                                        startIndex = index;
                                    }
                                }
                            });

                            // Sätt start cell med korrekt spanRows
                            if (startIndex >= 0 && startIndex < discreteTimeSlots.length) {
                                const startTimeSlot = discreteTimeSlots[startIndex];
                                
                                // Beräkna spanRows baserat på faktisk lektionstid
                                const intervalMinutes = 5;
                                const actualDurationMinutes = lessonEndMinutes - lessonStartMinutes;
                                const spanRows = Math.ceil(actualDurationMinutes / intervalMinutes);
                                
                                grid[day][startTimeSlot] = {
                                    type: 'lesson-start',
                                    lesson: lesson,
                                    spanRows: spanRows
                                };
                                
                                // Markera mellanliggande celler
                                const endIndex = Math.min(startIndex + spanRows - 1, discreteTimeSlots.length - 1);
                                for (let i = startIndex + 1; i <= endIndex; i++) {
                                    const middleTimeSlot = discreteTimeSlots[i];
                                    grid[day][middleTimeSlot] = {
                                        type: 'lesson-middle',
                                        lesson: lesson,
                                        spanRows: 0
                                    };
                                }
                            }
                        });
                    });
                }
                
                return grid;
            }


            // Lägg till styles om de inte redan finns
            if (!document.getElementById('spanning-lesson-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'spanning-lesson-styles';
                styleElement.textContent = spanningLessonStyles;
                document.head.appendChild(styleElement);
            }



            // Lägg till CSS för spanning lessons
            const spanningLessonStyles = `
                .schedule-cell {
                    position: relative;
                }
                
                .spanning-lesson {
                    box-sizing: border-box;
                }
                
                .spanning-lesson:hover {
                    z-index: 30 !important;
                    transform: scale(1.02) !important;
                }
                
                .spanning-lesson:active {
                    cursor: grabbing !important;
                }
                
                .lesson-middle {
                    background: linear-gradient(135deg, #4299e1, #3182ce) !important; /* SAMMA FÄRG som lektionsblocket */
                    border-top: 1px solid rgba(255,255,255,0.3) !important;
                    border-left: 1px solid rgba(255,255,255,0.3) !important;
                    border-right: 1px solid rgba(255,255,255,0.3) !important;
                }
                
                .editable-schedule-table td {
                    padding: 0;
                    vertical-align: top;
                }
                
                .editable-schedule-table .schedule-cell.empty {
                    background: transparent;
                }
                
                .editable-schedule-table .schedule-cell.lesson-start {
                    background: transparent; /* Låt lektionsblocket hantera färgen */
                }
                
                .editable-schedule-table .schedule-cell.lesson-middle {
                    background: linear-gradient(135deg, #4299e1, #3182ce); /* SAMMA FÄRG */
                    border-left: 1px solid rgba(255,255,255,0.3);
                    border-right: 1px solid rgba(255,255,255,0.3);
                }
            `;


            /**
             * Display schedule in editable format with drag-and-drop
             */
            // Förbättrad displayEditableSchedule med scroll-container
            // Uppdaterad displayEditableScheduleWithAutoScroll funktion
            // Ersätt displayEditableScheduleWithAutoScroll funktionen med denna:
            // Ersätt displayEditableScheduleWithAutoScroll funktionen med denna:
            function displayEditableScheduleWithAutoScroll(scheduleData) {
                const preview = document.getElementById('schedulePreview');
                
                // Skapa scroll-container
                const scrollContainer = document.createElement('div');
                scrollContainer.id = 'scheduleScrollContainer';
                scrollContainer.style.cssText = `
                    max-height: 70vh;
                    overflow: auto;
                    position: relative;
                    border: 2px solid #e2e8f0;
                    border-radius: 0.5rem;
                    background: white;
                    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
                `;

                // Generera diskreta tidsintervall (5-minuters intervall)
                const discreteTimeSlots = generateDiscreteTimeSlots('08:00', '18:00', 5);
                
                // Build schedule grid med förbättrad layout
                const weekdays = ['måndag', 'tisdag', 'onsdag', 'torsdag', 'fredag'];
                
                // Store lesson data för lookup
                window.editModeLessons = {};
                
                let html = `<table class="editable-schedule-table" style="
                    width: 100%; 
                    border-collapse: collapse; 
                    user-select: none;
                    min-width: 800px;
                ">`;
                
                // Table header
                html += '<thead><tr style="position: sticky; top: 0; background: white; z-index: 50;">';
                html += '<th style="min-width: 80px; padding: 12px; background: #f7fafc; border: 1px solid #e2e8f0; font-weight: 600;">Tid</th>';
                weekdays.forEach(day => {
                    html += `<th style="min-width: 160px; padding: 12px; background: #f7fafc; border: 1px solid #e2e8f0; text-align: center; font-weight: 600;">
                        ${day.charAt(0).toUpperCase() + day.slice(1)}
                    </th>`;
                });
                html += '</tr></thead><tbody>';
                
                // Skapa en grid för lektioner per dag och tid
                const lessonGrid = createLessonGrid(scheduleData, weekdays, discreteTimeSlots);
                
                // Rendera rader för varje diskret tidsslot
                discreteTimeSlots.forEach(timeSlot => {
                    html += `<tr><td style="
                        padding: 4px 12px; 
                        font-weight: 600; 
                        background: #f9fafb; 
                        border: 1px solid #e2e8f0;
                        white-space: nowrap;
                        position: sticky;
                        left: 0;
                        z-index: 10;
                        height: 20px;
                        font-size: 12px;
                        line-height: 1;
                    ">${timeSlot}</td>`;
                    
                    weekdays.forEach(day => {
                        const cellId = `cell-${day}-${timeSlot.replace(':', '-')}`;
                        const cellData = lessonGrid[day][timeSlot];
                        
                        html += `<td id="${cellId}" 
                                    class="schedule-cell ${cellData.type}" 
                                    data-day="${day}" 
                                    data-time="${timeSlot}"
                                    ondrop="handleLessonDrop(event)" 
                                    ondragover="handleDragOver(event)"
                                    ondragenter="handleDragEnter(event)"
                                    ondragleave="handleDragLeave(event)"
                                    style="
                                        padding: 0; 
                                        border: 1px solid #e2e8f0; 
                                        height: 20px;
                                        position: relative; 
                                        vertical-align: top;
                                        transition: all 0.2s ease;
                                        ${cellData.type === 'lesson-start' ? 'background: transparent;' : ''}
                                        ${cellData.type === 'lesson-middle' ? 'background: linear-gradient(135deg, #4299e1, #3182ce); border-left: 1px solid rgba(255,255,255,0.3); border-right: 1px solid rgba(255,255,255,0.3);' : ''}
                                    ">`;

                        
                        // Rendera lektion bara på start-raden (utan höjdberäkning här)
                        // Rendera lektion bara på start-raden (utan höjdberäkning här)
                        if (cellData.type === 'lesson-start' && cellData.lesson) {
                            const lessonWithTeacher = {
                                ...cellData.lesson,
                                teacher_id: cellData.lesson.teacher_id || cellData.lesson.teacherId,
                                teacher_name: cellData.lesson.teacher_name || cellData.lesson.teacherName || cellData.lesson.teacher
                            };
                            
                            // Store complete lesson data including teacher info
                            window.editModeLessons[cellData.lesson.id] = lessonWithTeacher;
                            
                            html += `<div id="lesson-${cellData.lesson.id}" 
                                class="draggable-lesson spanning-lesson" 
                                draggable="true"
                                data-lesson-id="${cellData.lesson.id}"
                                data-subject="${escapeHtml(cellData.lesson.subject || cellData.lesson.school_subject || 'Okänt ämne')}"
                                data-room="${escapeHtml(cellData.lesson.room || 'Inget rum')}"
                                data-original-day="${day}"
                                data-original-time="${cellData.lesson.time}"
                                data-span-rows="${cellData.spanRows}"
                                data-teacher-id="${lessonWithTeacher.teacher_id || ''}"
                                data-teacher-name="${escapeHtml(lessonWithTeacher.teacher_name || '')}"
                                style="position: absolute; left: 1px; right: 1px; background: linear-gradient(135deg, #4299e1, #3182ce); color: white; padding: 4px 8px; border-radius: 6px; cursor: move; box-shadow: 0 2px 4px rgba(0,0,0,0.15); transition: all 0.2s ease; border: 1px solid rgba(255,255,255,0.3); z-index: 10; overflow: hidden; font-size: 11px; line-height: 1.2; box-sizing: border-box;"
                                ondragstart="handleLessonDragStartEnhanced(event)"
                                ondragend="handleLessonDragEndEnhanced(event)">
                                <div style="font-weight: 700; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${escapeHtml(cellData.lesson.subject || cellData.lesson.school_subject || 'Okänt ämne')}
                                </div>
                            </div>`;
                        }
                        
                        html += '</td>';
                    });
                    
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                
                // Set content
                scrollContainer.innerHTML = html;

                // Preserve existing edit header
                const existingHeader = document.getElementById('editModeHeader');
                const headerHtml = existingHeader ? existingHeader.outerHTML : '';
                
                preview.innerHTML = headerHtml;
                preview.appendChild(scrollContainer);
                
                // Store reference för auto-scroll
                scheduleScrollContainer = scrollContainer;
                
                // VIKTIGT: Beräkna korrekta höjder EFTER DOM är renderad
                setTimeout(() => {
                    adjustLessonHeights();
                    setupAutoScrollBounds();
                    attachScrollListeners();
                }, 50);
                
                debugLog('Enhanced editable schedule displayed with discrete time slots');
            }

            // Ny funktion för att justera lesson-höjder efter DOM är renderad
            function adjustLessonHeights() {
                document.querySelectorAll('.spanning-lesson').forEach(lessonElement => {
                    const lessonId = lessonElement.dataset.lessonId;
                    const lesson = window.editModeLessons[lessonId];
                    const day = lessonElement.dataset.originalDay;
                    const originalTime = lessonElement.dataset.originalTime;
                    const spanRows = parseInt(lessonElement.dataset.spanRows);
                    
                    if (!lesson || !originalTime) return;
                    
                    const [lessonStartTime, lessonEndTime] = originalTime.split('-');
                    const lessonStartMinutes = timeToMinutes(lessonStartTime);
                    const lessonEndMinutes = timeToMinutes(lessonEndTime);
                    const durationMinutes = lessonEndMinutes - lessonStartMinutes;
                    
                    // Hitta första cellen
                    const discreteTimeSlots = generateDiscreteTimeSlots('08:00', '18:00', 5);
                    let startTimeSlot = null;
                    let bestMatch = -1;
                    
                    discreteTimeSlots.forEach(timeSlot => {
                        const slotMinutes = timeToMinutes(timeSlot);
                        if (slotMinutes <= lessonStartMinutes && slotMinutes > bestMatch) {
                            bestMatch = slotMinutes;
                            startTimeSlot = timeSlot;
                        }
                    });
                    
                    if (!startTimeSlot) return;
                    
                    const firstCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${startTimeSlot}"]`);
                    if (!firstCell) return;
                    
                    const actualCellHeight = firstCell.getBoundingClientRect().height;
                    const pixelsPerMinute = actualCellHeight / 5; // 5 minuter per cell
                    
                    // Beräkna offset och höjd
                    const slotStartMinutes = timeToMinutes(startTimeSlot);
                    const offsetMinutes = Math.max(0, lessonStartMinutes - slotStartMinutes);
                    const offsetPixels = Math.round(offsetMinutes * pixelsPerMinute);
                    
                    // Beräkna total tillgänglig höjd
                    const lastCellStartMinutes = slotStartMinutes + (spanRows - 1) * 5;
                    const lastCellTime = minutesToTime(lastCellStartMinutes);
                    const lastCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${lastCellTime}"]`);
                    
                    let totalAvailableHeight = spanRows * actualCellHeight;
                    if (firstCell && lastCell) {
                        const firstRect = firstCell.getBoundingClientRect();
                        const lastRect = lastCell.getBoundingClientRect();
                        totalAvailableHeight = Math.max(0, lastRect.bottom - firstRect.top);
                    }
                    
                    const durationPixels = Math.round(durationMinutes * pixelsPerMinute);
                    const maxPossibleHeight = Math.max(0, totalAvailableHeight - offsetPixels - 2);
                    const blockHeight = Math.max(20, Math.min(durationPixels, maxPossibleHeight));
                    
                    // Uppdatera element
                    lessonElement.style.top = `${offsetPixels}px`;
                    lessonElement.style.height = `${blockHeight}px`;
                    
                    // Lägg till mer innehåll om det finns plats
                    const contentDiv = lessonElement.querySelector('div');
                    if (spanRows >= 3 && !lessonElement.querySelector('.room-info')) {
                        const roomDiv = document.createElement('div');
                        roomDiv.className = 'room-info';
                        roomDiv.style.cssText = 'font-size: 10px; opacity: 0.9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                        roomDiv.textContent = `📍 ${lesson.room || 'Inget rum'}`;
                        contentDiv.after(roomDiv);
                    }
                    
                    if (spanRows >= 5 && !lessonElement.querySelector('.time-info')) {
                        const timeDiv = document.createElement('div');
                        timeDiv.className = 'time-info';
                        timeDiv.style.cssText = 'font-size: 10px; opacity: 0.8; margin-top: 2px;';
                        timeDiv.textContent = `🕒 ${originalTime}`;
                        lessonElement.appendChild(timeDiv);
                    }
                });
            }

            function displayEditableSchedule(scheduleData) {
                return displayEditableScheduleWithAutoScroll(scheduleData);
            }

            /**
             * Create draggable lesson block for editing (backward compatibility)
             */
            function createEditableLessonBlock(lesson, day, timeSlot) {
                return createEditableLessonBlockEnhanced(lesson, day, timeSlot);
            }


            // Uppdaterad funktion för att skapa spanning lesson blocks
            // 5. Uppdatera createEditableLessonBlockSpanning med korrekt lesson data
            // Ersätt denna funktion (createEditableLessonBlockSpanning) med denna version.
            // Förklaring: vi hämtar verkliga DOM-höjder för start- och slutcell istället för
            // att använda hårdkodade 20px/5min. Vi beräknar blockets top (offset) och höjd
            // från cellernas bounding rects vilket gör att blocket alltid fyller korrekt tid.
            // --- Ersätt hela createEditableLessonBlockSpanning med denna ---
            function createEditableLessonBlockSpanning(lesson, day, timeSlot, spanRows) {
                const lessonId = lesson.id;

                // Försök hitta referenscellen för slotStart (för den dag/tid som skickas in).
                const firstCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${timeSlot}"]`);
                const teacherId = lesson.teacher_id || lesson.teacherId || null;
                const teacherName = lesson.teacher_name || lesson.teacherName || lesson.teacher || null;
                // Minutes per cell — läs från data-minutes-per-slot om det finns, annars default 5.
                const minutesPerCell = firstCell && firstCell.dataset && firstCell.dataset.minutesPerSlot
                    ? parseInt(firstCell.dataset.minutesPerSlot, 10)
                    : 5;

                // Fallback cellheight om DOM ej renderad
                const fallbackCellHeight = 20;
                const actualCellHeight = firstCell ? firstCell.getBoundingClientRect().height : fallbackCellHeight;

                // pixels per minute baserat på verklig cellhöjd
                const pixelsPerMinute = actualCellHeight / minutesPerCell;

                // Lektionens start/slut i minuter
                const [lessonStartTime, lessonEndTime] = lesson.time.split('-');
                const lessonStartMinutes = timeToMinutes(lessonStartTime);
                const lessonEndMinutes = timeToMinutes(lessonEndTime);
                const durationMinutes = Math.max(0, lessonEndMinutes - lessonStartMinutes);

                // Offset i minuter (om lektionen börjar mitt i en cell)
                const slotStartMinutes = timeToMinutes(timeSlot);
                const offsetMinutes = Math.max(0, lessonStartMinutes - slotStartMinutes);
                const offsetPixels = Math.max(0, Math.round(offsetMinutes * pixelsPerMinute));

                // Försök hitta sista cellen som lektionen spänner över
                const lastCellStartMinutes = slotStartMinutes + (spanRows - 1) * minutesPerCell;
                const lastCellTime = minutesToTime(lastCellStartMinutes);
                const lastCell = document.querySelector(`.schedule-cell[data-day="${day}"][data-time="${lastCellTime}"]`);

                // totalAvailableHeight: från toppen av första cell till botten av sista cell (inkl. gap)
                let totalAvailableHeight;
                if (firstCell && lastCell) {
                    const firstRect = firstCell.getBoundingClientRect();
                    const lastRect  = lastCell.getBoundingClientRect();
                    totalAvailableHeight = Math.max(0, lastRect.bottom - firstRect.top);
                } else {
                    totalAvailableHeight = Math.max(0, spanRows * actualCellHeight);
                }

                // Beräkna gap-justering (radgaps, borders, mm): skillnad mellan faktiska rect-höjden och sum av cell heights
                const estimatedCellsHeight = spanRows * actualCellHeight;
                const gapAdjustment = Math.max(0, totalAvailableHeight - estimatedCellsHeight);

                // Beräkna lektionens pixelhöjd + kompensera för gaps
                const durationPixels = Math.round(durationMinutes * pixelsPerMinute);
                const desiredHeight = durationPixels + gapAdjustment;

                // Max som får användas (ej rinna utanför tillgänglig area efter offset)
                const maxPossibleHeight = Math.max(0, totalAvailableHeight - offsetPixels - 2); // -2 för borders

                // Minimal synlig höjd
                const MIN_LESSON_HEIGHT = 20;

                // Slutlig höjd: clamp till maxPossibleHeight och säkerställ MIN_LESSON_HEIGHT
                const computed = Math.min(desiredHeight, maxPossibleHeight);
                const blockHeight = Math.max(MIN_LESSON_HEIGHT, Math.ceil(computed + 1)); // +1 fudge för pixelavrundning

                return `
                    <div id="lesson-${lessonId}" 
                        class="draggable-lesson spanning-lesson" 
                        draggable="true"
                        ondragstart="handleLessonDragStartEnhanced(event)"
                        ondragend="handleLessonDragEndEnhanced(event)"
                        data-lesson-id="${lessonId}"
                        data-subject="${escapeHtml(lesson.subject || lesson.school_subject || 'Okänt ämne')}"
                        data-room="${escapeHtml(lesson.room || 'Inget rum')}"
                        data-original-day="${day}"
                        data-original-time="${lesson.time}"
                        data-span-rows="${spanRows}"
                        data-teacher-id="${teacherId || ''}"
                        data-teacher-name="${escapeHtml(teacherName || '')}"
                        style="
                            position: absolute;
                            top: ${offsetPixels}px;
                            left: 1px;
                            right: 1px;
                            height: ${blockHeight}px;
                            background: linear-gradient(135deg, #4299e1, #3182ce);
                            color: white;
                            padding: 4px 8px;
                            border-radius: 6px;
                            cursor: move;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
                            transition: all 0.2s ease;
                            border: 1px solid rgba(255,255,255,0.3);
                            z-index: 10;
                            overflow: hidden;
                            font-size: 11px;
                            line-height: 1.2;
                            box-sizing: border-box;
                        "
                        onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.25)'; this.style.zIndex='20';"
                        onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.15)'; this.style.zIndex='10';">
                        
                        <div style="font-weight: 700; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${escapeHtml(lesson.subject || lesson.school_subject || 'Okänt ämne')}
                        </div>
                        
                        ${spanRows >= 3 ? `
                            <div style="font-size: 10px; opacity: 0.9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                📍 ${escapeHtml(lesson.room || 'Inget rum')}
                            </div>
                        ` : ''}
                        
                        ${spanRows >= 5 ? `
                            <div style="font-size: 10px; opacity: 0.8; margin-top: 2px;">
                                🕒 ${lesson.time}
                            </div>
                        ` : ''}
                        
                        <div class="drag-handle" style="
                            position: absolute;
                            top: 2px;
                            right: 2px;
                            width: 12px;
                            height: 12px;
                            background: rgba(255,255,255,0.3);
                            border-radius: 2px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 8px;
                            cursor: grab;
                        ">⋮⋮</div>
                    </div>
                `;
            }


    



            /**
             * Create draggable lesson block for editing
             */
            // 1. Fix för createEditableLessonBlock - lägg till korrekt lesson ID
            // Uppdatera lesson block creation för att använda enhanced handlers
            function createEditableLessonBlockEnhanced(lesson, day, timeSlot) {
                const lessonId = lesson.id;
                
                return `
                    <div id="lesson-${lessonId}" 
                        class="draggable-lesson" 
                        draggable="true"
                        ondragstart="handleLessonDragStartEnhanced(event)"
                        ondragend="handleLessonDragEndEnhanced(event)"
                        data-lesson-id="${lessonId}"
                        data-subject="${lesson.subject}"
                        data-room="${lesson.room}"
                        data-original-day="${day}"
                        data-original-time="${timeSlot}"
                        style="
                            background: linear-gradient(135deg, #4299e1, #3182ce);
                            color: white;
                            padding: 10px;
                            border-radius: 8px;
                            cursor: move;
                            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
                            transition: all 0.2s ease;
                            border: 2px solid transparent;
                            position: relative;
                        "
                        onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 6px 12px rgba(0,0,0,0.2)'"
                        onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 6px rgba(0,0,0,0.15)'">
                        <div style="font-weight: 700; font-size: 0.9rem; margin-bottom: 4px;">
                            ${escapeHtml(lesson.subject)}
                        </div>
                        <div style="font-size: 0.8rem; opacity: 0.9; margin-bottom: 2px;">
                            📍 ${escapeHtml(lesson.room || 'Inget rum')}
                        </div>
                        <div class="drag-handle" style="
                            position: absolute;
                            top: 4px;
                            right: 4px;
                            width: 16px;
                            height: 16px;
                            background: rgba(255,255,255,0.3);
                            border-radius: 3px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 10px;
                            cursor: grab;
                        ">⋮⋮</div>
                        <div style="
                            position: absolute;
                            bottom: 2px;
                            right: 4px;
                            font-size: 0.7rem;
                            opacity: 0.7;
                        ">🕒 5min buffer</div>
                    </div>
                `;
            }

            /**
             * Handle drag start for lessons
             */
            // Add enhanced drag visual feedback
            // Förbättrad drag start med auto-scroll setup
            // 3. Fix dragstart för spanning lessons
            // 1. HUVUDPROBLEMET: Förbättra handleLessonDragStartEnhanced
            function handleLessonDragStartEnhanced(event) {
                // Förhindra event bubbling
                event.stopPropagation();
                
                const lessonElement = event.target.closest('.draggable-lesson');
                if (!lessonElement) {
                    console.warn('Drag started on non-lesson element');
                    return;
                }
                
                // Hämta lärardata från DOM eller window.editModeLessons
                let teacherId = lessonElement.dataset.teacherId;
                let teacherName = lessonElement.dataset.teacherName;
                
                // Fallback: hämta från editModeLessons om data saknas i DOM
                if ((!teacherId || !teacherName) && window.editModeLessons) {
                    const lesson = window.editModeLessons[lessonElement.dataset.lessonId];
                    if (lesson) {
                        teacherId = teacherId || lesson.teacher_id || lesson.teacherId;
                        teacherName = teacherName || lesson.teacher_name || lesson.teacherName || lesson.teacher;
                    }
                }
                
                // Säkerställ att draggedLesson sätts FÖRST med korrekt lärardata
                draggedLesson = {
                    element: lessonElement,
                    lessonId: lessonElement.dataset.lessonId,
                    subject: lessonElement.dataset.subject,
                    room: lessonElement.dataset.room,
                    originalDay: lessonElement.dataset.originalDay,
                    originalTime: lessonElement.dataset.originalTime,
                    teacherId: teacherId || null,
                    teacherName: teacherName || null,
                    spanRows: parseInt(lessonElement.dataset.spanRows) || 1
                };
                
                debugLog('Drag start enhanced - draggedLesson set:', draggedLesson);
                
                // Sätt drag data för native drag-and-drop
                try {
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/plain', draggedLesson.lessonId);
                    event.dataTransfer.setData('application/json', JSON.stringify(draggedLesson));
                } catch (e) {
                    debugLog('DataTransfer error (IE compatibility):', e);
                }
                
                // Visuell feedback för dragged element
                lessonElement.style.opacity = '0.7';
                lessonElement.style.transform = 'rotate(2deg) scale(1.05)';
                lessonElement.style.zIndex = '1000';
                lessonElement.style.boxShadow = '0 8px 16px rgba(0,0,0,0.3)';
                
                // Hitta ursprungscellerna MEN rensa dem INTE än
                const originalDay = draggedLesson.originalDay;
                const [originalStart, originalEnd] = draggedLesson.originalTime.split('-');
                const originalStartMinutes = timeToMinutes(originalStart);
                const originalEndMinutes = timeToMinutes(originalEnd);
                
                const discreteTimeSlots = generateDiscreteTimeSlots('08:00', '18:00', 5);
                const occupiedCells = [];
                
                discreteTimeSlots.forEach(timeSlot => {
                    const slotMinutes = timeToMinutes(timeSlot);
                    if (slotMinutes >= originalStartMinutes && slotMinutes < originalEndMinutes) {
                        const cellId = `cell-${originalDay}-${timeSlot.replace(':', '-')}`;
                        const cell = document.getElementById(cellId);
                        if (cell) {
                            occupiedCells.push(cell);
                        }
                    }
                });
                
                draggedLesson.originalCells = occupiedCells;
                
                // Starta auto-scroll och markera celler EFTER en liten delay
                setTimeout(() => {
                    if (draggedLesson) {
                        markTeacherConflictCells();
                        startAutoScroll();
                    }
                }, 50);
                
                debugLog('Enhanced drag started successfully');
            }


            /**
             * Handle drag end
             */
            function handleLessonDragEnd(event) {
                event.target.style.opacity = '1';
                event.target.style.transform = 'scale(1)';
                
                // Remove visual feedback
                document.querySelectorAll('.drop-zone').forEach(cell => {
                    cell.classList.remove('drop-zone');
                    cell.style.background = '';
                });
            }



            // Update markTeacherConflictCells to handle original cell clearing properly
            // Update markTeacherConflictCells to handle original cell clearing properly
            // Update markTeacherConflictCells to handle original cell clearing properly
            // Ersätt markTeacherConflictCells funktionen med denna version
            // 6. FÖRBÄTTRA markTeacherConflictCells - anropa clearOriginalLessonCells BARA en gång
            function markTeacherConflictCells() {
                // Clear all previous markings first
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    cell.classList.remove('drop-zone', 'teacher-conflict-zone', 'room-conflict-zone');
                    cell.style.border = '';
                    cell.style.background = '';
                    cell.title = '';
                    // Remove old indicators
                    cell.querySelectorAll('.drag-conflict-indicator, .teacher-buffer-indicator').forEach(el => el.remove());
                });
                
                // Rensa ursprungscellerna BARA FÖRSTA GÅNGEN
                clearOriginalLessonCells();
                
                if (!draggedLesson) {
                    debugLog('No draggedLesson available for conflict marking');
                    return;
                }
                
                // Debug lärardata
                debugLog('Teacher data for conflict check:', {
                    teacherId: draggedLesson.teacherId,
                    teacherName: draggedLesson.teacherName
                });
                
                if (!draggedLesson.teacherId && !draggedLesson.teacherName) {
                    debugLog('No teacher data available, marking all empty cells as available');
                    // Fallback - mark all empty cells as available
                    document.querySelectorAll('.schedule-cell.empty').forEach(cell => {
                        cell.classList.add('drop-zone');
                        cell.style.border = '2px dashed #4299e1';
                        cell.style.background = 'rgba(66, 153, 225, 0.1)';
                    });
                    return;
                }
                
                // Get all lessons from DOM (excluding the one being dragged) with improved data extraction
                const allCurrentLessons = Array.from(document.querySelectorAll('.spanning-lesson'))
                    .filter(lessonEl => lessonEl.dataset.lessonId !== draggedLesson.lessonId && lessonEl.style.display !== 'none')
                    .map(lessonEl => {
                        const originalTime = lessonEl.dataset.originalTime;
                        if (!originalTime || !originalTime.includes('-')) return null;
                        
                        let teacherId = lessonEl.dataset.teacherId;
                        let teacherName = lessonEl.dataset.teacherName;
                        
                        // Fallback: hämta från editModeLessons
                        if ((!teacherId || !teacherName) && window.editModeLessons) {
                            const lesson = window.editModeLessons[lessonEl.dataset.lessonId];
                            if (lesson) {
                                teacherId = teacherId || lesson.teacher_id || lesson.teacherId;
                                teacherName = teacherName || lesson.teacher_name || lesson.teacherName || lesson.teacher;
                            }
                        }
                        
                        return {
                            id: lessonEl.dataset.lessonId,
                            day: lessonEl.dataset.originalDay,
                            time: originalTime,
                            teacherId: teacherId,
                            teacherName: teacherName,
                            room: lessonEl.dataset.room,
                            subject: lessonEl.dataset.subject
                        };
                    }).filter(Boolean);
                
                debugLog('Found lessons for conflict check:', allCurrentLessons.map(l => ({
                    subject: l.subject,
                    teacher: l.teacherName || l.teacherId,
                    time: l.time,
                    day: l.day
                })));
                
                // Mark all cells with conflict checking
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    const cellDay = cell.dataset.day;
                    const cellTime = cell.dataset.time;
                    
                    if (!cellDay || !cellTime) return;
                    
                    // Calculate time interval for the cell based on dragged lesson's length
                    const originalDuration = calculateLessonDuration(draggedLesson.originalTime);
                    const cellStartMinutes = timeToMinutes(cellTime);
                    const cellEndMinutes = cellStartMinutes + originalDuration;
                    const newTimeRange = `${cellTime}-${minutesToTime(cellEndMinutes)}`;
                    
                    // Check teacher conflict with 10 min buffer
                    const hasTeacherConflict = checkTeacherConflictForCell(
                        allCurrentLessons, cellDay, newTimeRange, draggedLesson.teacherId, draggedLesson.teacherName
                    );
                    
                    // Check room conflict
                    const hasRoomConflict = !isRoomAvailableForTimeSlot(draggedLesson.room, allCurrentLessons, cellDay, newTimeRange);
                    const availableRooms = getAvailableRoomsForTimeSlot(allCurrentLessons, cellDay, newTimeRange);
                    
                    // Set position relative for indicators
                    cell.style.position = 'relative';
                    
                    if (hasTeacherConflict) {
                        // RED marking for teacher conflicts
                        cell.classList.add('teacher-conflict-zone');
                        cell.style.border = '2px solid #f56565 !important';
                        cell.style.background = 'rgba(245, 101, 101, 0.3) !important';
                        cell.title = `⚠️ Läraren ${draggedLesson.teacherName || draggedLesson.teacherId || 'okänd'} har redan lektion här (10 min buffert krävs)`;
                        
                        // Add conflict icon
                        const conflictIcon = document.createElement('div');
                        conflictIcon.className = 'drag-conflict-indicator';
                        conflictIcon.innerHTML = '⚠️';
                        conflictIcon.style.cssText = `
                            position: absolute;
                            top: 2px;
                            right: 2px;
                            background: #f56565;
                            color: white;
                            border-radius: 50%;
                            width: 18px;
                            height: 18px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 12px;
                            z-index: 100;
                            pointer-events: none;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                        `;
                        cell.appendChild(conflictIcon);
                        
                    } else if (hasRoomConflict && availableRooms.length === 0) {
                        // RED marking for room conflict without alternatives
                        cell.classList.add('room-conflict-zone');
                        cell.style.border = '2px solid #f56565 !important';
                        cell.style.background = 'rgba(245, 101, 101, 0.2) !important';
                        cell.title = `🏫 Inga lediga rum tillgängliga för denna tid`;
                        
                        const roomIcon = document.createElement('div');
                        roomIcon.className = 'drag-conflict-indicator';
                        roomIcon.innerHTML = '🚫';
                        roomIcon.style.cssText = `
                            position: absolute;
                            top: 2px;
                            left: 2px;
                            background: #f56565;
                            color: white;
                            border-radius: 3px;
                            padding: 2px 4px;
                            font-size: 10px;
                            z-index: 100;
                            pointer-events: none;
                        `;
                        cell.appendChild(roomIcon);
                        
                    } else if (hasRoomConflict && availableRooms.length > 0) {
                        // ORANGE marking for room conflict with alternatives
                        cell.classList.add('room-conflict-zone');
                        cell.style.border = '2px dashed #ed8936 !important';
                        cell.style.background = 'rgba(237, 137, 54, 0.15) !important';
                        cell.title = `🏫 Originalsal upptagen, kommer att byta till: ${availableRooms[0]}`;
                        
                        const roomIcon = document.createElement('div');
                        roomIcon.className = 'drag-conflict-indicator';
                        roomIcon.innerHTML = '🔄';
                        roomIcon.style.cssText = `
                            position: absolute;
                            top: 2px;
                            left: 2px;
                            background: #ed8936;
                            color: white;
                            border-radius: 3px;
                            padding: 2px 4px;
                            font-size: 10px;
                            z-index: 100;
                            pointer-events: none;
                        `;
                        cell.appendChild(roomIcon);
                        
                    } else {
                        // GREEN/BLUE marking for available positions
                        cell.classList.add('drop-zone');
                        cell.style.border = '2px dashed #4299e1 !important';
                        cell.style.background = 'rgba(66, 153, 225, 0.1) !important';
                        cell.title = 'Tillgänglig - klicka för att flytta hit';
                    }
                });
            }

            /**
             * Handle drag over for drop zones
             */
            function handleDragOver(event) {
                event.preventDefault();
                event.currentTarget.style.background = 'rgba(72, 187, 120, 0.2)';
            }

            function calculateLessonDuration(timeRange) {
                if (!timeRange || typeof timeRange !== 'string' || !timeRange.includes('-')) {
                    console.warn('calculateLessonDuration received invalid timeRange:', timeRange);
                    return 60; // Default 60 minuter
                }
                const [startTime, endTime] = timeRange.split('-');
                return timeToMinutes(endTime) - timeToMinutes(startTime);
            }


            function getAvailableRoomsForTimeSlot(allLessons, targetDay, targetTimeRange) {
                const allRooms = getAvailableRooms(); // Hämta alla tillgängliga rum
                const [targetStart, targetEnd] = targetTimeRange.split('-');
                const targetStartMinutes = timeToMinutes(targetStart);
                const targetEndMinutes = timeToMinutes(targetEnd);
                
                const occupiedRooms = new Set();
                
                allLessons.forEach(lesson => {
                    if (lesson.day !== targetDay) return;
                    
                    const [lessonStart, lessonEnd] = lesson.time.split('-');
                    const lessonStartMinutes = timeToMinutes(lessonStart);
                    const lessonEndMinutes = timeToMinutes(lessonEnd);
                    
                    // Om lektionen överlappar med måltiden, markera rummet som upptaget
                    if (!(targetEndMinutes <= lessonStartMinutes || targetStartMinutes >= lessonEndMinutes)) {
                        occupiedRooms.add(lesson.room);
                    }
                });
                
                return allRooms.filter(room => !occupiedRooms.has(room));
            }

            /**
             * Kontrollera om ett specifikt rum är ledigt vid en viss tid
             */
            function isRoomAvailableForTimeSlot(room, allLessons, targetDay, targetTimeRange) {
                const availableRooms = getAvailableRoomsForTimeSlot(allLessons, targetDay, targetTimeRange);
                return availableRooms.includes(room);
}


            function checkTeacherConflictForCell(allLessons, targetDay, targetTimeRange, teacherId, teacherName) {
                if (!teacherId && !teacherName) {
                    debugLog('No teacher data available for conflict check');
                    return false;
                }
                
                const [targetStart, targetEnd] = targetTimeRange.split('-');
                const targetStartMinutes = timeToMinutes(targetStart);
                const targetEndMinutes = timeToMinutes(targetEnd);
                
                const TEACHER_BUFFER_MINUTES = 10; // Minst 10 minuter mellan lektioner
                
                return allLessons.some(lesson => {
                    if (lesson.day !== targetDay) return false;
                    
                    // Förbättrad lärarmatching - kontrollera både ID och namn
                    let sameTeacher = false;
                    
                    if (teacherId && lesson.teacherId) {
                        sameTeacher = lesson.teacherId === teacherId;
                    } else if (teacherName && lesson.teacherName) {
                        // Normalisera namn för jämförelse
                        const normalizedDraggedName = teacherName.toLowerCase().trim();
                        const normalizedLessonName = lesson.teacherName.toLowerCase().trim();
                        sameTeacher = normalizedDraggedName === normalizedLessonName;
                    }
                    
                    if (!sameTeacher) return false;
                    
                    // Kontrollera tidsöverlappning med buffert
                    const [lessonStart, lessonEnd] = lesson.time.split('-');
                    const lessonStartMinutes = timeToMinutes(lessonStart);
                    const lessonEndMinutes = timeToMinutes(lessonEnd);
                    
                    // Lägg till buffert: ny lektion får inte börja inom 10 min efter befintlig lektion slutar
                    // och befintlig lektion får inte börja inom 10 min efter ny lektion slutar
                    const bufferConflict = (targetStartMinutes < lessonEndMinutes + TEACHER_BUFFER_MINUTES && 
                                        targetEndMinutes + TEACHER_BUFFER_MINUTES > lessonStartMinutes);
                    
                    if (bufferConflict) {
                        debugLog('Teacher conflict detected:', {
                            teacher: teacherName || teacherId,
                            conflictLesson: lesson,
                            targetTime: targetTimeRange
                        });
                    }
                    
                    return bufferConflict;
                });
            }


            // Uppdaterad drop handler för diskreta tidsintervall
            async function handleLessonDropDiscrete(event) {
                event.preventDefault();
                event.currentTarget.style.background = '';
                
                if (!draggedLesson) return;
                
                const targetCell = event.currentTarget;
                const newDay = targetCell.dataset.day;
                const newTimeSlot = targetCell.dataset.time;
                const lessonElement = draggedLesson.element;
                
                // Räkna ut ny tid baserat på lektionens ursprungliga längd
                const originalTime = draggedLesson.element.dataset.originalTime;
                const [originalStart, originalEnd] = originalTime.split('-');
                const lessonDurationMinutes = timeToMinutes(originalEnd) - timeToMinutes(originalStart);
                
                const newStartMinutes = timeToMinutes(newTimeSlot);
                const newEndMinutes = newStartMinutes + lessonDurationMinutes;
                const newEndTime = minutesToTime(newEndMinutes);
                const newTimeRange = `${newTimeSlot}-${newEndTime}`;
                
                // Kontrollera om det är samma position
                if (newDay === draggedLesson.originalDay && newTimeSlot === timeToMinutes(draggedLesson.originalTime.split('-')[0])) {
                    debugLog('Dropped on same location, no action needed');
                    return;
                }
                
                // Kontrollera konflikter med ny tidsberäkning
                const conflictCheck = await checkMoveConflictsDiscrete(draggedLesson, newDay, newTimeRange);
                if (!conflictCheck.canMove) {
                    showConflictMessage(conflictCheck.reason);
                    return;
                }
                
                try {
                    // Flytta lektionen med ny start- och sluttid
                    const moveResult = await moveLesson(draggedLesson.lessonId, newDay, newTimeSlot, newEndTime);
                    if (moveResult.success) {
                        showSuccessToast(`Lektion flyttad till ${newDay} ${newTimeRange}`);
                        
                        // Ladda om schemat för att visa uppdateringen
                        reloadEditSchedule();
                        
                        debugLog('Lesson moved successfully with discrete time slots', moveResult);
                    } else {
                        throw new Error(moveResult.error || 'Kunde inte flytta lektion');
                    }
                } catch (error) {
                    console.error('Error moving lesson:', error);
                    showConflictMessage(`Fel vid flyttning: ${error.message}`);
                }
                
                draggedLesson = null;
            }

            // Uppdaterad konflikt-kontroll för diskreta tidsintervall
            function checkMoveConflictsDiscrete(lesson, newDay, newTimeRange) {
                const [newStartTime, newEndTime] = newTimeRange.split('-');
                const newStartMinutes = timeToMinutes(newStartTime);
                const newEndMinutes = timeToMinutes(newEndTime);
                
                const ROOM_BUFFER_MINUTES = 5;
                
                // Hämta alla nuvarande lektioner från schemat
                const currentLessons = Array.from(document.querySelectorAll('.spanning-lesson')).map(lessonEl => {
                    const originalTime = lessonEl.dataset.originalTime;
                    if (!originalTime || !originalTime.includes('-')) return null;
                    
                    const [startTime, endTime] = originalTime.split('-');
                    const lessonDay = lessonEl.dataset.originalDay;
                    
                    return {
                        id: lessonEl.dataset.lessonId,
                        day: lessonDay,
                        time: originalTime,
                        startMinutes: timeToMinutes(startTime),
                        endMinutes: timeToMinutes(endTime),
                        subject: lessonEl.dataset.subject,
                        room: lessonEl.dataset.room
                    };
                }).filter(Boolean);

                // Kontrollera klassrums-konflikter med 5-minuters buffer
                const roomConflicts = currentLessons.filter(l => 
                    l.day === newDay && 
                    l.id !== lesson.lessonId &&
                    l.room === lesson.room &&
                    (newStartMinutes < l.endMinutes + ROOM_BUFFER_MINUTES && 
                    newEndMinutes + ROOM_BUFFER_MINUTES > l.startMinutes)
                );

                if (roomConflicts.length > 0) {
                    const conflictDetails = roomConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Klassrumskonflikt med ${ROOM_BUFFER_MINUTES}-min buffer: ${conflictDetails}` 
                    };
                }

                // Kontrollera vanliga tidskonflikter
                const timeConflicts = currentLessons.filter(l => 
                    l.day === newDay && 
                    l.id !== lesson.lessonId &&
                    l.room !== lesson.room &&
                    newStartMinutes < l.endMinutes && newEndMinutes > l.startMinutes
                );

                if (timeConflicts.length > 0) {
                    const conflictDetails = timeConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Tidskonflikt: ${conflictDetails}` 
                    };
                }

                return { canMove: true };
            }

            /**
             * Handle lesson drop with conflict checking
             */
            // 1. Ersätt handleLessonDrop funktionen med korrekt implementation
            // 5. Fix handleLessonDrop för att kontrollera draggedLesson ordentligt
            // Uppdatera handleLessonDrop för att hantera den dolda lektionen
            // Uppdatera handleLessonDrop för att vara enklare
            // 7. FÖRBÄTTRA handleLessonDrop för att hantera dataTransfer korrekt
            async function handleLessonDrop(event) {
                event.preventDefault();
                event.stopPropagation();
                
                const targetCell = event.currentTarget;
                targetCell.style.background = '';
                targetCell.classList.remove('drop-zone', 'teacher-conflict-zone', 'room-conflict-zone');
                
                // Ta bort alla konfliktindikatorer
                document.querySelectorAll('.drag-conflict-indicator').forEach(el => el.remove());
                
                // Hämta draggedLesson från dataTransfer om det inte finns
                if (!draggedLesson) {
                    try {
                        const lessonData = event.dataTransfer.getData('application/json');
                        if (lessonData) {
                            draggedLesson = JSON.parse(lessonData);
                            debugLog('Restored draggedLesson from dataTransfer:', draggedLesson);
                        }
                    } catch (e) {
                        debugLog('Could not restore draggedLesson from dataTransfer:', e);
                    }
                }
                
                if (!draggedLesson) {
                    debugLog('handleLessonDrop: No valid draggedLesson found');
                    return;
                }
                
                const newDay = targetCell.dataset.day;
                const newTimeSlot = targetCell.dataset.time;
                
                if (!newDay || !newTimeSlot) {
                    debugLog('handleLessonDrop: Target cell missing day or time data');
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                    return;
                }
                
                // Spara draggedLesson i lokal variabel
                const currentDraggedLesson = { ...draggedLesson };
                
                // Kontrollera om det är samma position
                const originalStartTime = currentDraggedLesson.originalTime ? currentDraggedLesson.originalTime.split('-')[0] : '';
                if (newDay === currentDraggedLesson.originalDay && newTimeSlot === originalStartTime) {
                    debugLog('Dropped on exact same location, restoring');
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                    return;
                }
                
                // Förhindra drop på lärarkonfliktzoner
                if (targetCell.classList.contains('teacher-conflict-zone')) {
                    showConflictMessage('⚠️ Läraren har redan en lektion vid denna tid. Välj en annan tid.');
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                    return;
                }
                
                // Beräkna ny tid och kontrollera rumstillgänglighet
                const originalDuration = calculateLessonDuration(currentDraggedLesson.originalTime);
                const newStartMinutes = timeToMinutes(newTimeSlot);
                const newEndMinutes = newStartMinutes + originalDuration;
                const newEndTime = minutesToTime(newEndMinutes);
                const newTimeRange = `${newTimeSlot}-${newEndTime}`;
                
                // Hämta alla andra lektioner för rumskontroll
                const allCurrentLessons = Array.from(document.querySelectorAll('.spanning-lesson'))
                    .filter(el => el.dataset.lessonId !== currentDraggedLesson.lessonId && el.style.display !== 'none')
                    .map(el => ({
                        day: el.dataset.originalDay,
                        time: el.dataset.originalTime,
                        room: el.dataset.room
                    }))
                    .filter(lesson => lesson.time && lesson.day);
                
                // Bestäm vilket rum som ska användas
                let finalRoom = currentDraggedLesson.room || 'Inget rum';
                
                if (!isRoomAvailableForTimeSlot(currentDraggedLesson.room, allCurrentLessons, newDay, newTimeRange)) {
                    const availableRooms = getAvailableRoomsForTimeSlot(allCurrentLessons, newDay, newTimeRange);
                    
                    if (availableRooms.length === 0) {
                        showConflictMessage('🏫 Inga lediga rum tillgängliga för denna tid. Välj en annan tid.');
                        restoreLessonToOriginalPosition();
                        cleanupDragState();
                        return;
                    }
                    
                    finalRoom = availableRooms[0];
                    debugLog(`Room switched from ${currentDraggedLesson.room} to ${finalRoom} due to conflict`);
                }
                
                try {
                    // Flytta lektionen med eventuell salsbyte
                    const moveResult = await moveLessonWithRoomChange(
                        currentDraggedLesson.lessonId, 
                        newDay, 
                        newTimeSlot, 
                        newEndTime, 
                        finalRoom
                    );
                    
                    if (moveResult.success) {
                        if (finalRoom !== currentDraggedLesson.room) {
                            showSuccessToast(`✅ Lektion flyttad till ${newDay} ${newTimeRange} (sal ändrad till ${finalRoom})`);
                        } else {
                            showSuccessToast(`✅ Lektion flyttad till ${newDay} ${newTimeRange}`);
                        }
                        
                        // Cleanup omedelbart efter framgångsrik flytt
                        cleanupDragState();
                        
                        // Ladda om schemat efter kort delay
                        setTimeout(() => {
                            reloadEditSchedule();
                        }, 500);
                        
                        debugLog('Lesson moved successfully with potential room change', moveResult);
                    } else {
                        throw new Error(moveResult.error || 'Kunde inte flytta lektion');
                    }
                } catch (error) {
                    console.error('Error moving lesson:', error);
                    showConflictMessage(`❌ Fel vid flyttning: ${error.message}`);
                    restoreLessonToOriginalPosition();
                    cleanupDragState();
                }
            }



            /**
             * Check for conflicts when moving a lesson
             */
            // 2. Förenkla conflict checking - ta bort API-anrop som inte finns
            // Uppdatera checkMoveConflicts funktionen

            function timeToMinutes(timeStr) {
                if (!timeStr || typeof timeStr !== 'string') {
                    console.warn('timeToMinutes received invalid input:', timeStr);
                    return 0;
                }
                const parts = timeStr.split(':');
                if (parts.length < 2) {
                    console.warn('timeToMinutes received invalid time format:', timeStr);
                    return 0;
                }
                const [hours, minutes] = parts.map(Number);
                return (hours || 0) * 60 + (minutes || 0);
            }

            // Förbättrad checkMoveConflicts med 5-minuters buffer för klassrum
            // 2. Fix checkMoveConflicts för att hantera saknade tidsdata
            function checkMoveConflicts(lesson, newDay, newTime) {
                if (!newTime || typeof newTime !== 'string' || !newTime.includes('-')) {
                    console.warn('checkMoveConflicts received invalid newTime:', newTime);
                    return { canMove: false, reason: 'Ogiltig tid angiven' };
                }
                
                const [newStartTime, newEndTime] = newTime.split('-');
                const newStartMinutes = timeToMinutes(newStartTime);
                const newEndMinutes = timeToMinutes(newEndTime);
                
                const ROOM_BUFFER_MINUTES = 5;
                const TEACHER_BUFFER_MINUTES = 10;
                
                const currentLessons = Array.from(document.querySelectorAll('.spanning-lesson')).map(lessonEl => {
                    const originalTime = lessonEl.dataset.originalTime;
                    if (!originalTime || !originalTime.includes('-')) return null;
                    
                    const [startTime, endTime] = originalTime.split('-');
                    const lessonDay = lessonEl.dataset.originalDay;
                    
                    return {
                        id: lessonEl.dataset.lessonId,
                        day: lessonDay,
                        time: originalTime,
                        startMinutes: timeToMinutes(startTime),
                        endMinutes: timeToMinutes(endTime),
                        subject: lessonEl.dataset.subject,
                        room: lessonEl.dataset.room,
                        teacherId: lessonEl.dataset.teacherId,
                        teacherName: lessonEl.dataset.teacherName
                    };
                }).filter(Boolean);

                // Kontrollera lärarkonflikter med 10-minuters buffert
                const teacherConflicts = currentLessons.filter(l => {
                    if (l.day !== newDay || l.id === lesson.lessonId) return false;
                    
                    // Matcha lärare
                    const sameTeacher = (lesson.teacherId && l.teacherId === lesson.teacherId) || 
                                    (lesson.teacherName && l.teacherName === lesson.teacherName);
                    
                    if (!sameTeacher) return false;
                    
                    // Kontrollera buffertkonflikt
                    return (newStartMinutes < l.endMinutes + TEACHER_BUFFER_MINUTES && 
                            newEndMinutes + TEACHER_BUFFER_MINUTES > l.startMinutes);
                });

                if (teacherConflicts.length > 0) {
                    const conflictDetails = teacherConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Lärarkonflikt (${TEACHER_BUFFER_MINUTES} min buffert krävs): ${conflictDetails}` 
                    };
                }

                // Kontrollera klassrums-konflikter med 5-minuters buffert
                const roomConflicts = currentLessons.filter(l => 
                    l.day === newDay && 
                    l.id !== lesson.lessonId &&
                    l.room === lesson.room &&
                    (newStartMinutes < l.endMinutes + ROOM_BUFFER_MINUTES && 
                    newEndMinutes + ROOM_BUFFER_MINUTES > l.startMinutes)
                );

                if (roomConflicts.length > 0) {
                    const conflictDetails = roomConflicts.map(l => 
                        `${l.subject} (${l.time})`
                    ).join(', ');
                    
                    return { 
                        canMove: false, 
                        reason: `Klassrumskonflikt med ${ROOM_BUFFER_MINUTES}-min buffert: ${conflictDetails}` 
                    };
                }

                return { canMove: true };
            }


            async function moveLessonWithRoomChange(lessonId, newDay, newStartTime, newEndTime, newRoom) {
                try {
                    debugLog('Moving lesson with room change', {
                        lessonId, newDay, newStartTime, newEndTime, newRoom
                    });
                    
                    const response = await fetch(`/api/schedule/move_lesson/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            weekday: newDay,
                            start_time: newStartTime,
                            end_time: newEndTime,
                            room: newRoom // Inkludera rum i API-anropet
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte flytta lektion');
                    }

                    return result;

                } catch (error) {
                    console.error('Error in moveLessonWithRoomChange:', error);
                    throw error;
                }
            }


            // Uppdatera moveLesson för att hantera både start och end tid
            async function moveLessonWithEndTime(lessonId, newDay, newStartTime, newEndTime) {
                try {
                    const response = await fetch(`/api/schedule/move_lesson/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            weekday: newDay,
                            start_time: newStartTime,
                            end_time: newEndTime
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte flytta lektion');
                    }

                    return result;

                } catch (error) {
                    console.error('Error moving lesson:', error);
                    throw error;
                }
            }



            /**
             * Move lesson in database
             */
            // Uppdatera moveLesson funktionen för att använda riktig API
            // 2. Uppdatera moveLesson för att acceptera både start och end tid
            async function moveLesson(lessonId, newDay, newStartTime, newEndTime = null) {
                try {
                    // Om ingen sluttid angiven, räkna ut från starttid (60 min default)
                    if (!newEndTime) {
                        const startMinutes = timeToMinutes(newStartTime);
                        const endMinutes = startMinutes + 60; // Default 60 minuter
                        newEndTime = minutesToTime(endMinutes);
                    }
                    
                    debugLog('Moving lesson via API', {
                        lessonId,
                        newDay,
                        newStartTime,
                        newEndTime
                    });
                    
                    const response = await fetch(`/api/schedule/move_lesson/${lessonId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            weekday: newDay,
                            start_time: newStartTime,
                            end_time: newEndTime
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Kunde inte flytta lektion');
                    }

                    return result;

                } catch (error) {
                    console.error('Error in moveLesson:', error);
                    throw error;
                }
            }

            /**
             * Perform UI update after successful lesson move
             */
            function performLessonMove(lessonElement, targetCell, newDay, newTime) {
                // Remove from original location
                const originalCell = lessonElement.parentElement;
                originalCell.classList.remove('occupied');
                originalCell.classList.add('empty');
                
                // Add to new location
                targetCell.appendChild(lessonElement);
                targetCell.classList.add('occupied');
                targetCell.classList.remove('empty');
                
                // Update lesson data attributes
                lessonElement.dataset.originalDay = newDay;
                lessonElement.dataset.originalTime = newTime;
            }

            /**
             * Check and highlight schedule conflicts
             */
            // Enhanced conflict checking with real-time validation
            // 5. Förenkla konflikt-checking
            async function checkScheduleConflicts() {
                if (!isEditMode) return;
                
                // Clear existing conflict indicators
                document.querySelectorAll('.conflict-indicator').forEach(el => el.remove());
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    cell.classList.remove('has-conflict');
                    cell.style.background = '';
                });
                
                // Get all current lessons from the UI
                const currentLessons = Array.from(document.querySelectorAll('.draggable-lesson')).map(lessonEl => {
                    const cell = lessonEl.closest('.schedule-cell');
                    return {
                        id: lessonEl.dataset.lessonId,
                        day: cell.dataset.day,
                        time: cell.dataset.time,
                        subject: lessonEl.dataset.subject,
                        room: lessonEl.dataset.room
                    };
                });
                
                // Simple client-side conflict detection
                const roomConflicts = new Map();
                const timeConflicts = new Map();
                
                currentLessons.forEach(lesson => {
                    const timeKey = `${lesson.day}-${lesson.time}`;
                    const roomKey = `${lesson.room}-${timeKey}`;
                    
                    // Check for time conflicts (multiple lessons same time)
                    if (!timeConflicts.has(timeKey)) {
                        timeConflicts.set(timeKey, []);
                    }
                    timeConflicts.get(timeKey).push(lesson);
                    
                    // Check for room conflicts
                    if (!roomConflicts.has(roomKey)) {
                        roomConflicts.set(roomKey, []);
                    }
                    roomConflicts.get(roomKey).push(lesson);
                });
                
                // Mark conflicts
                roomConflicts.forEach((lessons, roomKey) => {
                    if (lessons.length > 1) {
                        lessons.forEach(lesson => {
                            const cell = document.getElementById(`cell-${lesson.day}-${lesson.time.replace(':', '-')}`);
                            if (cell) {
                                cell.classList.add('has-conflict');
                                
                                const indicator = document.createElement('div');
                                indicator.className = 'conflict-indicator';
                                indicator.style.cssText = `
                                    position: absolute;
                                    top: 2px;
                                    left: 2px;
                                    background: #f56565;
                                    color: white;
                                    font-size: 10px;
                                    padding: 2px 4px;
                                    border-radius: 2px;
                                    z-index: 100;
                                `;
                                indicator.textContent = '⚠️';
                                indicator.title = `Konflikt: Flera lektioner använder samma rum (${lesson.room})`;
                                
                                cell.style.position = 'relative';
                                cell.appendChild(indicator);
                            }
                        });
                    }
                });
                
                debugLog('Client-side conflict check completed');
            }


            /**
             * Show conflict message to user
             */
            function showConflictMessage(message) {
                // Create temporary notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #f56565, #e53e3e);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 0.5rem;
                    box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
                    z-index: 10000;
                    font-weight: 500;
                    animation: slideIn 0.3s ease-out;
                `;
                notification.innerHTML = `⚠️ ${message}`;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            /**
             * Show success toast message
             */
            function showSuccessToast(message) {
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #48bb78, #38a169);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 0.5rem;
                    box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);
                    z-index: 10000;
                    font-weight: 500;
                    animation: slideIn 0.3s ease-out;
                `;
                toast.innerHTML = `✅ ${message}`;
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            }

            /**
             * Update edit controls in generation panel
             */
            function updateEditControls() {
                const controls = document.getElementById('generationControls');
                if (!controls) return;
                
                // Replace normal controls with edit controls
                controls.innerHTML = `
                    <div class="edit-controls-header" style="margin-bottom: 1rem; padding: 1rem; background: #fef5e7; border-radius: 0.5rem; border-left: 4px solid #ed8936;">
                        <h4 style="margin: 0 0 0.5rem 0; color: #744210;">✏️ Redigeringsläge aktiv</h4>
                        <p style="margin: 0; color: #744210; font-size: 0.9rem;">
                            Dra och släpp lektioner för att flytta dem. Alla ändringar sparas automatiskt.
                        </p>
                    </div>
                    
                    <div class="schedule-actions" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button type="button" class="btn" onclick="saveEditedSchedule()" style="background: #48bb78;">
                            💾 Spara ändringar
                        </button>
                        <button type="button" class="btn" onclick="discardScheduleChanges()" style="background: #f56565;">
                            ❌ Avbryt redigering
                        </button>
                        <button type="button" class="btn" onclick="reloadEditSchedule()" style="background: #4299e1;">
                            🔄 Ladda om schema
                        </button>
                    </div>
                    
                    <div class="edit-info" style="margin-top: 1rem; padding: 0.75rem; background: #ebf8ff; border-radius: 0.375rem; font-size: 0.85rem; color: #2a4365;">
                        <strong>💡 Tips för redigering:</strong>
                        <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
                            <li>Dra lektioner till nya tider - systemet kollar automatiskt efter konflikter</li>
                            <li>Röda celler indikerar konflikter som måste lösas</li>
                            <li>Lärare och klassrum kan inte dubbelbokas</li>
                        </ul>
                    </div>
                `;
            }

            function handleDragLeave(event) {
                const cell = event.currentTarget;
                if (cell.classList.contains('drop-zone')) {
                    cell.style.background = 'rgba(66, 153, 225, 0.1)';
                    cell.style.borderColor = '#4299e1';
                }
                cell.title = '';
            }


            // 8. LÄGG TILL CSS-FIX för att förhindra text-selection under drag
            const dragFixStyles = `
            .editable-schedule-table {
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }

            .draggable-lesson {
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                cursor: grab;
            }

            .draggable-lesson:active {
                cursor: grabbing !important;
            }

            .draggable-lesson.dragging {
                opacity: 0.7 !important;
                transform: rotate(2deg) scale(1.05) !important;
                z-index: 1000 !important;
                box-shadow: 0 8px 16px rgba(0,0,0,0.3) !important;
                pointer-events: none;
            }

            .schedule-cell {
                position: relative;
            }

            /* Förhindra hover-effekter under drag */
            body.dragging .draggable-lesson:not(.dragging):hover {
                transform: none !important;
                box-shadow: 0 2px 4px rgba(0,0,0,0.15) !important;
            }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('drag-fix-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'drag-fix-styles';
                styleElement.textContent = dragFixStyles;
                document.head.appendChild(styleElement);
            }

            // Förbättrade drag handlers
            // 3. Fix handleDragEnter för att hantera null draggedLesson
            function handleDragEnter(event) {
                event.preventDefault();
                if (!draggedLesson) {
                    console.warn('handleDragEnter called without draggedLesson');
                    return;
                }
                
                const cell = event.currentTarget;
                const day = cell.dataset.day;
                const time = cell.dataset.time;
                
                if (!day || !time) {
                    console.warn('handleDragEnter: cell missing day or time data');
                    return;
                }
                
                // Beräkna ny tidsintervall baserat på lektionens längd
                const originalDuration = calculateLessonDuration(draggedLesson.originalTime);
                const newStartMinutes = timeToMinutes(time);
                const newEndMinutes = newStartMinutes + originalDuration;
                const newTimeRange = `${time}-${minutesToTime(newEndMinutes)}`;
                
                // Quick conflict check för visuell feedback
                const conflictCheck = checkMoveConflicts(draggedLesson, day, newTimeRange);
                
                if (conflictCheck.canMove) {
                    cell.style.background = 'rgba(72, 187, 120, 0.2)';
                    cell.style.borderColor = '#48bb78';
                    cell.title = 'Drop här för att flytta lektionen';
                } else {
                    cell.style.background = 'rgba(245, 101, 101, 0.2)';
                    cell.style.borderColor = '#f56565';
                    cell.title = conflictCheck.reason;
                }
            }


            // Enhanced initialization for edit mode
            document.addEventListener('DOMContentLoaded', function() {
                // Add global error handler for drag operations
                window.addEventListener('error', function(e) {
                    if (isEditMode && e.message.includes('drag')) {
                        console.error('Drag operation error:', e);
                        showConflictMessage('Fel vid drag-and-drop operation. Ladda om sidan om problemet kvarstår.');
                    }
                });
                
                // Add visibility change handler to prevent data loss
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden && isEditMode && draggedLesson) {
                        // User switched tabs while dragging - reset drag state
                        draggedLesson = null;
                        document.querySelectorAll('.draggable-lesson').forEach(el => {
                            el.style.opacity = '1';
                            el.style.transform = 'scale(1)';
                        });
                        document.querySelectorAll('.drop-zone').forEach(el => {
                            el.classList.remove('drop-zone');
                            el.style.background = '';
                            el.style.border = '';
                        });
                    }
                });
            });


            // Add keyboard shortcuts for edit mode
            document.addEventListener('keydown', function(e) {
                if (!isEditMode) return;
                
                // Escape to exit edit mode
                if (e.key === 'Escape') {
                    e.preventDefault();
                    discardScheduleChanges();
                }
                
                // Ctrl+S to save in edit mode
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    saveEditedSchedule();
                }
                
                // Ctrl+Z for undo (reload from database)
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    reloadEditSchedule();
                }
            });

            /**
             * Save edited schedule changes
             */
            // Enhanced save function for edited schedules
            // 6. Förenkla save-funktionen för editerat schema
            // Uppdatera saveEditedSchedule för att använda rätt API
            async function saveEditedSchedule() {
                if (!confirm('Spara alla ändringar i schemat?')) {
                    return;
                }
                
                const saveButton = event.target;
                const originalText = saveButton.textContent;
                saveButton.disabled = true;
                saveButton.textContent = '💾 Sparar...';
                
                try {
                    // För redigeringsläge, spara direkt via database-uppdatering
                    // Ändringarna har redan gjorts via moveLesson API-anrop
                    
                    showSuccessToast('✅ Alla ändringar sparade i databasen!');
                    debugLog('Schedule changes saved successfully');
                    
                    // Exit edit mode och visa uppdaterat schema
                    setTimeout(() => {
                        exitEditMode();
                        // Ladda om schemat från databasen för att visa uppdateringarna
                        if (editingClassId) {
                            editClassSchedule(editingClassId, editingClassName);
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('Error saving edited schedule:', error);
                    showConflictMessage(`Fel vid sparning: ${error.message}`);
                } finally {
                    saveButton.disabled = false;
                    saveButton.textContent = originalText;
                }
            }

            /**
             * Discard changes and exit edit mode
             */
            function discardScheduleChanges() {
                if (!confirm('Avbryt redigeringen och förlora alla ändringar?')) {
                    return;
                }
                
                exitEditMode();
                showSuccessToast('Redigering avbruten - inga ändringar sparade');
            }

            /**
             * Reload schedule from database
             */
            async function reloadEditSchedule() {
                if (!confirm('Ladda om schemat från databasen? Alla osparade ändringar går förlorade.')) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/class_schedule/status/${editingClassId}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        originalScheduleData = result;
                        displayEditableSchedule(result);
                        showSuccessToast('Schema laddat om från databasen');
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error reloading schedule:', error);
                    showConflictMessage(`Fel vid laddning: ${error.message}`);
                }
            }

            // Add CSS animations for notifications
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes slideOut {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
                
                .draggable-lesson:hover {
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
                }
                
                .schedule-cell.drop-zone {
                    border: 2px dashed #4299e1 !important;
                }
                
                .schedule-cell.has-conflict {
                    background: rgba(245, 101, 101, 0.1) !important;
                    border-color: #f56565 !important;
                }
            `;
            document.head.appendChild(style);

            async function saveMultiClassSchedule() {
                if (!currentSchedule || !currentSchedule.lessons) {
                    alert('Inget schema att spara');
                    debugLog('Save attempted with no schedule');
                    return;
                }

                if (selectedClasses.length === 0) {
                    alert('Inga klasser valda');
                    debugLog('Save attempted with no classes selected');
                    return;
                }

                // Confirm save action
                const confirmMessage = `Spara schema för ${selectedClasses.length} klass${selectedClasses.length !== 1 ? 'er' : ''}?\n\n` +
                    `Detta kommer att ersätta eventuella befintliga scheman för:\n${selectedClasses.map(c => `• ${c.name}`).join('\n')}`;
                
                if (!confirm(confirmMessage)) {
                    debugLog('Save cancelled by user');
                    return;
                }




                // Show saving indicator
                const saveButton = document.querySelector('button[onclick="saveMultiClassSchedule()"]');
                const originalText = saveButton.textContent;
                saveButton.disabled = true;
                saveButton.textContent = '💾 Sparar...';

                try {
                    debugLog('Saving multi-class schedule...', {
                        classes: selectedClasses.length,
                        lessons: currentSchedule.lessons.length
                    });

                    const response = await fetch('/api/multi_class_schedule/save', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            schedule: currentSchedule,
                            class_ids: selectedClasses.map(c => parseInt(c.id))
                        })
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        // Update save state
                        scheduleSaveState.hasUnsavedChanges = false;
                        scheduleSaveState.lastSavedSchedule = JSON.parse(JSON.stringify(currentSchedule));
                        
                        // Update class status
                        await updateClassScheduleStatus();
                        
                        // Show success message
                        showSuccessMessage(`✅ Schema sparat framgångsrikt!\n\n` +
                            `📊 ${result.lessons_saved} lektioner sparade\n` +
                            `🏫 ${result.classes_updated} klasser uppdaterade\n` +
                            `${result.classes_deleted_lessons > 0 ? `🗑️ ${result.classes_deleted_lessons} gamla lektioner ersatta` : ''}`);
                        
                        debugLog('Schedule saved successfully:', result);

                        // Update UI to show saved state
                        updateScheduleUI();

                    } else {
                        throw new Error(result.error || 'Okänt fel vid sparning');
                    }

                } catch (error) {
                    console.error('Error saving schedule:', error);
                    alert(`❌ Fel vid sparning av schema:\n${error.message}`);
                    debugLog('Save failed:', error);
                } finally {
                    // Restore button
                    saveButton.disabled = false;
                    saveButton.textContent = originalText;
                }
            }

            document.addEventListener('mousemove', function(e) {
                window.currentMousePosition = { x: e.clientX, y: e.clientY };
            });

            // Stop auto-scroll
            function stopAutoScroll() {
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                    autoScrollInterval = null;
                }
            }


            // Lägg till detta efter displayEditableScheduleWithAutoScroll funktionen
            function attachScrollListeners() {
                if (scheduleScrollContainer) {
                    scheduleScrollContainer.addEventListener('scroll', function() {
                        if (draggedLesson) {
                            setupAutoScrollBounds();
                        }
                    });
                    
                    scheduleScrollContainer.addEventListener('mouseenter', function() {
                        if (isEditMode) {
                            setupAutoScrollBounds();
                        }
                    });
                }
            }


            function startAutoScroll() {
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                }
                
                autoScrollInterval = setInterval(() => {
                    if (!draggedLesson || !scheduleScrollContainer || !window.currentMousePosition) {
                        return;
                    }
                    
                    const mousePos = window.currentMousePosition;
                    const containerRect = scheduleScrollContainer.getBoundingClientRect();
                    
                    // Kolla om musen är inom scroll-containern
                    const mouseInContainer = mousePos.x >= containerRect.left && 
                                            mousePos.x <= containerRect.right && 
                                            mousePos.y >= containerRect.top && 
                                            mousePos.y <= containerRect.bottom;
                    
                    if (!mouseInContainer) return;
                    
                    const scrollSpeed = 15;
                    const edgeZone = 40; // Större zon för lättare scroll
                    let didScroll = false;
                    
                    // Vertikal scroll - när musen är nära övre eller nedre kanten av containern
                    const distanceFromTop = mousePos.y - containerRect.top;
                    const distanceFromBottom = containerRect.bottom - mousePos.y;
                    
                    if (distanceFromTop < edgeZone && scheduleScrollContainer.scrollTop > 0) {
                        // Scroll upp
                        const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromTop) / edgeZone);
                        scheduleScrollContainer.scrollTop -= scrollAmount;
                        didScroll = true;
                    } else if (distanceFromBottom < edgeZone) {
                        // Scroll ner
                        const maxScroll = scheduleScrollContainer.scrollHeight - scheduleScrollContainer.clientHeight;
                        if (scheduleScrollContainer.scrollTop < maxScroll) {
                            const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromBottom) / edgeZone);
                            scheduleScrollContainer.scrollTop += scrollAmount;
                            didScroll = true;
                        }
                    }
                    
                    // Horizontal scroll - när musen är nära vänster eller höger kanten
                    const distanceFromLeft = mousePos.x - containerRect.left;
                    const distanceFromRight = containerRect.right - mousePos.x;
                    
                    if (distanceFromLeft < edgeZone && scheduleScrollContainer.scrollLeft > 0) {
                        // Scroll vänster
                        const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromLeft) / edgeZone);
                        scheduleScrollContainer.scrollLeft -= scrollAmount;
                        didScroll = true;
                    } else if (distanceFromRight < edgeZone) {
                        // Scroll höger
                        const maxScrollLeft = scheduleScrollContainer.scrollWidth - scheduleScrollContainer.clientWidth;
                        if (scheduleScrollContainer.scrollLeft < maxScrollLeft) {
                            const scrollAmount = Math.max(5, scrollSpeed * (edgeZone - distanceFromRight) / edgeZone);
                            scheduleScrollContainer.scrollLeft += scrollAmount;
                            didScroll = true;
                        }
                    }
                    
                    if (didScroll) {
                        debugLog('Auto-scrolled container', {
                            scrollTop: scheduleScrollContainer.scrollTop,
                            scrollLeft: scheduleScrollContainer.scrollLeft,
                            mousePos: mousePos,
                            containerRect: containerRect
                        });
                    }
                    
                }, 16); // ~60 FPS
            }


            const teacherBufferStyles = `
            .teacher-buffer-indicator {
                pointer-events: none;
                user-select: none;
                font-weight: bold;
                text-shadow: 0 1px 1px rgba(0,0,0,0.3);
            }

            .teacher-conflict-zone {
                position: relative;
            }

            .teacher-conflict-zone::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 2px;
                background: linear-gradient(90deg, transparent, #f56565, transparent);
                opacity: 0.8;
            }
            `;



            // Lägg till styles
            if (!document.getElementById('teacher-buffer-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'teacher-buffer-styles';
                styleElement.textContent = teacherBufferStyles;
                document.head.appendChild(styleElement);
            }

            // Lägg till CSS för nya klasser
            const enhancedConflictStyles = `
                .teacher-conflict-zone {
                    border: 2px solid #f56565 !important;
                    background: rgba(245, 101, 101, 0.3) !important;
                }

                .room-conflict-zone {
                    border: 2px dashed #ed8936 !important;
                    background: rgba(237, 137, 54, 0.15) !important;
                }

                .drop-zone {
                    border: 2px dashed #4299e1 !important;
                    background: rgba(66, 153, 225, 0.1) !important;
                }

                .drag-conflict-indicator {
                    pointer-events: none !important;
                    user-select: none;
                    font-weight: bold;
                }

                .schedule-cell {
                    transition: all 0.2s ease;
                    position: relative;
                }
                
                /* Förstärk markeringen */
                .schedule-cell.teacher-conflict-zone {
                    border-color: #f56565 !important;
                    border-style: solid !important;
                    border-width: 2px !important;
                }
                
                .schedule-cell.room-conflict-zone {
                    border-color: #ed8936 !important;
                    border-style: dashed !important;  
                    border-width: 2px !important;
                }
                
                .schedule-cell.drop-zone {
                    border-color: #4299e1 !important;
                    border-style: dashed !important;
                    border-width: 2px !important;
                }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('enhanced-conflict-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'enhanced-conflict-styles';
                styleElement.textContent = enhancedConflictStyles;
                document.head.appendChild(styleElement);
            }

            // Förbättrat visuell feedback system
            const enhancedStyles = `
                .schedule-cell.drop-zone {
                    border: 2px dashed #4299e1 !important;
                    background: rgba(66, 153, 225, 0.1) !important;
                }
                
                .schedule-cell.invalid-drop-zone {
                    border: 2px dashed #f56565 !important;
                    background: rgba(245, 101, 101, 0.1) !important;
                }
                
                .draggable-lesson:active {
                    cursor: grabbing !important;
                }
                
                .schedule-cell:hover {
                    background: rgba(0, 0, 0, 0.02);
                }
                
                #scheduleScrollContainer::-webkit-scrollbar {
                    width: 8px;
                    height: 8px;
                }
                
                #scheduleScrollContainer::-webkit-scrollbar-track {
                    background: #f1f1f1;
                    border-radius: 4px;
                }
                
                #scheduleScrollContainer::-webkit-scrollbar-thumb {
                    background: #c1c1c1;
                    border-radius: 4px;
                }
                
                #scheduleScrollContainer::-webkit-scrollbar-thumb:hover {
                    background: #a8a8a8;
                }
                
                .buffer-indicator {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 2px;
                    background: linear-gradient(90deg, transparent, #ffd700, transparent);
                    opacity: 0.8;
                }
            `;



            const preserveGridStyles = `
                .schedule-cell.lesson-start,
                .schedule-cell.lesson-middle,
                .schedule-cell.empty {
                    height: 20px !important;
                    border: 1px solid #e2e8f0 !important;
                    position: relative !important;
                    vertical-align: top !important;
                }
                
                /* Bevara rutnätet även när celler är tomma under drag */
                .schedule-cell {
                    min-height: 20px !important;
                    box-sizing: border-box !important;
                }
                
                /* Förhindra att lesson-middle celler kollapsar */
                .schedule-cell.lesson-middle {
                    background: linear-gradient(135deg, #4299e1, #3182ce) !important;
                    border-left: 1px solid rgba(255,255,255,0.3) !important;
                    border-right: 1px solid rgba(255,255,255,0.3) !important;
                }
            `;

            // Lägg till styles om de inte redan finns
            if (!document.getElementById('preserve-grid-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'preserve-grid-styles';
                styleElement.textContent = preserveGridStyles;
                document.head.appendChild(styleElement);
            }


            window.addEventListener('resize', setupAutoScrollBounds);

            window.addEventListener('resize', function() {
                if (scheduleScrollContainer) {
                    setupAutoScrollBounds();
                }
            });

            // Cleanup vid page unload
            window.addEventListener('beforeunload', function() {
                stopAutoScroll();
            });


            function restoreHiddenLesson() {
                if (draggedLesson && draggedLesson.originalCells) {
                    draggedLesson.originalCells.forEach(cell => {
                        const hiddenLesson = cell.querySelector(`#lesson-${draggedLesson.lessonId}`);
                        if (hiddenLesson && hiddenLesson.style.display === 'none') {
                            hiddenLesson.style.display = 'block';
                            // Återställ cellens läge
                            cell.classList.remove('empty');
                            if (cell === draggedLesson.originalCells[0]) {
                                cell.classList.add('lesson-start');
                            } else {
                                cell.classList.add('lesson-middle');
                            }
                        }
                    });
                }
            }


            // New function to restore lesson to original position if drop failed
            function restoreLessonToOriginalPosition() {
                if (!draggedLesson || !draggedLesson.originalCells) {
                    debugLog('Cannot restore lesson - missing data');
                    return;
                }
                
                debugLog('Restoring lesson to original position');
                
                draggedLesson.originalCells.forEach((cell, index) => {
                    const hiddenLesson = cell.querySelector(`#lesson-${draggedLesson.lessonId}`);
                    
                    if (hiddenLesson) {
                        // Återställ synligheten
                        hiddenLesson.style.display = 'block';
                    }
                    
                    // Återställ ursprungliga cellklasser utan att störa rutnätet
                    if (index === 0) {
                        // Första cellen behåller lesson-start
                        if (!cell.classList.contains('lesson-start')) {
                            cell.classList.add('lesson-start');
                        }
                        cell.classList.remove('empty');
                    } else {
                        // Mellan-celler behåller lesson-middle
                        if (!cell.classList.contains('lesson-middle')) {
                            cell.classList.add('lesson-middle');
                        }
                        cell.classList.remove('empty');
                    }
                });
            }

            // 3. FÖRBÄTTRA clearOriginalLessonCells - anropa ENDAST från markTeacherConflictCells
            function clearOriginalLessonCells() {
                if (!draggedLesson || !draggedLesson.originalCells || clearOriginalLessonCells.hasRun) {
                    return;
                }
                
                // Förhindra dubbelanrop
                clearOriginalLessonCells.hasRun = true;
                
                debugLog('Clearing original lesson cells', draggedLesson.originalCells.length);
                
                draggedLesson.originalCells.forEach((cell, index) => {
                    // Ta bort lesson content men behåll cell structure
                    const lessonInCell = cell.querySelector(`#lesson-${draggedLesson.lessonId}`);
                    if (lessonInCell) {
                        // Gör lektionen osynlig istället för att ta bort den helt
                        lessonInCell.style.display = 'none';
                    }
                    
                    // VIKTIGT: Behåll cellernas ursprungliga klasser och struktur
                    // Ta INTE bort lesson-start/lesson-middle klasserna här - det påverkar rutnätet
                    
                    // Behåll cell styling och drop handlers utan att ändra grundläggande struktur
                    if (!cell.hasAttribute('ondrop')) {
                        cell.setAttribute('ondrop', 'handleLessonDrop(event)');
                        cell.setAttribute('ondragover', 'handleDragOver(event)');
                        cell.setAttribute('ondragenter', 'handleDragEnter(event)');
                        cell.setAttribute('ondragleave', 'handleDragLeave(event)');
                    }
                });
            }



            // Also update the cleanupDragState function to better handle cell restoration:
            // 5. FÖRBÄTTRA cleanupDragState
            function cleanupDragState() {
                debugLog('Starting drag state cleanup');
                
                stopAutoScroll();
                
                // Reset clearOriginalLessonCells flag
                clearOriginalLessonCells.hasRun = false;
                
                // Ta bort alla visuella feedback-klasser
                document.querySelectorAll('.schedule-cell').forEach(cell => {
                    cell.classList.remove('drop-zone', 'teacher-conflict-zone', 'room-conflict-zone');
                    
                    // Återställ cell styling till default
                    if (cell.classList.contains('empty')) {
                        cell.style.cssText = `
                            padding: 0; 
                            border: 1px solid #e2e8f0; 
                            height: 20px;
                            position: relative; 
                            vertical-align: top;
                            transition: all 0.2s ease;
                            background: transparent;
                        `;
                    } else if (cell.classList.contains('lesson-middle')) {
                        cell.style.cssText = `
                            padding: 0; 
                            border: 1px solid #e2e8f0; 
                            height: 20px;
                            position: relative; 
                            vertical-align: top;
                            background: linear-gradient(135deg, #4299e1, #3182ce);
                            border-left: 1px solid rgba(255,255,255,0.3);
                            border-right: 1px solid rgba(255,255,255,0.3);
                        `;
                    }
                    
                    cell.title = '';
                });
                
                // Ta bort konfliktindikatorer
                document.querySelectorAll('.drag-conflict-indicator, .teacher-buffer-indicator').forEach(el => el.remove());
                
                // Reset draggedLesson
                draggedLesson = null;
                
                debugLog('Drag state cleanup completed');
            }


            // Update handleLessonDragEndEnhanced to handle restoration better:
            // Update handleLessonDragEndEnhanced to handle restoration better:
            // 2. FÖRBÄTTRA handleLessonDragEndEnhanced
            function handleLessonDragEndEnhanced(event) {
                event.stopPropagation();
                
                if (!draggedLesson) {
                    debugLog('Drag end called but no draggedLesson found');
                    return;
                }
                
                const lessonElement = event.target.closest('.draggable-lesson');
                if (lessonElement) {
                    // Återställ visuell feedback
                    lessonElement.style.opacity = '1';
                    lessonElement.style.transform = 'scale(1)';
                    lessonElement.style.zIndex = '';
                    lessonElement.style.boxShadow = '';
                }
                
                // Kontrollera om lektionen droppades framgångsrikt
                const wasSuccessfullyMoved = !draggedLesson.originalCells.some(cell => 
                    cell.contains(lessonElement)
                );
                
                if (!wasSuccessfullyMoved) {
                    debugLog('Drag ended without successful drop - restoring lesson');
                    restoreLessonToOriginalPosition();
                }
                
                // Cleanup efter en kort delay för att låta drop-handler köra först
                setTimeout(() => {
                    cleanupDragState();
                }, 100);
                
                debugLog('Enhanced drag ended');
            }

            // Lägg till styles
            if (!document.getElementById('enhanced-schedule-styles')) {
                const styleElement = document.createElement('style');
                styleElement.id = 'enhanced-schedule-styles';
                styleElement.textContent = enhancedStyles;
                document.head.appendChild(styleElement);
            }


            // Ersätt befintliga funktioner med förbättrade versioner
            window.displayEditableSchedule = displayEditableScheduleWithAutoScroll;
            window.createEditableLessonBlock = createEditableLessonBlockEnhanced;
            window.handleLessonDragStart = handleLessonDragStartEnhanced;
            window.handleLessonDragEnd = handleLessonDragEndEnhanced;


            window.markTeacherConflictCells = markTeacherConflictCells;
            window.clearOriginalLessonCells = clearOriginalLessonCells;
            window.restoreLessonToOriginalPosition = restoreLessonToOriginalPosition;
            window.cleanupDragState = cleanupDragState;


            debugLog('Enhanced drag-and-drop schedule editor loaded with 5-minute room buffer and auto-scroll');
            window.handleLessonDrop = handleLessonDrop;
            window.createEditableLessonBlockSpanning = createEditableLessonBlockSpanning;

            function setupAutoScrollBounds() {
                if (!scheduleScrollContainer) return;
                
                const rect = scheduleScrollContainer.getBoundingClientRect();
                
                dragScrollBounds = {
                    top: rect.top,
                    bottom: rect.bottom,
                    left: rect.left,
                    right: rect.right,
                    containerRect: rect
                };
                
                debugLog('Auto-scroll bounds updated:', {
                    bounds: dragScrollBounds,
                    scrollHeight: scheduleScrollContainer.scrollHeight,
                    clientHeight: scheduleScrollContainer.clientHeight,
                    scrollWidth: scheduleScrollContainer.scrollWidth,
                    clientWidth: scheduleScrollContainer.clientWidth
                });
            }


            // Initiera när sidan laddas
            document.addEventListener('DOMContentLoaded', function() {
                debugLog('Multi-class schedule generator loaded');
                validateSubjectHours();
            });
    </script>
</body>
</html>
